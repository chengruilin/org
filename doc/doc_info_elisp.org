#+TITLE: Info Document of Elisp
#+TODO: TODO(t) DOING(d!) PAUSE(p!) RESUME(r!) | DONE(e) LATER(l)

* DOING Emacs Lisp Document [10/41]
  - State "DOING"      from "TODO"       [2018-09-27 四 12:17]

** DONE [[elisp:(info-other-window%20"(elisp)Introduction")][1.Introduction]]
   CLOSED: [2018-09-27 四 00:10]
   - State "DOING"      from "TODO"       [2018-09-26 三 23:41]
** DONE [[elisp:(info-other-window "(elisp)Lisp Data Types")][2.Lisp Data Types]]
   CLOSED: [2018-09-27 四 23:59]
   - State "DOING"      from "TODO"       [2018-09-27 四 00:10]
*** Primitive types
    Each object blongs to one and only one primitive type.
    - integer
    - float
    - cons
    - symbol
    - string
    - vector
    - hash-table
    - subr
    - byte-code function
    - record
    - buffer

    Such type declarations do not exist in Emacs Lisp.
    A Lisp variables can have any type of value, and it remembers whatever value you store in it, type and all.
    
    Variables with Restricted Values:a small number of Emacs Lisp variables can only take on values of a certain type.

*** Printed Representation 
*** Comments
    #+BEGIN_SRC elisp
    ;; This is a commnet.
    '(this is the code)
    #+END_SRC
*** Programming Type
    | type                     | example                                  | description                                                                     |
    |--------------------------+------------------------------------------+---------------------------------------------------------------------------------|
    | Integer Type             | '-1','1','+1','1.'                       | The range depends on the machine.                                               |
    | Floating-Point Type      | '1500.0','+15e2','15.0e+2','+1500000e-3' | Uses the C data type 'double' to store the value                                |
    | Chatacter Type           | 'A','?B','?\n'                           |                                                                                 |
    | Symbol Type              | 'foo','FOO'                              | A "symbol" in GNU Emacs List is an object with a name                           |
    | Sequence Type            |                                          | "lists" and "arrays"                                                            |
    | Cons Cell Type           |                                          | "CAR" & "CDR", A Lisp list thus works as a "linked list" built up of cons cells |
    | Array Type               |                                          | one-dimensional, number of slots for holding/ referring Lisp objects            |
    | String Type              |                                          | an array of characters                                                          |
    | Vector Type              | [1 "two" (three)]                        | one-dimensional array of elements of any type                                   |
    | Chat-Table Type          |                                          | one-dimensional array of elements of any type, indexed by character codes.      |
    | Bool-Vector Type         |                                          | one-dimensional array elements must be 't' or 'nil'                             |
    | Hash Table Type          |                                          | a very fast kind of lookup table                                                |
    | Function Type            |                                          | In Lisp, functions are also Lisp objects.                                       |
    | Marco Type               |                                          | an object much like a function. CDR is a Lisp function object, include 'lambda' |
    | Primitive Funcetion Type |                                          | function callable from Lisp written in C language                               |
    | Byte-Code Type           |                                          | byte-compiling Lisp code                                                        |
    | Record Type              |                                          | much like a vector. create objects with new types not build into Emacs          |
    | Type Descriptors         |                                          | is a 'record' holds infomateion about a type                                    |
    | Autoload Type            |                                          | a list whose first element is the symbol 'autoload'                             |
    | Finalizer Type           |                                          | helps clean up after objects that are no longer needed                          |

*** Editing Types
    | Type                      | description                                                                            |
    |---------------------------+----------------------------------------------------------------------------------------|
    | Buffer Type               | hold text that can be edited                                                           |
    | Marker Type               | denotes a position in a specific buffer                                                |
    | Window Type               | describes the portion of the terminal screen that Emacs uses to display a buffer       |
    | Frame Type                | a screen area that contains one or more Emacs windows                                  |
    | Terminal Type             | a device capable of displaying one or more Emacs frames                                |
    | Window Configuration Type | stores information about the positions, sizes, and content of the window in a frame    |
    | Frame Configuration Type  | stores information about the positions, sizes, and content of the window in all frames |
    | Process Type              | usually means a running program                                                        |
    | Thread Type               | a separate thread of Emacs Lisp execution                                              |
    | Mutex Type                | an exclusive lock that threads can own and disown, for synchronize                     |
    | Condition Variable Type   | a device for a more complex thread synchronization than the one supported by a mutex   |
    | Stream Type               | an object can be used as a source or sink for characters                               |
    | Keymap Type               | maps keys typed by the user to commands                                                |
    | Overlay Type              | specifies properties that apply to a part of a buffer                                  |
    | Font Type                 | specifies how to diaplay text on a graphical terminal                                  |

*** Circular Objects
    To represent shared or circular structures within a complex Lisp objects;
    You can use the reader constructs '#N=' and '#N#'
    #+BEGIN_SRC elisp
    '(#1=(a) b #1#)
    equals
    ((a) b (a))
    #+END_SRC

*** Type Predicates
    Check the types of any arguments
    #+BEGIN_SRC elisp
    ;; error -> Wrong type argument: number-or-mark-p, a 
    (+ 2 'a)
    #+END_SRC

*** Equality Predicates
    Here we describe functions that test for equality between two objects.
    #+BEGIN_SRC elisp
    ;; result is 't'
    (eq 'foo 'foo)

    ;; result is nil
    (eq "asdf" "asdf")
    #+END_SRC

** DONE [[elisp:(info-other-window "(elisp)Numbers")][3.Numbers]]
   CLOSED: [2018-09-29 六 10:12]
   - State "DOING"      from "TODO"       [2018-09-28 五 00:15]

*** Integer Basics
    The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2**29 to 2**29 −1).
    Many machines provide a wider range.

    '#' followed by a letter specifies the radix:
    #+BEGIN_SRC elisp
      '(#b101100) ;; b for binary
      '(#o54)     ;; o for octal
      '(#x2c)     ;; x for hex
      '(#24r1k)   ;; #RADIXrINTEGER

      (+ most-positive-fixnum 0) ;; largest integer
      (+ most-negative-fixnum 0) ;; smallest integer
    #+END_SRC

*** Floating-Point Basics
    #+BEGIN_SRC elisp
      (/ 0.0 0.0)         ;; = 0.0e+NaN
      (isnan (/ 0.0 0.0)) ;; = t
      (frexp 10.0)        ;; = (0.625 . 4)
      (ldexp 1.5 2)       ;; = 6.0
      (copysign 2.3 -1.3) ;; = -2.3
      (logb 2.2)          ;; = 1
    #+END_SRC
    
*** Predicates on Numbers
    #+BEGIN_SRC elisp
      (floatp 1.2)     ;; = t
      (integerp 2)     ;; = t
      (numberp "aaa")  ;; = nil
      (natnump 11.2)   ;; = nil
      (zerop 0)        ;; = t
      (= 2 0)          ;; = nil
    #+END_SRC

*** Comparison of Numbers
    #+BEGIN_SRC elisp
      ;; Comparison of Numbers
      (= 2 2)         ;= t
      (eql 2 3)       ;= nil
      (/= 2 3)        ;= t
      (/= 2 2)        ;= nil
      (< 3 4)         ;= t
      (<= 3 4)        ;= t
      (> 4 5)         ;= nil
      (>= 3 5)        ;= nil
      (max 2 4 10 9)  ;= 10
      (min 2 4 10 9)  ;= 2
      (abs -9)        ;= 9
    #+END_SRC

*** Numeric Conversions
    #+BEGIN_SRC elisp
      ;; Numeric Conversions
      (float 2)       ;= 2.0
      (truncate 2.23) ;= 2
      (floor 3.65)    ;= 3
      (floor -1.7)    ;= -2
      (ceiling 1.2)   ;= 2
      (ceiling -2.9)  ;= -2
      (round 1.2)     ;= 1
      (round -1.2)    ;= -1
      (round -1.7)    ;= -2
    #+END_SRC
    
*** Arithmetic Operations
    #+BEGIN_SRC elisp
      ;; 1+ function -> NUMBER plus 1
      (setq foo 3)
      (1+ foo)
      (setq foo (1+ foo)) ;; like ++
      ;; 1- function -> NUMBER minus 1
      (setq foo 4)
      (1- foo)
      (setq foo (1- foo)) ;; like --
      ;; - function -> negation and subtraction
      (- 10 1 2 3 4)      ;= 0
      (- 10)              ;= -10
      (-)                 ;= 0
      ;; * function -> multiplies
      (*)                 ;= 1
      (* 1)               ;= 1
      (* 1 2 3 4)         ;= 1
      ;; / function -> divides
      (/ 6 2)             ;= 3
      (/ 5 2)             ;= 2
      (/ 5.0 2)           ;= 2.5
      (/ 5 2.0)           ;= 2.5
      (/ 5.0 2.0)         ;= 2.5
      (/ 4.0)             ;= 0.25
      (/ 4)               ;= 0
      (/ 25 3 2)          ;= 4
      (/ -17 6)           ;= -2
      ;; % function
      (% 9 4)             ;= 1
      (% -9 4)            ;= -1
      (% 9 -4)            ;= 1
      (% -9 -4)           ;= -1
      ;; mod function
      (mod 9 4)           ;= 1
      (mod -9 4)          ;= 3
      (mod 9 -4)          ;= -3
      (mod -9 -4)         ;= -1
      (mod 5.5 2.5)       ;= 0.5
    #+END_SRC

*** Rounding Operations
    #+BEGIN_SRC elisp
      ;; rounds FLOAT to the next lower integral value
      (ffloor 2.52)       ;= 2.0
      ;; rounds FLOAT to the next higher integral value
      (fceiling 2.15)     ;= 3.0
      ;; rounds FLOAT towards zero to an integral value
      (ftruncate 3.9)     ;= 3.0
      ;; rounds FLOAT to the nearest integral value
      (fround 3.55)       ;= 4.0
    #+END_SRC

*** Bitwise Operations
    #+BEGIN_SRC elisp
      ;; lsh function -> shifts bits in INTEGER to the left COUNT places
      (lsh 5 1)                     ;= 10 00000101 -> 00001010 = 5 * 2^1
      (lsh 7 1)                     ;= 14 00000111 -> 00001110 = 7 * 2^1
      (lsh 3 2)                     ;= 12 00000110 -> 00001100 = 3 * 2^2
      (lsh most-positive-fixnum 1)  ;= -2 0111.......1111 -> 1111......111110
      ;; ash function -> shifts bits in INTEGER to the left COUNT places, or to the right if COUNT is negative
      (ash -6 -1)       ;= -3 1111...11010 -> 1111...111101
      (ash 2 3)         ;= 16 000010 -> 010000
      ;; logand function -> return bitwise AND the arguments
      (logand 13 12)    ;= 12 1101 AND 1100 -> 1100
      (logand 19 12)    ;= 0 10011 AND 1100 -> 00000
      ;; logior function -> return bitwise inclusive OR of its arguments
      (logior 12 5)     ;= 13 1100 OR 0101 -> 1101
      (logior 12 5 7)   ;= 15 1100 OR 0101 OR 0111 -> 1111
      ;; logxor function -> return bitwise exclusive OR of its arguments
      (logxor 12 5)     ;= 9 1100 XOR 0101 -> 1001
      (logxor 12 5 7)   ;= 14 1100 XOR 0101 XOR 0111
      ;; lognot function -> return bitwise complement of its argument
      (lognot 5)        ;= -6 0000...000101 -> 1111...111010 (30 bits total)
    #+END_SRC

*** Math Functions
    #+BEGIN_SRC elisp
      ;; Argument 为弧度，角度 != 弧度
      ;; 弧度 = (PI * 角度) / 180.0
      (/ (* float-pi 90) 180)   ;= 1.572693
      (sin 1.572963)            ;= 0.99999 近似于 sin90 度 = 1
      (cos 1.572963)            ;= 0.002   近似与 cos90 度 = 0
      (/ (* float-pi 45) 180)   ;= 0.7864815
      (tan 0.7864815)           ;= 1.002 近似于 tan45 度 = 1
      ;;asin function -> X > -PI/2 && X < PI/2 && sinX=Y -> (asin Y) = X (Y 超过[-1,1]返回 NaN)
      (asin 1)                  ;= 1.57
      ;;acos function -> X > 0 && X < PI && cosX=Y -> (acos Y) = X (Y 超过[-1,1]返回 NaN)
      (acos 0)                  ;= 1.57
      ;;atan function -> X > -PI/2 && X < PI/2 && atanX=Y -> (atan Y) = X
      (atan 1)                  ;= 0.78
      (atan 1 2)                ;= 0.46 is the angle in radians between the vector [1, 2] and the 'X' axis
      ;; exp function
      (exp 1)                   ;= 2.718 return
      ;; log function
      (log 4)
      ;; expt function -> return X reised to power Y
      (expt 3 2)
      ;; sqat
      (sqrt -10)
    #+END_SRC

*** Random Numbers
    #+BEGIN_SRC elisp
      ;; random function -> return random number in interval [0,LIMIT]
      (random)            ; = X X >=0 && X < 100
      (random 100)        ; = X X > most-negative-fixnum && X < most-positive-fixnum
    #+END_SRC
** DONE [[elisp:(info-other-window "(elisp)Strings and Characters")][4.Strings and Characters]]
   CLOSED: [2018-09-29 Sat 18:08]
   - State "DOING"      from "TODO"       [2018-09-29 六 10:13]
*** String Basics
    A character is a Lisp object which represents a single character of text.
    A string is a fixed sequence of characters.
    Since strings are arrays, you can operate on them with general array and sequence functions.
*** Predicates for Strings
    #+BEGIN_SRC elisp
      ;; Predicates for Strings
      ;; stringp function -> check argument is a string nor not
      (stringp "asd")    ;= t
      (stringp 1)        ;= nil
      (stringp nil)      ;= nil
      (stringp 'a')      ; error!
      ;; string-or-null-p function -> check argument is a string or 'nil'
      (string-or-null-p nil)    ;= t
      (string-or-null-p "aab")  ;= t
      (string-or-null-p 12)     ;= nil
      ;; char-or-string-p function -> check argument is a string or a character(i.e., an integer)
      (char-or-string-p "asd")  ;= t
      (char-or-string-p 12)     ;= t
      (char-or-string-p ?a)     ;= t
      (char-or-string-p nil)    ;= nil
    #+END_SRC
*** Creating Strings
    #+BEGIN_SRC elisp
      ;; make-string function -> made up of COUNT repetition of CHARACTER. COUNT must >= 0
      (make-string 4 ?x)                          ;= "xxxx"
      (make-string 0 ?x)                          ;= ""
      (make-string -1 ?)                          ; error!
      ;; string function -> contain the characters
      (string ?a ?b ?c)                           ;= "abc"
      ;; substring function -> return a new string consists of those characters[START, END]
      (substring "abcdefg" 0 3)                   ;= "abc"
      (substring "abcdefg")                       ;= "abcdefg" just copy the string
      (substring "abcdefg" -3 -1)                 ;= "ef" A negative number counts from the end of the string
      (substring "abcdefg" -3 nil)                ;= "efg" 'nil' used for END, it stands for the length for the string.
      (substring "abcdefg" 0)                     ;= "abcdefg" retun a copy of string
      (substring [a b (c)] 1 3)                   ;= [b (c)] also accepts a vector for the first argument
      ;; substring-no-properties function -> works like substring, but discards all text properties
      (substring-no-properties "abcdefg" 0 3)     ;= "abc"
      ;; concat function -> return a new string consisting of the characters in the arguments passed to it
      (concat "abc" "-def")                       ;= "abc-def"
      (concat "abc" (list 120 121) [122])         ;= "abcxyz"
      (concat "abc" nil "-def")                   ;= "abc-def" 'nil' is an empty sequence
      (concat)                                    ;= ""
      ;; splite-string function -> splits STRING into substrings
      (split-string "  tow words ")               ;= ("two" "words")
      (split-string "  tow words " split-string-default-separators) ;=("" "two" "words" "")
      (split-string "Soup is good food" "o")      ;= ("S" "up is g" "" "d f" "" "d")
      (split-string "Soup is good food" "o" t)    ;= ("S" "up is g" "d f" "d")
      (split-string "Soup is good food" "o+")     ;= ("S" "up is g" "d f" "d")
      (split-string "aooob" "o*")                 ;= ("" "a" "" "b" "")
      (split-string "ooaboo" "o*")                ;= ("" "" "a" "b" "")
      (split-string "" "")                        ;= ("")
      (split-string "Soup is good food" "o*" t)   ;= ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
      (split-string "Nice doggy!" "" t)           ;= ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
      (split-string "ooo" "o*" t)                 ;= nil
      (split-string "ooo" "\\|o+" t)              ;= ("o", "o", "o")
    #+END_SRC
    | variable                        | default value   | description                                        |
    |---------------------------------+-----------------+----------------------------------------------------|
    | split-string-defualt-separators | "[ \f\t\n\r\v]" | The default value of SEPARATORS for ~split-string~ |
*** Modifying Strings
    #+BEGIN_SRC elisp
      ;; store-substring function -> alters part of string by index and replace string
      (store-substring "asdoasdfoa" 0 "insert")   ;= "insertdfoa"
      ;; clear-string function -> make string a unibyte string and clear its contents to zeros. length change.
      (clear-string "aaa")                        ;= nil
      (length (clear-string "abcdefg"))           ;= 0
    #+END_SRC
*** Text Comparison
    #+BEGIN_SRC elisp
      ;; char-equal function -> check arguments represent the sam character
      (char-equal ?x ?a)                   ;= nil
      (char-equal ?x ?x)                   ;= t
      (let ((case-fold-search nil))
        (char-equal ?x ?X))                ;= nil ignore differences in case if 'case-fold-search' is non- 'nil'
      ;; string= function -> check if the two strings match exactly
      (string= "asdf" "asdf")              ;= t
      (string= "asdf" "asd")               ;= nil
      (string= "asdf" "ASDF")              ;= nil
      ;; string-equal -> another name for 'string='
      (string-equal "aaa" "aaa")           ;= t
      (string-collate-equalp "a" "a")      ;= t
      (string-collate-equalp (string ?\uFF40) (string ?\u1FEF)) ;= t characters with different coding points but the same mean might be considered as equal. Do not use this function compare file names.
      ;; string< function -> compare two strings a character at a time
      (string< "aa" "aa")                  ;= nil
      (string< "aa" "ac")                  ;= t
      (string< "" "abc")                   ;= t
      ;; string-lessp function -> another name for 'string<'
      (string-lessp "aaa" "bbb")           ;= t
      (string-greaterp "cc" "aa")          ;= t compare in the opposite order, equivalent to (string-lessp "aa" "cc")
      ;; string-collate-lessp function -> compare two strings in collation order
      (sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp) ;= ("11" "1 1" "1.1" "12" "1 2" "1.2")
      ;; string-version-lessp function -> compare numbers in two strings
      (string-version-lessp "foo2.png" "foo12.png") ;= t
      ;; string-prefix-p function -> check if string1 is a prefix of string2
      (string-prefix-p "A" "Abc")          ;= t
      (string-prefix-p "a" "Abc")          ;= nil
      (string-prefix-p "a" "Abc" t)        ;= t you can add 'ignore-case' argument
      ;; string-suffix-p function -> check if string1 is a suffix of string2
      (string-suffix-p "C" "abC")          ;= t
      (string-suffix-p "c" "abC")          ;= nil
      (string-suffix-p "c" "abC" t)        ;= t you can add 'ignore-case' argument
      ;; compare-strings function -> strings are compared by the numberic values of their characters
      (compare-strings "abcdefg" 1 3 "bbbbabc" 5 7)                 ;= t "bc" compare with "bc"
      (compare-strings "abcdefg" 1 3 "bbbbabc" 1 3)                 ;= 2 "bc" compare with "bb"
      (compare-strings "abcc" 1 3 "bcbc" 1 3)                       ;= -1 "bc" compare with "cb"
      (compare-strings "abcccccc" 1 5 "ZZZZZZZ" 2 4)                ;= 1
      (compare-strings "abcccccc" 1 5 "zzzzzzz" 2 4 t)              ;= -1
      ;; assoc-string function -> like function 'assoc'
      (assoc-string "key" (list "keys" "aaa" "key"))                ;= "key"
      (assoc-string "key" (list "keys" "aaa" "KEY"))                ;= nil
      (assoc-string "key" (list "keys" "aaa" "KEY") t)              ;= "key"
    #+END_SRC
*** String Conversion
    Describs functions for converting between characters, strings, and integers.
    #+BEGIN_SRC elisp
      ;; number-to-string function -> convert a NUMBER to string
      (number-to-string 222)               ;= "222"
      (number-to-string 0222)              ;= "222"
      (number-to-string -22)               ;= "-22"
      (int-to-string 22)                   ;= "22" a semi-obsolete alias for this function
      ;; string-to-number function -> return the numeric value of the characters in STRING
      (string-to-number "256")             ;= 256
      (string-to-number "256 is a number") ;= 256
      (string-to-number "Number 22")       ;= 0
      (string-to-number "-4.5")            ;= -4.5
      ;; char-to-string function
      (char-to-string ?x)                  ;= "x"
      ;; string-to-char function -> return the first character in STRING (a integer value)
      (string-to-char "")                  ;= 0
      (string-to-char "a")                 ;= 97
      ;; concat function -> vonverts a vector or a list into a string
      (concat "aaa" "bbb" "ccc")           ;= "aaabbbccc"
      (concat "list-" (list 97 98 99 100)) ;= "list-abcd"
      ;; vconcat function -> vonvert a string into a vector
      (vconcat "abc")                      ;= [97 98 99]
      ;; append function -> convert a string into a list
      (append "cba" (list "a" "b"))        ;= (99 98 97 "a" "b")
      ;; byte-to-string function -> convert a byte to unibyte string
      (byte-to-string 98)                  ;= "b"
    #+END_SRC
*** Formatting Strings
    #+BEGIN_SRC elisp
      ;; format function -> return a string equal to STRING
      (progn
        (setq x "foo")
        (eq x (format "%s" x)))                               ;= t object x and (format "%s" x) is the same object
      ;; %s -> Replace, Without quoting
      (format "%s is his name." "Tom")                        ;= "Tom is his name"
      ;; %S -> Replace, With quoting
      (format "%S is his name." "Tom")                        ;= "\"Tom\" is his name"
      ;; %o -> Replace, with base-eight representation of a unsigned integer
      (format "The value is %o." 10)                         ;= "The value is 12."
      ;; %d -> Replace, with base-ten representation of a signed integer
      (format "The value is %d." 10)                         ;= "The value is 10."
      ;; %x -> Replace, with base-sixteen representation of an unsigned integer, lower case
      (format "The value is %x." 12)                         ;= "The value is c."
      ;; %X -> Replace, with base-sixteen representation of an unsigned integer, upper case
      (format "The value is %X." 90)                         ;= "The value is 5A."
      ;; %c -> Replace, with character
      (format "The value is %c." 65)                         ;= "The value is A."
      ;; %e -> Replace, with exponential notation for a floating-point number
      (format "The value is %e." 65000000)                   ;= "The value is 6.500000e+07"
      ;; %f -> Replace, with decimal-point notation for a floating-point number
      (format "The value is %f." 65.23)                      ;= "The value is 65.230000."
      ;; %% -> Replace, with a single '%'
      (format "The value is %%%d." 65)                       ;= "The value is %65."

      (format "%2$s, %3$s, %%, %1$s" "x" "y" "z")            ;= "y, z, %, x"
      (format "%06d is padded on the left with zeros" 123)   ;= "000123 is padded on the left with zeros"
      (format "'%-6d' is padded on the right" 123)           ;= "'123   ' is padded on the right"
      (format "The word '%-7s' actually has %d letters in it."
              "foo" (length "foo"))                          ;= "The word 'foo    ' actually has 3 letters in it."
      (format "%5d is padded on the left with spaces" 123)   ;= "  123 is padded on the left with spaces"
      (format "The word '%7s' has %d letters in it."
              "foo" (length "foo"))                          ;= "The word '    foo' has 3 letters in it."
      (format "The word '%7s' has %d letters in it."
              "specification" (length "specification"))      ;= "The word 'specification' has 13 letters in it."
      ;; format-message function -> like 'format'
      (format-message
       "The name of this buffer is ‘%s’." (buffer-name))   ;= "The name of this buffer is ‘c2_lisp_bdata_type.el’."
    #+END_SRC
*** Case Conversion
    #+BEGIN_SRC elisp
      ;; downcase function -> convert string or char to lower case
      (downcase "AAAbbbCCC")                      ;= "aaabbbccc"
      (print ?X)                                  ;= 88
      (downcase ?X)                               ;=120
      ;; upcase function -> convert string or char to upper case
      (upcase "aaaBBBccc")                        ;="AAABBBCCC"
      (print ?X)                                  ;= 88
      (upcase ?x)                                 ;= 88
      ;; capitalize function -> capitalize the word of strings
      (capitalize "the cat in the hat")           ;= "The Cat In The Hat"
      (capitalize ?x)                             ;= 88
      ;; capitalize-initials function
      (upcase-initials "The CAT in the hAt")      ;= "The CAT In The HAt"
    #+END_SRC
*** Case Table
    You can customize case conversion by installing a special 'case table'.
    #+NAME: Case Table functions
    | function                | description                                                        | example                                |
    |-------------------------+--------------------------------------------------------------------+----------------------------------------|
    | case-table-p            | 'nil' if OBJECT is valid case table                                | case-table-p object                    |
    | set-standard-case-table | make TABLE the standard case table                                 | set-standard-case-table table          |
    | standard-case-table     | Return the standard case table                                     |                                        |
    | current-case-table      | Return the current buffer's case table                             |                                        |
    | set-case-table          | Set the current buffer's case table                                | set-case-table table                   |
    | set-case-synctax-pair   | Specifies a pair of corresponding letters                          | set-case-synctax-pair uc lc case-table |
    | set-case-syntax-delims  | Make characters L and R matching pair of case-invariant delimiters | set-case-synctax-delims l r case-table |
    | set-case-syntax         | Make CHAR case-invariant, with synctax SYNTAX                      | set-case-syntax char syntax case-table |

    #+NAME: Case Table Macro
    | macro           | description                                            | example                    |
    |-----------------+--------------------------------------------------------+----------------------------|
    | with-case-table | save the current case table, make TABLE the case table | with-case-table table body |

** DONE [[elisp:(info-other-window%20"(elisp)Lists")][5.List]]
   CLOSED: [2018-09-30 日 17:56]
   - State "DOING"      from "TODO"       [2018-09-29 Sat 18:09]
*** Cons Cells
    - Lists in Lisp are not a primitive data type; they are built up from 'cons cells'.
    - A cons cell is a data object that represents an orderd pair.[CAR, CDR]
    - A list is a series of cons cells chained together, so that each cell refers to the next one.
    - The CARs of the cons cells hold the elements of the list, and the CDRs are used to chain the list.
*** Predicates on Lists
    #+BEGIN_SRC elisp
      ;; Predicates on Lists
      ;; consp function -> check if argument is a cons cell
      (consp "aa")              ;= nil
      (consp '(1 . 3))          ;= t
      ;; atom function -> check if argument is an atom
      (atom "a")                ;= t
      (atom '(1 . "a"))         ;= nil
      (not (consp "a"))         ;= t
      ;; listp function -> check if argument is a cons cell
      (listp '(1))              ;= t
      (listp '(1 3))            ;= t
      (listp '())               ;= t
      ;; nlistp function -> check if argument is not a list
      (nlistp 1)                ;= t
      (not (nlistp "1"))        ;= nil
      ;; null function -> check if argument is 'nil'
      (null 1)                  ;= nil
      (null nil)                ;= t
      (null '(1))               ;= nil
      (null '())                ;= t
    #+END_SRC
*** List Elements
    #+BEGIN_SRC elisp
      ;; car function -> return the value referred to by the first slot of the cons cell
      (car '(1 . 3))                 ;= 1
      (car '(a b c))                 ;= a
      (car '())                      ;= nil
      ;; cdr function -> return the value referred to by the first slot of the cons cell
      (cdr '(3 . 4))                 ;= 4
      (cdr '(a b c))                 ;= (b c)
      (cdr '())                      ;= nil
      ;; car-safe function -> take the CAR of a cons cell while avoiding errors for other data types.
      (car-safe 1)                   ;= nil
      (car "a")                      ; error!
      (car-safe "a")                 ;= nil
      (car-safe '(5 . 3))            ;= 5
      ;; cdr-safe function -> take the CDR of a cons cell while avoiding errors for other data types.
      (cdr "a")                      ; error!
      (cdr-safe "a")                 ;= nil
      (cdr-safe '(5 . 3))            ;= 3
      ;; nth function -> return the Nth element of LIST
      (nth 2 '(1 2 3 4))             ;= 3
      (nth 10 '(1 2 3 4))            ;= nil
      (car (nthcdr 2 '(1 2 3 4)))    ;= 3
      ;; nthcdr function -> return the Nth CDR of LIST
      (nthcdr 1 '(1 2 3 4))          ;= (2 3 4)
      (nthcdr 10 '(1 2 3 4))         ;= nil
      (nthcdr 0 '(1 2 3 4))          ;= (1 2 3 4)
      ;; last function -> return the last link of LIST
      (last '(1 3 5 7))              ;= 7
      (last '(1 3 5 7) 2)            ;= (5 7)
      (last '(1 3 5 7) 0)            ;= nil
      (last '(1 3 5 7) 12)           ;= (1 3 5 7)
      (last '())                     ;= nil
      ;; safe-length function -> return length of LIST with no risk of either an error or an infinite loop.
      (safe-length 1)                ;= 0
      (length 1)                     ; error !
      (safe-length '(1 2 3 4))       ;= 4
      ;; caar function -> the same as (car (car CONS-CELL))
      (caar '((b) a ))               ;= b
      ;; cadr function -> the same as (car (cdr CONS-CELL)) or (nth 1 CONS-CELL)
      (cadr '(a (b c)))              ;= (b c)
      ;; cdar function -> the same as (cdr (car CONS-CELL))
      (cdar '((a c) b))              ;= (c)
      ;; cddr function -> the same as (cdr (cdr CONS-CELL))
      (cddr '((a c) b e))            ;= (e)
      ;; butlast function -> return the last X with the last element or the last N elements, removed.
      (butlast '(1 2 3 4 5))         ;= (1 2 3 4)
      (butlast '(1 2 3 4 5) 2)       ;= (1 2 3)
      ;; nbutlast function -> a version of 'butlast'
      (nbutlast '(1 2 3 4 5))        ;= (1 2 3 4)

      ;; pop macro -> provide a convenient way to examine the CAR of a list, and take it off the list, all at once.
      (pop x)
      ;; equivalent to
      (prog1 (car listname) (setq listname (cdr listname)))
    #+END_SRC
*** Building Lists
    #+BEGIN_SRC elisp
      ;; cons function -> create a new cons cell, make arg1 the CAR, and arg2 the CDR
      (cons 1 '(2))                  ;= (1 2)
      (cons 1 '())                   ;= (1)
      (cons 1 2)                     ;= (1 . 2)
      ;; list function -> create a list with OBJECTS as its elements
      (list 1 2 3 4 5)               ;= (1 2 3 4 5)
      (list 1 2 '(3 4 5) 'foo)       ;= (1 2 (3 4 5) foo)
      (list)                         ;= nil
      ;; make-list function -> creates a list of LENGTH elements
      (make-list 3 'pigs)            ;= (pigs pigs pigs)
      (make-list 0 'pigs)            ;= nil
      (setq l (make-list 3 '(a b)))  ;=((a b) (a b) (a b))
      (eq (car l)(cadr l))           ;= t
      ;; append function -> return a list containing all the elements of SEQUENCES(must be list)
      (setq ll (make-list 2 '(a b)))
      (append '(1 2 3) ll)           ;= (1 2 3 (a b) (a b))
      (append [a b] "cd" nil)        ;= (a b 99 100)
      (apply 'append '((a b c) nil (x y z))) ;= (a b c x y z) with 'apply', we can append all the lists in a list of lists
      (append)                       ;= nil
      (append '(x y) 'z)             ;= (x y . z)
      (append '(x y) [z])            ;= (x y . [z])
      ;; copy-tree function -> retuan a copy of the tree
      (copy-tree '(1 2 (3 4) (2. 3)))    ;= (1 2 (3 4) (2 3))
      (copy-tree '(1 2 (3 4) (2. 3)) t)  ;= (1 2 (3 4) (2 3)) so...what is different?
      ;; number-sequence function -> return a list of numbers [START.....END]
      (number-sequence 4 9)          ;= (4 5 6 7 8 9)
      (number-sequence 9 4 -1)       ;= (9 8 7 6 5 4)
      (number-sequence 8)            ;= (8)
      (number-sequence 5 8 -1)       ;= nil
      (number-sequence 1.5 6 2)      ;= (1.5 3.5 5.5)
    #+END_SRC
*** List Variables
    #+BEGIN_SRC elisp
      ;; push macro -> create a new list whose CAR is ELEMENT and whose CDR is the list
      (setq l '(a b))                ;= (a b)
      (push 'c l)                    ;= (c a b)
      (pop l)                        ;= c
      ;; add-to-list function -> set the variable SYMBOL by consing ELEMENT onto the old value(if ElEMENT is not already a member of that value)
      (setq foo '(a b))              ;= (a b)
      (add-to-list 'foo 'c)          ;= (c a b)
      (add-to-list 'foo 'b)          ;= (c a b)
      ;; add-to-ordered-listp function -> set the variable SYMBOL
      (setq foo '())                 ;= nil
      (add-to-ordered-list 'foo 'a 1);= (a)
      (add-to-ordered-list 'foo 'c 3);= (a c)
      (add-to-ordered-list 'foo 'b 2);= (a b c)
      (add-to-ordered-list 'foo 'b 4);= (a c b)
      (add-to-ordered-list 'foo 'd)  ;= (a c b d)
      (add-to-ordered-list 'foo 'e)  ;= (a c b e d)
    #+END_SRC
*** Modifying Lists
**** Setcar
     Replacing an element in a list.
     #+BEGIN_SRC elisp

       ;; setcar function -> sotre OBEJCT as the new CAR of CONS replacing its previous CAR
       (setq x '(1 2))                ;= (1 2)
       (setcar x 4)                   ;= 4
       x                              ;= (4 2)
       ;; when a cons cell is part of the shared structure of serveral lists.
       ;; storing a new CAR into the cons changes one element of each of these lists:
       (setq x1 '(a b c))             ;= (a b c)
       (setq x2 (cons 'z (cdr x1)))   ;= (z b c)
       (setcar (cdr x1) 'foo)
       x1                             ;= (a foo c)
       x2                             ;= (z foo c)
       ;; Replace the CAR of a link that is not shared
       (setcar x1 'baz)         ;= baz
       x1                       ;= (baz foo c)
       x2                       ;= (z foo c)
     #+END_SRC
     
     Here is the graphical show the changes:
     #+BEGIN_EXAMPLE
              --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

     #+END_EXAMPLE
**** Setcdr
     Replacing part of the list backbone.
     This can be used to remove or add elements.
     #+BEGIN_SRC elisp
       ;; setcdr function -> stores OBJECT as the new CDR of CONS, replacing its previous CDR.
       (setq x '(1 2 3))              ;= (1 2 3)
       (setcdr x '(4))                ;= (4)
       x                              ;= (1 4)
       ;; You can delete elemnts froom the middle of a list by altering the CDRs of the cons cells in the list.
       (setq x1 '(a b c))             ;= (a b c)
       (setcdr x1 (cdr (cdr x1)))     ;= (c)
       x1                             ;= (a c)
       ;; It is equally easy to inert a new elment by changing CDRs
       (setq x1 '(a b c))             ;= (a b c)
       (setcdr x1 (cons 'd (cdr x1))) ;=(d b c)
       x1                             ;=(a d b c)
     #+END_SRC

     Here is this result in box notation:
     #+BEGIN_EXAMPLE
                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

     #+END_EXAMPLE
**** Rearrangement
     Recording the elements in a list;combining lists. 
     #+BEGIN_SRC elisp
       ;; nconc function -> return a list containing all the elements of LISTS
       (setq x '(1 2 3))              ;= (1 2 3)
       (nconc x '(4 5))               ;= (1 2 3 4 5)
       x                              ;= (1 2 3 4 5)
       ;; The last argument of 'nconc' is not itself modified:
       (setq x1 '(1 2 3))             ;= (1 2 3)
       (nconc x1 'z)                  ;= (1 2 3 . z)
       x1                             ;= (1 2 3 . z)
     #+END_SRC
*** Sets And Lists
    #+BEGIN_SRC elisp
      ;; memq function -> test to see wether OBJECT is a member of LIST, return a list starting with the first occurrence of OBJECT.
      (memq 'b '(a b c b a))               ;= (b c b a)
      (memq '(2) '((1) (2)))               ;= nil '(2)' and '(2)' are not 'eq'
      ;; delq function -> removes all elements 'eq' to OBJECT from list, and return resulting list.
      (delq 'a '(a b c))                   ;= (b c)
      (delq 'b '(a b c))                   ;= (a c)
      ;; remq function -> return a copy of LIST, with all elements removed which are 'eq' to OBEJCT
      (setq sample-list '(a b c a b c))    ;= (a b c a b c)
      (remq 'a sample-list)                ;= (b c b c)
      sample-list                          ;= (a b c a b c)
      ;; memql function -> compare members with OBEJCT use 'eql', and return a list starting with the first occurrence of OBJECT.
      (memql 1.2 '(1.1 1.2 1.3))           ;= (1.2 1.3)
      (memq 1.2 '(1.1 1.2 1.3))            ;= nil
      ;; member function -> see weather OBJECT is a member of LIST(using 'equal')
      (member '(2) '((1) (2)))             ;= ((2))
      (memq '(2) '((1) (2)))               ;= nil
      (member "foo" '("foo" "bar"))        ;= ("foo" "bar")
      ;; delete function -> uses 'equal' to compare elements with OBJECT, then cut the element as 'delq' would
      (setq l '((2) (1) (2)))              ;= ((2) (1) (2))
      (delete '(2) l)                      ;= (1)
      ;; remove function -> non-desctructive counterpart of 'delete'
      (remove '(2) '((2) (1) (2)))         ;= ((1))
      (remove '(2) [(2) (1) (2)])          ;= [(1)]
      ;; member-ignore-case function -> like 'member' but ignores letter-case
      (member-ignore-case "A" '("b" "a" "c")) ;= ("a" "c")
      ;; delete-dups function -> Remove all 'equal' duplicates from LIST
      (setq l '((2) (1) (2) (2)))
      (delete-dups l)                      ;= ((2) (1) (2))
      l                                    ;= ((2) (1))
    #+END_SRC
*** Association Lists
    An "Association List", or "alist" for short, records a mapping form keys to values.
    It is a list of cons cells called "associations": the CAR of each cons cell is the "key", and the CDR is the "associated value".
    
    #+BEGIN_SRC elisp
      ;; assoc function -> return the first association for KEY in ALIST
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (assoc 'oak trees)                   ;= (oak . acorns)
      (setq needles-per-cluster
            '((2 "Austrian Pine" "Red Pine")
              (3 "Pitch Pine")
              (5 "White Pine")))
      (cdr (assoc 3 needles-per-cluster))  ;= ("Pitch Pine")
      (cdr (assoc 2 needles-per-cluster))  ;= ("Austrian Pine" "Red Pine")
      ;; rassoc function -> return the first association with value in ALIST
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (rassoc 'cones trees)                ;= (pine . cones)
      ;; assq function -> like 'assoc', but it makes the compare using 'eq'
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (assq 'pine trees)                   ;= (pine .cones)
      (setq leaves
            '(("simple leaves" . oak)
              ("compound leaves" . horsechestnut)))
      (assq "simple leaves" leaves)        ;= nil
      ;; alist-get function -> similar to 'assq', compare KEY, retuen VALUE
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (alist-get 'pine trees)              ;= cones
      ;; rassq function -> return first compare CDR 'eq' VALUE, return 'nil' if not found
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (rassq 'acorns trees)                ;= (oak . acorns)
      (rassq 'aa trees)                    ;= nil
      ;; assoc-default function -> search ALIST for a match for KEY
      (assoc-default 'pina trees)          ;= nil
      (assoc-default 'pine trees)          ;= cones
      ;; copy-list function -> create a new copy of each association
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (copy-list trees)                    ;= ((pine . cones) (oak . acorns) (maple . seeds))
      (setq copy (copy-list trees))
      (eq trees copy)                      ;= nil
      (equal trees copy)                   ;= t
      ;; assq-delete-all function -> delete from ALIST all the elements whose CAR is 'eq' to KEY, return eht shortened alist
      (setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
      (assq-delete-all 'foo alist)         ;= ((bar 2) (lose 4))
      alist                                ;= ((foo 1) (bar 2) (lose 4))
      ;; rassq-delete-all function -> delete from ALIST all the elements whose CDR is 'eq' to KEY, return eht shortened alist
      (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
      (rassq-delete-all 'acorns trees)     ;= ((pine . cones) (maple . seeds))
      trees                                ;= ((pine . cones) (maple . seeds))
    #+END_SRC
*** Property Lists
    A "property list" ("plist" for short) is a list of paired elements.
    Each of the pairs associates a property name (usually a symbol) with a property or value.
    Here is a example:
    #+BEGIN_SRC elisp
    (pine cones numbers (1 2 3) color "blue")
    #+END_SRC
**** Plists and Alists
     The property name must be distinct.
     Better than alist for attaching information to various Lisp function names for variables.
**** Plist Access
     #+BEGIN_SRC elisp
       ;; plist-get function -> return the value of the PROPERTY property stored in the property list PLIST
       (plist-get '(foo 4) 'foo)                       ;= 4
       ;; plist-put function -> store VALUE as the value of the PROPERTY property in the property list PLIST
       (setq my-plist '(bar t foo 4))                  ;= (bar t foo 4)
       (setq my-plist (plist-put my-plist 'foo 69))    ;= (bar t foo 9)
       ;; lax-plist-get function -> like 'plist-get', use 'equal' instead of 'eq'
       (lax-plist-get '("a" 4 "b" 5) "a")              ;= 4
       (plist-get '("a" 4 "b" 5) "a")                  ;= nil
       ;; lax-plist-put function -> like 'plist-put', use 'equal' instead of 'eq'
       (setq my-plist '("a" 4 "b" 5))                  ;= ("a" 4 "b" 5)
       (setq my-plist (lax-plist-put my-plist "a" 11)) ;= ("a" 11 "b" 5)
       (setq my-plist (plist-put my-plist "a" 21))     ;= ("a" 11 "b" 5 "a" 21)
       ;; plist-member function -> return 'nil' if PLIST not contains the given PROPERTY
       (setq my-plist '(bar t foo 4))
       (plist-member my-plist 'bar)                    ;= (bar t foo 4)
     #+END_SRC
** DONE [[elisp:(info-other-window "(elisp)Sequences Arrays Vectors")][6.Sequences, Arrays, and Vectors]]
   CLOSED: [2018-10-02 二 15:56]
   - State "DOING"      from "TODO"       [2018-09-30 日 17:59]

*** Summary
    The "sequence" type is the union of two other Lisp types: lists and arrays.
    An "array" is a fixed-length object with a slot for each of its elements.
    #+BEGIN_EXAMPLE
               _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

    #+END_EXAMPLE

*** Sequence Functions
    #+BEGIN_SRC elisp    
      ;; sequencep function -> check if the OBJECT is a list, vector, string, bool-vector, or char-table.
      (sequencep ?a)                     ;= nil
      (sequencep "a")                    ;= t
      (sequencep '(a b c))               ;= t
      ;;length function -> return the number of elements in SEQUENCE
      (length '(1 2 3))                  ;= 3
      (length ())                        ;= 0
      (length "foobar")                  ;= 6
      (length [1 2 3])                   ;= 3
      ;; elt function -> return the element of SEQUENCE indexed by INDEX
      (elt [1 2 3 4] 2)                  ;= 3
      (elt '(1 2 3 4) 2)                 ;= 3
      (string (elt "1234" 3))            ;= "4"
      (elt [1 2 3 4] 4)                  ; error! out of index.
      (elt [1 2 3 4] -1)                 ; error! out of index.
      ;; copy-sequence function -> return a copy of SEQUENCE
      (setq bar '(1 2))                  ;= (1 2)
      (setq x (vector 'foo bar))         ;= [foo (1 2)]
      (setq y (copy-sequence x))         ;= [foo (1 2)]
      (eq x y)                           ;= nil
      (equal x y)                        ;= t
      ;; reverse function -> create a new sequence whose elements are the elements of SEQUENCE, but in reverse order
      (setq x '(1 2 3 4))                ;= (1 2 3 4)
      (reverse x)                        ;= (4 3 2 1)
      x                                  ;= (1 2 3 4)
      (reverse "abc")                    ;= "cba"
      ;; nreverse function -> reverses the order of the element of SEQUENCE. the original SEQUENCE may be modified
      (setq x '(a b c))                  ;= (a b c)
      x                                  ;= (a b c)
      (nreverse x)                       ;= (c b a)
      x                                  ;= (a)
      (setq x [1 2 3 4])                 ;= [1 2 3 4]
      (nreverse x)                       ;= [4 3 2 1]
      x                                  ;= [4 3 2 1]
      ;; sort function -> sort SEQUENCE stably
      (sort '(1 3 4 2) '<)               ;= (1 2 3 4)
      (sort '(1 3 4 2) '>)               ;= (4 3 2 1)
      ;; seq.el library provides the following additional sequence mainpulation macros and functions.
      ;; seq-elt function -> get the element by index, return places settable using 'setf'
      (seq-elt [1 2 3 4] 2)              ;= 3
      (setq vec [1 2 3 4])               ;= [1 2 3 4]
      (setf (seq-elt vec 2) 5)           ;= 5
      vec                                ;= [1 2 5 4]
      ;; seq-length function -> return the number of elements in SEQUENCE
      (seq-length '(1 2 3 4))            ;= 4
      ;; seqp function -> check argument is a sequence
      (seqp [1 3])                       ;= t
      (seqp 2)                           ;= nil
      ;; seq-drop function -> return all but the first N elements of SEQUENCE
      (seq-drop [1 2 3 4 5 6] 3)         ;= [4 5 6]
      (seq-drop "hello world" -4)        ;= "hello world"
      ;; seq-take function -> return first N elements if SEQUENCE
      (seq-take '(1 2 3 4) 3)            ;= (1 2 3)
      (seq-take [1 2 3 4] 0)             ;= []
      ;; seq-take-while function -> get sequence before the first one for which PREDICATE return 'nil'
      (seq-take-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2)) ;= (1 2 3)
      ;; seq-drop-while function -> get sequence start from the first one for which PREDICATE return 'nil'
      (seq-drop-while (lambda (elt) (> elt 0)) '(1 2 3 -1 -2)) ;= (-1 -2)
      ;; seq-do function -> apply FUNCTION to each element of SEQUENCE
      (seq-do (lambda (elt) (+ elt 2)) '(1 2 3 4 5))
      ;; seq-map function -> return the result of apply function to each element
      (seq-map #'1+ '(2 4 5))             ;= (3 5 6)
      ;; seq-map-indexed function -> return result of apply function to each element and its index.
      (seq-map-indexed (lambda (elt idx)
                         (list idx elt))
                       '(a b c))          ;= ((0 a) (1 b) (2 c))
      ;; seq-mapn function -> get result of apply FUNCTION to each element
      (seq-mapn #'+ '(2 4 6) '(20 40 60)) ;= (22 44 66)
      ;; seq-filter function -> return a list of all the elements in SEQUENCE for PREDICATE return 'nil'
      (seq-filter (lambda (elt) (> elt 0)) [1 -1 3 -3 5])      ;= (1 3 5)
      ;; seq-remove function -> return a list of all elements
      (seq-remove (lambda (elt) (< elt 0)) '(-1 -3 -5))        ;= nil
      ;; seq-reduce function -> result of calling FUNCTION with INITIAL-VALUE
      (seq-reduce #'+ [1 2 3 4] 0)            ;= 10
      (seq-reduce #'+ [1 2 3 4] 5)            ;= 15
      ;; seq-some function -> return the first non- 'nil' value
      (seq-some #'numberp ["abc" 1 nil])      ;= t
      (seq-some #'null ["abc" 1 nil])         ;= t
      ;; seq-find function -> return the first element in SEQUENCE
      (seq-find #'numberp ["abc" 1 nil])      ;= 1
      (seq-find #'numberp ["abc" "abd"])      ;= nil
      ;; seq-every-p function -> return non- 'nil' if applying PREDICATE to every element
      (seq-every-p #'numberp [2 4 5])         ;= t
      (seq-every-p #'numberp [2 "a" 5 6])     ;= nil
      ;; seq-empty-p function -> return non- 'nil' if SEQUENCE is empty
      (seq-empty-p "not-empty")               ;= nil
      (seq-empty-p "")                        ;= t
      ;; seq-count function -> return the number of SEQUENCE for which PREDICATE
      (seq-count (lambda (elt) (> elt 0)) [-1 2 0 3 -2])   ;= 2
      ;; seq-sort function -> return a copy of SEQUENCE that is sorted according to FUNCTION
      (seq-sort #'> [1 3 4 2])                ;= [4 3 2 1]
      ;; seq-sort-by function -> similar to 'seq-sort', but the element of SEQUENCE are transformed by applying FUNCTION on them before being sorted
      (seq-sort-by #'seq-length #'> ["a" "ab" "abc"])      ;= ["abc" "ab" "a"]
      ;; seq-contains function -> return first element in SEQUENCE that is equal to ELT
      (seq-contains '(symbol1 symbol2) 'symbol1)           ;= symbol1
      ;; seq-set-equal-p function -> check whether SEQUENCE1 and SEQUENCE2 contain the same elements, regardless of the order.
      (seq-set-equal-p '(a b c) '(c b a))                  ;= t
      (seq-set-equal-p '(a b c) '(c b))                    ;= nil
      ;; seq-position function -> get the index of first element in SEQUENCE
      (seq-position '(a b c) 'b)                           ;= 1
      (seq-position '(a b c) 'd)                           ;= nil
      ;; seq-uniq function -> get a list of the elements of SEQUENCE with duplicates removed
      (setq list '(1 2 2 1 3 3))
      (seq-uniq list)                                      ;= (1 2 3)
      list                                                 ;= (1 2 2 1 3 3)
      ;; seq-subseq function -> get a subset of SEQUENCE from START to END
      (seq-subseq '(1 2 3 4 5) 1)                          ;= (2 3 4 5)
      (seq-subseq '[1 2 3 4 5] 1 3)                        ;= [2 3]
      ;; seq-concatenate function -> get a sequence made of the concatenation of SEQUENCES
      (seq-concatenate 'list '(1 2) '(3 4) [5 6])          ;= (1 2 3 4 5 6)
      (seq-concatenate 'string "Hello" " " "World")        ;= "Hello World"
      ;; seq-mapcat function -> return the result of applying 'seq-concatenate' to the result of applying FUNCTION to each element of SEQUENCE
      (seq-mapcat #'seq-reverse '((3 2 1) (6 5 4)))        ;= (1 2 3 4 5 6)
      ;; seq-partition function -> return a list of the element of SEQUENCE groupd into sub-sequence of length N
      (seq-partition '(0 1 2 3 4 5 6 7) 3)                 ;= ((0 1 2) (3 4 5) (6 7))
      ;; seq-intersection function -> return a list of the elements that appear both SEQUENCES
      (seq-intersection [2 3 4 5] [1 3 5 6 7])             ;= (3 5)
      ;; seq-difference function -> return a list of the elements appear in SEQUENCE1 but not in SEQUENCE2
      (seq-difference '(2 3 4 5) [1 3 5 6 7])              ;= (2 4)
      ;; seq-group-by function -> separate the elements of SEQUENCE into an alist whose keys are the result of applying FUNCTION to each element of SEQUENCE.
      (seq-group-by #'integerp '(1 2.1 3 2 3.2))           ;= ((t 1 3 2) (nil 2.1 3.2))
      ;; seq-into function -> convert the sequence into a sequence of type in ('vector', 'string', 'list')
      (seq-into [1 2 3] 'list)                             ;= (1 2 3)
      ;; seq-min function -> return the smallest element of SEQUENCE
      (seq-min [3 1 2])                                    ;= 1
      ;; seq-max function -> return the largest element of SEQUENCE
      (seq-max [1 3 2])                                    ;= 3
      ;; seq-random-elt function -> return an element of SEQUENCE taken a random
      (seq-random-elt [1 2 3 4])                           ;= 3
      ;; seq-doseq macro -> like 'dolist', except that SEQUENCE can be a lit, vector or string.
      (seq-doseq (var list) '(1 2 3))                        ;= (1 2 2 1 3 3)
      ;; seq-let macro -> binds the variable defined in ARGUMENTS to the elements of SEQUENCE
      (seq-let [first second] [1 2 3 4] (list first second)) ;= (1 2)
    #+END_SRC
    
*** Arrays
    An "array" object has slots that hold a number of other Lisp objecs, called the elements of the array.
    
    Emacs define four types of array
    1.strings
    2.vectors
    3.bool-vectors
    4.char-tables

    Array characteristics:
    1.First element of an array has index zero.
    2.The length of the array is fixed once you create it(can not change).
    3.The array is a constant.It evaluates to itself.
    4.Element may be referenced or changed with the functions 'aref' and 'aset'.

*** Array Functions
    #+BEGIN_SRC elisp
      ;; arrayp function -> check whether the argument is an array
      (arrayp [a])                      ;= t
      (arrayp "abc")                    ;= t
      ;;
      (setq primes [2 3 5 7 11 13])     ;= [2 3 5 7 11 13]
      (aref primes 4)                   ;= 11
      (aref "abcdefg" 1)                ; 98  'b' is ASCII code 98
      ;; aset function -> set the INDEXth element of ARRAY to be OBJECT
      (setq w [foo bar baz])            ;= [foo bar baz]
      (aset w 0 'fu)
      w                                 ;= [fu bar baz]
      ;; fillarray function -> fill the array with OBJECT
      (setq a [a b c d e f g])          ;= [a b c d e f g]
      (fillarray a 0)                   ;= [0 0 0 0 0 0 0]
    #+END_SRC

*** Vectors
    A "vector" is a general-purpose array whose elements can be any Lisp objects.
    
    Used in Emacs:
    1.As key sequences
    2.As symbol-lookup tables
    3.As part of the representation of a byte-compiled function

    Vector example:
    #+BEGIN_SRC elisp
    [a b a]
    #+END_SRC

*** Vector Functions
    #+BEGIN_SRC elisp
      ;; vectorp function -> return 't' if OBJECT is a vector
      (vectorp [a])                     ;= t
      (vectorp "abc")                   ;= nil
      ;; vector function -> create and return a vector
      (vector 'foo 23 [bar baz] "rats") ;= [foo 23 [bar baz] "rats"
      (vector)                          ;= []
      ;; make-vector function -> return a new vector consisting of LENGTH elements
      (setq sleepy (make-vector 9 'Z))  ;= [Z Z Z Z Z Z Z Z Z]
      ;; vconcat function -> return a new containing all the elements of SEQUENCES
      (setq a (vconcat '(A B C) '(D E F))) ;= [A B C D E F]
      (eq a (vconcat a))                   ;= nil
      (vconcat)                            ;= []
    #+END_SRC

*** Char-Tables
    A char-table is much like a vector, except that it is indexed by character codes.
 
    #+BEGIN_SRC elisp
      ;; make-char-table function -> retuan a newly-created char-table, with subtype(a symbol)
      ;; no argument to specify the length of the char-table, all char-table have room for any valid character code as index.
      (setq a-char-table (make-char-table  'my-test-subtype 100))
      ;; char-table-p function -> return 't' if OBJECT is a char-table
      (char-table-p a-char-table)                     ;= t
      ;; char-table-subtype function -> return sybtype symbol of CHAR-TABLE
      (char-table-subtype a-char-table)               ;= my-test-subtype
      ;; set-char-table-parent function -> set the parent of CHAR-TABLE to NEW-PARENT
      (setq another-char-table (make-char-table 'my-test-subtype))
      (set-char-table-parent another-char-table a-char-table)
      (aref a-char-table ?A)
      ;; char-table-parent function -> return the parent of CHAR-TABLE
      (char-table-parent another-char-table)
      ;; char-table-extra-slot function -> return contents of extra slot
      (char-table-extra-slot a-char-table 0)
      ;; set-char-table-extra-slot function -> store VALUE in extra slot N of CHAR-TABLE
      (set-char-table-extra-slot a-char-table 0 '(haha Hello World))
      ;; char-table-range function -> return the value specified in CHAR-TABLE for a range of characters RANGE
      (char-table-range char-table range)
      ;; set-char-table-range function -> set the value in CHAR-TABLE for a range of characters RANGE
      (set-char-table-range char-table range)
      ;; map-char-table function -> call its argument FUNCTION for each element of CHAR-TABLE that has a non- 'nil' value
      (let (accumulator)
        (map-char-table
         #'(lambda (key value)
             (setq accumulator
                   (cons (list
                          (if (consp key)
                              (list (car key) (cdr key))
                            key)
                          value)
                         accumulator)))
         (syntax-table))
        accumulator)
    #+END_SRC

*** Bool-Vectors
    A bool-vector is much like a vector, except that if stores only the value 't' and 'nil'.
    #+BEGIN_SRC elisp
      ;; make-bool-vector function -> return a new bool-vector of LENGTH elements, with initialized value
      (setq my-bool-v (make-bool-vector 10 nil))
      ;; bool-vector function -> create and return a bool-vector
      (bool-vector t nil t nil)                  ;;= #&4"^E"
      ;; bool-vector-p function -> return 't' if OBJECT is a bool-vector
      (bool-vector-p my-bool-v)
      ;; bool-vector-exclusive-or function -> return "bitwise exclusive or" of bool vectors A and B
      (bool-vector-exclusive-or a b &optional c)
      ;; bool-vector-union function -> return "bitwise or" of bool vectors A and B
      (bool-vector-union a b &optional c)
      ;; bool-vector-intersection function -> return "bitwise and" of bool vectors A and B
      (bool-vector-intersection a b &optional c)
      ;; bool-vector-set-difference function -> return "set difference" of bool vectors A and B
      (bool-vector-set-difference a b &optional c)
      ;; bool-vector-not function -> return "set complement" of bool vector A
      (bool-vector-not a &optional b)
      ;; bool-vector-subsetp function -> return 't' if every 't' value in A is also 't' in B
      (bool-vector-subsetp a b)
      ;; bool-vector-count-consecutive function -> return the number of consecutive elements in A equal B starting at I
      (bool-vector-count-consecutive a b i)
      ;; bool-vector-count-population function -> return the number of elements that are 't' in bool vector A
      (bool-vector-count-population a)
      ;; use 'vconcat' to print a bool-vector
      (vconcat (bool-vector t nil t nil))          ;= [t nil t nil]
      ;; example
      (setq bv (make-bool-vector 5 t))             ;=#&5"^_"
      (aref bv 1)                                  ;t
      (aset bv 3 nil)                              ;nil
      bv                                           ;#&5"^W"
    #+END_SRC
*** Rings
    A "ring" is a fixed-size data structure that supports insertion, delete, rotation, and modulo-indexed reference and traversal.
    #+BEGIN_SRC elisp
      ;; make-ring function -> return a new ring capable of holding SIZE objects
      (make-ring 3)                          ;= (0 0 . [nil nil nil])
      (make-ring 0)                          ;= (0 0 . [])
      ;; ring-p function -> return 't' if OBJECT is a ring
      (ring-p "a")                           ;= nil
      (setq a-ring (make-ring 3))            ;= (0 0 . [nil nil nil])
      (ring-p a-ring)                        ;= t
      ;; ring-size function -> return the maximum capable of the RING
      (ring-size a-ring)                     ;= 3
      ;; ring-length function -> return the number of objects that RING currently contains
      (ring-length a-ring)                   ;= 0
      ;; ring-elements function -> return a list of the objects in RING, in order, newest first
      (ring-elements a-ring)                 ;= nil
      ;; ring-copy function -> return a new ring which is a copy of RING.
      (ring-copy a-ring)                     ;= (0 0 . [nil nil nil])
      ;; ring-empty-p function -> return 't' if RING is empty
      (ring-empty-p a-ring)                  ;= t
      ;; ring-ref function -> return the object in RING found at index
      (ring-ref ring index)
      ;; ring-insert function -> insert OBJECT into RING, make it the newest element, and return OBJECT
      (ring-insert a-ring "a")
      ;; ring-remove function -> remove an object from RING, and return that object.
      (ring-remove a-ring 1)
      ;; ring-insert-at-beginning function -> insert OBJECT into RING, treating it as the oldest element
      (ring-insert-at-beginning a-ring "b")
      ;;  If you are careful not to exceed the ring size, you can use the ring as a first-in-first-out queue.  For example:
      (let ((fifo (make-ring 5)))
        (mapc (lambda (obj) (ring-insert fifo obj))
              '(0 one "two"))
        (list (ring-remove fifo) t
              (ring-remove fifo) t
              (ring-remove fifo)))                   ;= (0 t one t "two")
    #+END_SRC

** DONE [[elisp:(info-other-window "(elisp)Records")][7.Records]]
   CLOSED: [2018-10-02 二 16:25]
   - State "DOING"      from "TODO"       [2018-10-02 二 15:56]
*** Sumary
    - The purpose of records is to allow programmers to create objects with new types that are not build into Emacs.
    - They are used as the underlying representation of 'cl-defstruct' and 'defclass' instance.
    - A record object is much like a vector
    - In the current implementation records can have at most 4096 slots, whereas vectors can be much larger.
    - The slot has index 0.
    - The printed representation of records is '#s' followed by a list specifying the contents.

*** Record Functions
    #+BEGIN_SRC elisp
      ;; recordp function -> return 't' if OBJECT is a record
      (recordp "a")                          ;= nil
      (recordp #s(a))                        ;= t
      ;; record function -> create and return a record whose type is TYPE and remaining slots are the rest of the arguments, OBJECTS
      (record 'foo 23 [bar baz] "rats")      ;= #s(foo 23 [bar baz] "rats")
      ;; make-record function -> return a new record with type TYPE and LENGTH moew slots, each initialized to OBJECT
      (setq sleepy (make-record 'foo 9 'Z))  ;= #s(foo Z Z Z Z Z Z Z Z Z)
    #+END_SRC

*** Backward Compatibility
    
    #+BEGIN_SRC elisp
    ;; if ARG is positive, enable backward compatibility with old-style structs
    (cl-old-struct-compat-mode arg)
    #+END_SRC
** DONE [[elisp:(info-other-window "(elisp)Hash Tables")][8.Hash Tables]]
   CLOSED: [2018-10-04 四 21:19]
   - State "DOING"      from "TODO"       [2018-10-02 二 16:25]
*** Summary
    A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values.
    It differs from an alist in thest ways:
    - Lookup in a hash table is extremely fast for large tables, the time required is essentially independent of how many elements are stored in the table
    - The corresponding in a hash table are in no particular order
    - There is no way to share structure between two hash tables, the way two alists can share a common tail
      
    Hash tables have a special printed representation, which consists of '#s' followed by a list specifying the hash table properties and contents.

*** Creating Hash
    #+BEGIN_SRC elisp
      ;; make-hash-table function -> create a new hash table according to the specified arguments
      (setq myHash (make-hash-table
                    :test 'equal
                    :weakness 'key-and-value))
    #+END_SRC
**** :test TEST
     This specifies the method of key lookup for this hash table.
    #+NAME: Hash table ':test'
    | value | description                                                                    |
    |-------+--------------------------------------------------------------------------------|
    | eql   | Eaquel in value and either both are integers or both are floating point        |
    | eq    | Any two discinct Lisp objects are different as keys                            |
    | equal | Two Lisp objects are the same, as keys, if they are equal according to 'equal' |

**** :weakness WEAK
     The weakness of a hash table specifies whether the presence of a key or value in the hash table preserves it from garbage collection.

     #+NAME: Hash table ':weakness'
     | value         | description                                                                  |
     |---------------+------------------------------------------------------------------------------|
     | nil           |                                                                              |
     | key           | Hash table does not prevent its keys from being collected as garbage         |
     | value         | Hash table does not prevent values from being collected as garbage           |
     | key-or-value  | Either the key or the value can preserve the association                     |
     | key-and-value | Both the key and the value must be live in order to preserve the association |
     | t             | An alias for 'key-and-value'                                                 |

**** :size SIZE
     This specifies a hint for how many associations you plan to store in the hash table.
     The default size is 65.

**** :rehash-size REHASH-SIZE
     Hash table grows automatically when the table is full.
     Integer should be positive, grows by adding approximately much to the normal size.
     Float, had beeter be greater than 1, grows by multiplying the old size by approximately that number.
     The default value is 1.5.

**** :rehash-threshold THRESHOLD
     Specifies the criterion for when the hash table is full.
     The defult for THRESHOLD is 0.8125

*** Hash Access
    #+BEGIN_SRC elisp
      ;; puthash function -> enter an association for KEY in table , with value
      (puthash "key1" "value1" myHash)         ;= "value1"
      ;; gethash function -> looks up KEY in TABLE, return its associated VALUE
      (gethash "key2" myHash)                  ;= nil
      (gethash "key1" myHash)                  ;= "value1"
      ;; remhash function -> remove the association for KEY fron TABLE
      (puthash "key2" "value2" myHash)
      (gethash "key2" myHash)                  ;= "value2"
      (remhash "key2" myHash)                  ;= nil
      (gethash "key2" myHash)                  ;= nil
      ;; clrhash function -> remove all the associations fron hash table
      (clrhash myHash)
      ;; maphash function -> call function once for each of the associations in table.
      (maphash function table)
    #+END_SRC

*** Defining Hash
    You can define new methods of key lookup by means of 'define-hash-table-test'.
    #+BEGIN_SRC elisp
      ;; define-hash-table-test function -> define a new hash table test, you can use it as TEST argument in 'make-hash-table'
      ;; test-fn -> accept two arguments, two keys, return non- 'nil' if they are considered the same
      ;; hash-fn -> accept one argument, a key, and return an integer thar is the hash code of that key
      ;;(define-hash-table-test name test-fn hash-fn)
      (defun case-fold-string= (a b)
        (eq t (compare-strings a nil nil b nil nil t)))
      (defun case-fold-string-hash (a)
        (sxhash-equal (upcase a)))
      (define-hash-table-test 'case-fold
        'case-fold-string= 'case-fold-string-hash)
      (make-hash-table :test 'case-fold)
      ;; sxhash-equal function -> return a hash code for Lisp object
      (sxhash-equal "a")            ;= 121 if two objects are 'equal', their hash code is same
      ;; sxhash-eq function -> return a hash code for List object
      (sxhash-eq "b")               ;= 1117765081
      (sxhash-eq "b")               ;= 1115129385
      ;; sxhash-eql function -> return a hash code for Lisp object
      (sxhash-eql "b")              ;= 1106649113
      (sxhash-eql "b")              ;= 1145969165
      ;; You can use 'sxhash-equal', 'sxhash-eq', 'sxhash-eql' like:
      (define-hash-table-test 'contents-hash 'equal 'sxhash-equal)
      (make-hash-table :test 'contents-hash)
    #+END_SRC

*** Other Hash
    #+BEGIN_SRC elisp
      (setq myHash (make-hash-table
                    :test 'equal
                    :weakness 'key-and-value))
      (puthash "key" "value" myHash)
      (puthash "key1" "value2" myHash)
      (puthash "key2" "value2" myHash)
      (hash-table-p myHash)                  ;= t
      (copy-hash-table myHash)               ; copy hash table
      (hash-table-count myHash)              ;= 3
      (hash-table-test myHash)               ;= equal
      (hash-table-weakness myHash)           ;= key-and-value
      (hash-table-rehash-size myHash)        ;= 1.5
      (hash-table-rehash-threshold myHash)   ;= 0.8125
      (hash-table-size myHash)               ;= 65
    #+END_SRC
** DONE [[elisp:(info-other-window "(elisp)Symbols")][9.Symbols]]
   CLOSED: [2018-10-05 五 00:45]
   - State "DOING"      from "TODO"       [2018-10-04 四 21:19]
*** Summary
    A "symbol" is an object with a unique name.
    Test whether an arbitrary Lisp object is a symbol with 'symbolp':
    #+BEGIN_SRC elisp
    (symbolp "a")         ;= nil
    (symbolp 'abc)        ;= t
    #+END_SRC
*** Symbol Components
    Each symbol has 4 components:
    #+NAME: Symbol Components
    | Component     | Description                                                        |
    |---------------+--------------------------------------------------------------------|
    | Print name    | Symbol's name                                                      |
    | Value         | Symbol's current value as variable                                 |
    | Function      | Symbol's function definition(a symbol, a keymap, a keyboard macro) |
    | Property list | Symbol's property list                                             |

*** Definitions
    A "definition" is a special kind of Lisp expression that announces your intention to use a symbol in a particular way.
    
    - 'defvar' and 'defconst' special forms that define a symbol as a 'global variable'.
    - 'defcustom' macro define a customizable variable, which also calls defvar as a subroutine.
    - 'setq' assign a variable value to any symbol
    - 'defun' define a symbol as a function
    - 'defsubst' and 'defalias' are two other ways defining a function
    - 'defmacro' defines a symbol as a macro
     
    As previously noted, Emacs Lisp allows the same symbol to be defined both as a variable and as a function or macro.

*** Creating Symbols
    How Lisp read symbols:
    1) Read all the characters of symbol
    2) Hashes those characters to find an index in a table called an "obarray".
       Each element of the obarray is ab "bucket", which holds all the symbols with a given hash code.
    3) If a symbol with the desired name is found, the reader uses that symbol.
    4) If obarray does not contain a symbol with that name, the reader makes a new symbol and add it to the obarray.

    #+BEGIN_SRC elisp
      ;; return the string that is SYMBOL's name.
      (symbol-name 'foo)                 ;= "foo"
      ;; return a newly-allocated, uninterned symbol whose name is NAME.
      (setq sym (make-symbol "foo"))     ;= foo
      (eq sym 'foo)                      ;= nil
      ;; return a symbol using 'make-symbol', whose name is make by appending 'gsnsym-couter' to PREFIX
      (gensym 'foo)                      ;= foo23
      (gensym 'foo)                      ;= foo24
      ;; return the interned symbol by name.If no such symbol, 'intern' create a new one, add it to the obarray, and return it.
      (setq sym (intern "foo"))          ;= foo
      (eq sym 'foo)                      ;= t
      ;; return the symbol in OBARRAY by name, or 'nil' if OBARRAY has no symbol with that name
      (intern-soft "frazzle")            ;= nil
      (make-symbol "frazzle")            ;= frazzle
      (intern-soft "frazzle")            ;= nil
      (setq sym (intern "frazzle"))      ;= frazzle
      (intern-soft "frazzle")            ;= frazzle
      (eq sym 'frazzle)                  ;= t
      ;; mapatioms function -> call function once with each symbol in the obarray.
      (setq count 0)
      (defun count-syms (s)
        (setq count (1+ count)))         ;= count-syms
      (mapatoms 'count-syms)             ;= nil
      count                              ;= 69948
      ;; delete SYMBOL from the obarray
      (unintern "foo")                   ;= t
      (unintern "foo")                   ;= nil
    #+END_SRC

    Variable: obarray
    The variable is the standard obarray for use by 'intern' and 'read'

*** Symbol Properties
    A symbol may possess any number of "symbol properties", which can be used to record miscellaneous information about the symbol.
    Each symbol's properties and property values are stored in the symbol's property list cell, in the form of a property list.
**** Symbol Plists
     #+BEGIN_SRC elisp
       ;; get value of the property
       (get 'foo 'prop1)                  ;= nil
       ;; put value of the property
       (put 'foo 'prop1 'value1)          ;= value1
       (get 'foo 'prop1)                  ;= value1
       ;; return the property list
       (symbol-plist 'foo)                ;= (prop1 value1)
       ;; sets SYMBOL's property list to PLIST
       (setplist 'foo '(a 1 b (2 3) c nil))  ;= (a 1 b (2 3) c nil)
       (symbol-plist 'foo)                   ;= (a 1 b (2 3) c nil)
       ;; identical to 'get'
       (function-get 'foo 'prop1)         ;= nil
       ;; identical to 'put'
       (function-put 'foo 'prop2 'value2) ;= value2
     #+END_SRC

**** Standard Properties
     [[info:elisp#Standard%20Properties][Link for standard properties]]

** DONE [[elisp:(info-other-window "(elisp)Evaluation")][10.Evaluation]]
   CLOSED: [2018-10-09 二 23:38]
   - State "DOING"      from "TODO"       [2018-10-05 五 00:46]

*** Summary
    The "evaluation" of expressions in Emacs Lisp is performed by the "Lisp interpreter"
    a program that receives a Lisp object as input and computes its "value as an expression".

*** Intro Eval
    The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it.
    Evaluation takes palce in a context called the "environment".
    
*** Forms
    A Lisp object that is intended tobe evaluated is called a "form" (or an "expression").
    How Emacs evaluates a form depends on its data type.

**** Self-Evaluating Forms
     Forms that evaluate to themselves.
     #+BEGIN_SRC elisp
       ;; Self-Evaluating Forms
       '123                   ;= 123
       123                    ;= 123
       (eval '123)            ;= 123
       (eval (eval '123))     ;= 123
       ;; For types that lack a read syntax.
       (setq print-exp (list 'print (current-buffer)))  ;= (print #<buffer c10_elisp_evaluation.el>)
       (eval print-exp)
     #+END_SRC

**** Symbol Forms
     Symbols evaluate as variables.
     #+BEGIN_SRC elisp
       (setq a 123)           ;= 123
       (eval a)               ;= 123
       a                      ;= 123
       (setq nil 23)          ; error!
     #+END_SRC

**** Classifying Lists
     A form that is a nonempty list is either a function call, a macro call or a special form, according to its first elemtns.
     The first step in evaluating a nonempty list is to examine its first elements.

**** Function Indirection
     When a symbol appears as the car of a list, we find the real function via the symbol.
     #+BEGIN_SRC elisp
       ;; Build this function cell linkage:
       ;;   -------------       -----        -------        -------
       ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
       ;;   -------------       -----        -------        -------
       ;; The first element is an anonymous Lisp function, not a symbol.
       (symbol-function 'car)        ;= #<subr car>
       (fset 'first 'car)            ;= car
       (fset 'erste 'first)          ;= car
       (erste '(1 2 3))              ;= 1
     #+END_SRC

**** Function Forms
     If the first element of a list being evaluated is a Lisp function object, byte-code object
     or primitive function object, then that list is a "function call".
     #+BEGIN_SRC elisp
     (+ 1 x)
     #+END_SRC

**** Macro Forms
     If the first element of a list being evaluated is a macro object, then the list is a "macro call".
     #+BEGIN_SRC elisp
       (defmacro cadr (x)
         (list 'car (list 'cdr x)))
     #+END_SRC

**** Special Forms
     A "special form" is a primitive function specially marked so that its arguments are not all evaluated.
     #+BEGIN_SRC elisp
       ;; test whether its argument is a special form
       (special-form-p 'car)           ;= nil
       (special-form-p 'and)           ;= t
     #+END_SRC

**** Autoloading
     The "autoload" feature allows you to call a function or macro whose function definition has not yet been loaded into Emacs.

*** Quoting
    The special form "quote" returns its single argument, as written, without evaluating it.
    #+BEGIN_SRC elisp
      (quote (+ 1 2))                 ;= (+ 1 2)
      (quote foo)                     ;= foo
      'foo                            ;= foo
      '(+ 1 2)                        ;= (+ 1 2)
    #+END_SRC

*** Backquote
    "Backquote constructs" allow you to quote a list, but selectively evaluate elements of that list.
    #+BEGIN_SRC elisp
      '(a list of (+ 2 3) elements)   ;= (a list of (+ 2 3) elements) use quote
      `(a list of ,(+ 2 3) elements)   ;= (a list of 5 elements) use backquote
      `(1 2 (3 ,(+ 4 5)))              ;= (1 2 (3 9))
    #+END_SRC
    
    You can also "splice" an evaluated value into the resulting list, using the special marker ',@'
    #+BEGIN_SRC elisp
      (setq some-list '(2 3))                    ;= (2 3)
      (cons 1 (append some-list '(4) some-list)) ;= (1 2 3 4 2 3)
      `(1 ,@some-list 4 ,@some-list)             ;= (1 2 3 4 2 3)
    #+END_SRC

*** Eval
    Most often, forms are evaluated automatically, by virtue of their occurrence in a program being run.

    Function: eval form &optional lexical
    Command:  eval-region start end &optional stream read-function
    Command:  eval-buffer &optional buffer-or-name stream filename unibyte print
    User Options: max-lisp-eval-depth
    Variable: values

** DOING [[elisp:(info-other-window "(elisp)Structure")][11.Control Structure]]
   - State "DOING"      from "TODO"       [2018-10-09 二 23:38]
** TODO [[elisp:(info-other-window "(elisp)Variables")][12.Variables]]
** TODO [[elisp:(info-other-window "(elisp)Functions")][13.Functions]]
** TODO [[elisp:(info-other-window "(elisp)Macros")][14.Macros]]
** TODO [[elisp:(info-other-window "(elisp)Customization Settings")][15.Customization Settings]]
** TODO [[elisp:(info-other-window "(elisp)Loading")][16.Loading]]
** TODO [[elisp:(info-other-window "(elisp)Byte Compilation")][17.Byte Compilation]]
** TODO [[elisp:(info-other-window%20"(elisp)Debugging")][18.Debugging Lisp Programs]]
** TODO [[elisp:(info-other-window "(elisp)Read and Print")][19.Reading and Printing List Objects]]
** TODO [[elisp:(info-other-window "(elisp)Minibuffers")][20.Minibuffers]]
** TODO [[elisp:(info-other-window "(elisp)Command Loop")][21.Command Loop]]
** TODO [[elisp:(info-other-window "(elisp)Keymaps")][22.Keymaps]]
** TODO [[elisp:(info-other-window "(elisp)Modes")][23.Major and Minor Modes]]
** TODO [[elisp:(info-other-window "(elisp)Documentation")][24.Documentation]]
** TODO [[elisp:(info-other-window "(elisp)Files")][25.Files]]
** TODO [[elisp:(info-other-window "(elisp)Backups and Auto-Saving")][26.Backups and Auto-Saving]]
** TODO [[elisp:(info-other-window "(elisp)Buffers")][27.Buffers]]
** TODO [[elisp:(info-other-window "(elisp)Windows")][28.Windows]]
** TODO [[elisp:(info-other-window "(elisp)Frames")][29.Frames]]
** TODO [[elisp:(info-other-window "(elisp)Positions")][30.Positions]]
** TODO [[elisp:(info-other-window "(elisp)Markers")][31.Markers]]
** TODO [[elisp:(info-other-window "(elisp)Text")][32.Text]]
** TODO [[elisp:(info-other-window "(elisp)Non-ASCII Characters")][33.Non-ASCII Characters]]
** TODO [[elisp:(info-other-window "(elisp)Searching and Matching")][34.Searching and Matching]]
** TODO [[elisp:(info-other-window "(elisp)Syntax Tables")][35.Syntax Tables]]
** TODO [[elisp:(info-other-window "(elisp)Abbrevs")][36.Abbrevs and Abbrev Expansion]]
** TODO [[elisp:(info-other-window "(elisp)Threads")][37.Threads]]
** TODO [[elisp:(info-other-window "(elisp)Processes")][38.Processes]]
** TODO [[elisp:(info-other-window "(elisp)Display")][39.Emacs Display]]
** TODO [[elisp:(info-other-window "(elisp)Operating Interface")][40.Operating System Interface]]
** TODO [[elisp:(info-other-window "(elisp)Packaging")][41.Preparing Lisp code for distribution]]
