#+TITLE: Info Document of Elisp
#+TODO: TODO(t) DOING(d!) PAUSE(p!) RESUME(r!) | DONE(e) LATER(l)

* DOING Emacs Lisp Document [3/41]
  - State "DOING"      from "TODO"       [2018-09-27 四 12:17]

** DONE [[elisp:(info-other-window%20"(elisp)Introduction")][1.Introduction]]
   CLOSED: [2018-09-27 四 00:10]
   - State "DOING"      from "TODO"       [2018-09-26 三 23:41]
** DONE [[elisp:(info-other-window "(elisp)Lisp Data Types")][2.Lisp Data Types]]
   CLOSED: [2018-09-27 四 23:59]
   - State "DOING"      from "TODO"       [2018-09-27 四 00:10]
*** Primitive types
    Each object blongs to one and only one primitive type.
    - integer
    - float
    - cons
    - symbol
    - string
    - vector
    - hash-table
    - subr
    - byte-code function
    - record
    - buffer

    Such type declarations do not exist in Emacs Lisp.
    A Lisp variables can have any type of value, and it remembers whatever value you store in it, type and all.
    
    Variables with Restricted Values:a small number of Emacs Lisp variables can only take on values of a certain type.

*** Printed Representation 
*** Comments
    #+BEGIN_SRC elisp
    ;; This is a commnet.
    '(this is the code)
    #+END_SRC
*** Programming Type
    | type                     | example                                  | description                                                                     |
    |--------------------------+------------------------------------------+---------------------------------------------------------------------------------|
    | Integer Type             | '-1','1','+1','1.'                       | The range depends on the machine.                                               |
    | Floating-Point Type      | '1500.0','+15e2','15.0e+2','+1500000e-3' | Uses the C data type 'double' to store the value                                |
    | Chatacter Type           | 'A','?B','?\n'                           |                                                                                 |
    | Symbol Type              | 'foo','FOO'                              | A "symbol" in GNU Emacs List is an object with a name                           |
    | Sequence Type            |                                          | "lists" and "arrays"                                                            |
    | Cons Cell Type           |                                          | "CAR" & "CDR", A Lisp list thus works as a "linked list" built up of cons cells |
    | Array Type               |                                          | one-dimensional, number of slots for holding/ referring Lisp objects            |
    | String Type              |                                          | an array of characters                                                          |
    | Vector Type              | [1 "two" (three)]                        | one-dimensional array of elements of any type                                   |
    | Chat-Table Type          |                                          | one-dimensional array of elements of any type, indexed by character codes.      |
    | Bool-Vector Type         |                                          | one-dimensional array elements must be 't' or 'nil'                             |
    | Hash Table Type          |                                          | a very fast kind of lookup table                                                |
    | Function Type            |                                          | In Lisp, functions are also Lisp objects.                                       |
    | Marco Type               |                                          | an object much like a function. CDR is a Lisp function object, include 'lambda' |
    | Primitive Funcetion Type |                                          | function callable from Lisp written in C language                               |
    | Byte-Code Type           |                                          | byte-compiling Lisp code                                                        |
    | Record Type              |                                          | much like a vector. create objects with new types not build into Emacs          |
    | Type Descriptors         |                                          | is a 'record' holds infomateion about a type                                    |
    | Autoload Type            |                                          | a list whose first element is the symbol 'autoload'                             |
    | Finalizer Type           |                                          | helps clean up after objects that are no longer needed                          |

*** Editing Types
    | Type                      | description                                                                            |
    |---------------------------+----------------------------------------------------------------------------------------|
    | Buffer Type               | hold text that can be edited                                                           |
    | Marker Type               | denotes a position in a specific buffer                                                |
    | Window Type               | describes the portion of the terminal screen that Emacs uses to display a buffer       |
    | Frame Type                | a screen area that contains one or more Emacs windows                                  |
    | Terminal Type             | a device capable of displaying one or more Emacs frames                                |
    | Window Configuration Type | stores information about the positions, sizes, and content of the window in a frame    |
    | Frame Configuration Type  | stores information about the positions, sizes, and content of the window in all frames |
    | Process Type              | usually means a running program                                                        |
    | Thread Type               | a separate thread of Emacs Lisp execution                                              |
    | Mutex Type                | an exclusive lock that threads can own and disown, for synchronize                     |
    | Condition Variable Type   | a device for a more complex thread synchronization than the one supported by a mutex   |
    | Stream Type               | an object can be used as a source or sink for characters                               |
    | Keymap Type               | maps keys typed by the user to commands                                                |
    | Overlay Type              | specifies properties that apply to a part of a buffer                                  |
    | Font Type                 | specifies how to diaplay text on a graphical terminal                                  |

*** Circular Objects
    To represent shared or circular structures within a complex Lisp objects;
    You can use the reader constructs '#N=' and '#N#'
    #+BEGIN_SRC elisp
    '(#1=(a) b #1#)
    equals
    ((a) b (a))
    #+END_SRC

*** Type Predicates
    Check the types of any arguments
    #+BEGIN_SRC elisp
    ;; error -> Wrong type argument: number-or-mark-p, a 
    (+ 2 'a)
    #+END_SRC

*** Equality Predicates
    Here we describe functions that test for equality between two objects.
    #+BEGIN_SRC elisp
    ;; result is 't'
    (eq 'foo 'foo)

    ;; result is nil
    (eq "asdf" "asdf")
    #+END_SRC

** DONE [[elisp:(info-other-window "(elisp)Numbers")][3.Numbers]]
   CLOSED: [2018-09-29 六 10:12]
   - State "DOING"      from "TODO"       [2018-09-28 五 00:15]

*** Integer Basics
    The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2**29 to 2**29 −1).
    Many machines provide a wider range.

    '#' followed by a letter specifies the radix:
    #+BEGIN_SRC elisp
      '(#b101100) ;; b for binary
      '(#o54)     ;; o for octal
      '(#x2c)     ;; x for hex
      '(#24r1k)   ;; #RADIXrINTEGER

      (+ most-positive-fixnum 0) ;; largest integer
      (+ most-negative-fixnum 0) ;; smallest integer
    #+END_SRC

*** Floating-Point Basics
    #+BEGIN_SRC elisp
      (/ 0.0 0.0)         ;; = 0.0e+NaN
      (isnan (/ 0.0 0.0)) ;; = t
      (frexp 10.0)        ;; = (0.625 . 4)
      (ldexp 1.5 2)       ;; = 6.0
      (copysign 2.3 -1.3) ;; = -2.3
      (logb 2.2)          ;; = 1
    #+END_SRC
    
*** Predicates on Numbers
    #+BEGIN_SRC elisp
      (floatp 1.2)     ;; = t
      (integerp 2)     ;; = t
      (numberp "aaa")  ;; = nil
      (natnump 11.2)   ;; = nil
      (zerop 0)        ;; = t
      (= 2 0)          ;; = nil
    #+END_SRC

*** Comparison of Numbers
    #+BEGIN_SRC elisp
      ;; Comparison of Numbers
      (= 2 2)         ;= t
      (eql 2 3)       ;= nil
      (/= 2 3)        ;= t
      (/= 2 2)        ;= nil
      (< 3 4)         ;= t
      (<= 3 4)        ;= t
      (> 4 5)         ;= nil
      (>= 3 5)        ;= nil
      (max 2 4 10 9)  ;= 10
      (min 2 4 10 9)  ;= 2
      (abs -9)        ;= 9
    #+END_SRC

*** Numeric Conversions
    #+BEGIN_SRC elisp
      ;; Numeric Conversions
      (float 2)       ;= 2.0
      (truncate 2.23) ;= 2
      (floor 3.65)    ;= 3
      (floor -1.7)    ;= -2
      (ceiling 1.2)   ;= 2
      (ceiling -2.9)  ;= -2
      (round 1.2)     ;= 1
      (round -1.2)    ;= -1
      (round -1.7)    ;= -2
    #+END_SRC
    
*** Arithmetic Operations
    #+BEGIN_SRC elisp
      ;; 1+ function -> NUMBER plus 1
      (setq foo 3)
      (1+ foo)
      (setq foo (1+ foo)) ;; like ++
      ;; 1- function -> NUMBER minus 1
      (setq foo 4)
      (1- foo)
      (setq foo (1- foo)) ;; like --
      ;; - function -> negation and subtraction
      (- 10 1 2 3 4)      ;= 0
      (- 10)              ;= -10
      (-)                 ;= 0
      ;; * function -> multiplies
      (*)                 ;= 1
      (* 1)               ;= 1
      (* 1 2 3 4)         ;= 1
      ;; / function -> divides
      (/ 6 2)             ;= 3
      (/ 5 2)             ;= 2
      (/ 5.0 2)           ;= 2.5
      (/ 5 2.0)           ;= 2.5
      (/ 5.0 2.0)         ;= 2.5
      (/ 4.0)             ;= 0.25
      (/ 4)               ;= 0
      (/ 25 3 2)          ;= 4
      (/ -17 6)           ;= -2
      ;; % function
      (% 9 4)             ;= 1
      (% -9 4)            ;= -1
      (% 9 -4)            ;= 1
      (% -9 -4)           ;= -1
      ;; mod function
      (mod 9 4)           ;= 1
      (mod -9 4)          ;= 3
      (mod 9 -4)          ;= -3
      (mod -9 -4)         ;= -1
      (mod 5.5 2.5)       ;= 0.5
    #+END_SRC

*** Rounding Operations
    #+BEGIN_SRC elisp
      ;; rounds FLOAT to the next lower integral value
      (ffloor 2.52)       ;= 2.0
      ;; rounds FLOAT to the next higher integral value
      (fceiling 2.15)     ;= 3.0
      ;; rounds FLOAT towards zero to an integral value
      (ftruncate 3.9)     ;= 3.0
      ;; rounds FLOAT to the nearest integral value
      (fround 3.55)       ;= 4.0
    #+END_SRC

*** Bitwise Operations
    #+BEGIN_SRC elisp
      ;; lsh function -> shifts bits in INTEGER to the left COUNT places
      (lsh 5 1)                     ;= 10 00000101 -> 00001010 = 5 * 2^1
      (lsh 7 1)                     ;= 14 00000111 -> 00001110 = 7 * 2^1
      (lsh 3 2)                     ;= 12 00000110 -> 00001100 = 3 * 2^2
      (lsh most-positive-fixnum 1)  ;= -2 0111.......1111 -> 1111......111110
      ;; ash function -> shifts bits in INTEGER to the left COUNT places, or to the right if COUNT is negative
      (ash -6 -1)       ;= -3 1111...11010 -> 1111...111101
      (ash 2 3)         ;= 16 000010 -> 010000
      ;; logand function -> return bitwise AND the arguments
      (logand 13 12)    ;= 12 1101 AND 1100 -> 1100
      (logand 19 12)    ;= 0 10011 AND 1100 -> 00000
      ;; logior function -> return bitwise inclusive OR of its arguments
      (logior 12 5)     ;= 13 1100 OR 0101 -> 1101
      (logior 12 5 7)   ;= 15 1100 OR 0101 OR 0111 -> 1111
      ;; logxor function -> return bitwise exclusive OR of its arguments
      (logxor 12 5)     ;= 9 1100 XOR 0101 -> 1001
      (logxor 12 5 7)   ;= 14 1100 XOR 0101 XOR 0111
      ;; lognot function -> return bitwise complement of its argument
      (lognot 5)        ;= -6 0000...000101 -> 1111...111010 (30 bits total)
    #+END_SRC

*** Math Functions
    #+BEGIN_SRC elisp
      ;; Argument 为弧度，角度 != 弧度
      ;; 弧度 = (PI * 角度) / 180.0
      (/ (* float-pi 90) 180)   ;= 1.572693
      (sin 1.572963)            ;= 0.99999 近似于 sin90 度 = 1
      (cos 1.572963)            ;= 0.002   近似与 cos90 度 = 0
      (/ (* float-pi 45) 180)   ;= 0.7864815
      (tan 0.7864815)           ;= 1.002 近似于 tan45 度 = 1
      ;;asin function -> X > -PI/2 && X < PI/2 && sinX=Y -> (asin Y) = X (Y 超过[-1,1]返回 NaN)
      (asin 1)                  ;= 1.57
      ;;acos function -> X > 0 && X < PI && cosX=Y -> (acos Y) = X (Y 超过[-1,1]返回 NaN)
      (acos 0)                  ;= 1.57
      ;;atan function -> X > -PI/2 && X < PI/2 && atanX=Y -> (atan Y) = X
      (atan 1)                  ;= 0.78
      (atan 1 2)                ;= 0.46 is the angle in radians between the vector [1, 2] and the 'X' axis
      ;; exp function
      (exp 1)                   ;= 2.718 return
      ;; log function
      (log 4)
      ;; expt function -> return X reised to power Y
      (expt 3 2)
      ;; sqat
      (sqrt -10)
    #+END_SRC

*** Random Numbers
    #+BEGIN_SRC elisp
      ;; random function -> return random number in interval [0,LIMIT]
      (random)            ; = X X >=0 && X < 100
      (random 100)        ; = X X > most-negative-fixnum && X < most-positive-fixnum
    #+END_SRC
** DOING [[elisp:(info-other-window "(elisp)Strings and Characters")][4.Strings and Characters]]
   - State "DOING"      from "TODO"       [2018-09-29 六 10:13]
*** String Basics
    A character is a Lisp object which represents a single character of text.
    A string is a fixed sequence of characters.
    Since strings are arrays, you can operate on them with general array and sequence functions.
*** Predicates for Strings
    #+BEGIN_SRC elisp
      ;; Predicates for Strings
      ;; stringp function -> check argument is a string nor not
      (stringp "asd")    ;= t
      (stringp 1)        ;= nil
      (stringp nil)      ;= nil
      (stringp 'a')      ; error!
      ;; string-or-null-p function -> check argument is a string or 'nil'
      (string-or-null-p nil)    ;= t
      (string-or-null-p "aab")  ;= t
      (string-or-null-p 12)     ;= nil
      ;; char-or-string-p function -> check argument is a string or a character(i.e., an integer)
      (char-or-string-p "asd")  ;= t
      (char-or-string-p 12)     ;= t
      (char-or-string-p ?a)     ;= t
      (char-or-string-p nil)    ;= nil
    #+END_SRC
*** Creating Strings
    #+BEGIN_SRC elisp
      ;; make-string function -> made up of COUNT repetition of CHARACTER. COUNT must >= 0
      (make-string 4 ?x)                          ;= "xxxx"
      (make-string 0 ?x)                          ;= ""
      (make-string -1 ?)                          ; error!
      ;; string function -> contain the characters
      (string ?a ?b ?c)                           ;= "abc"
      ;; substring function -> return a new string consists of those characters[START, END]
      (substring "abcdefg" 0 3)                   ;= "abc"
      (substring "abcdefg")                       ;= "abcdefg" just copy the string
      (substring "abcdefg" -3 -1)                 ;= "ef" A negative number counts from the end of the string
      (substring "abcdefg" -3 nil)                ;= "efg" 'nil' used for END, it stands for the length for the string.
      (substring "abcdefg" 0)                     ;= "abcdefg" retun a copy of string
      (substring [a b (c)] 1 3)                   ;= [b (c)] also accepts a vector for the first argument
      ;; substring-no-properties function -> works like substring, but discards all text properties
      (substring-no-properties "abcdefg" 0 3)     ;= "abc"
      ;; concat function -> return a new string consisting of the characters in the arguments passed to it
      (concat "abc" "-def")                       ;= "abc-def"
      (concat "abc" (list 120 121) [122])         ;= "abcxyz"
      (concat "abc" nil "-def")                   ;= "abc-def" 'nil' is an empty sequence
      (concat)                                    ;= ""
      ;; splite-string function -> splits STRING into substrings
      (split-string "  tow words ")               ;= ("two" "words")
      (split-string "  tow words " split-string-default-separators) ;=("" "two" "words" "")
      (split-string "Soup is good food" "o")      ;= ("S" "up is g" "" "d f" "" "d")
      (split-string "Soup is good food" "o" t)    ;= ("S" "up is g" "d f" "d")
      (split-string "Soup is good food" "o+")     ;= ("S" "up is g" "d f" "d")
      (split-string "aooob" "o*")                 ;= ("" "a" "" "b" "")
      (split-string "ooaboo" "o*")                ;= ("" "" "a" "b" "")
      (split-string "" "")                        ;= ("")
      (split-string "Soup is good food" "o*" t)   ;= ("S" "u" "p" " " "i" "s" " " "g" "d" " " "f" "d")
      (split-string "Nice doggy!" "" t)           ;= ("N" "i" "c" "e" " " "d" "o" "g" "g" "y" "!")
      (split-string "ooo" "o*" t)                 ;= nil
      (split-string "ooo" "\\|o+" t)              ;= ("o", "o", "o")
    #+END_SRC
    | variable                        | default value   | description                                        |
    |---------------------------------+-----------------+----------------------------------------------------|
    | split-string-defualt-separators | "[ \f\t\n\r\v]" | The default value of SEPARATORS for ~split-string~ |
*** Modifying Strings
    #+BEGIN_SRC elisp
      ;; store-substring function -> alters part of string by index and replace string
      (store-substring "asdoasdfoa" 0 "insert")   ;= "insertdfoa"
      ;; clear-string function -> make string a unibyte string and clear its contents to zeros. length change.
      (clear-string "aaa")                        ;= nil
      (length (clear-string "abcdefg"))           ;= 0
    #+END_SRC
*** Text Comparison
    #+BEGIN_SRC elisp
      ;; char-equal function -> check arguments represent the sam character
      (char-equal ?x ?a)                   ;= nil
      (char-equal ?x ?x)                   ;= t
      (let ((case-fold-search nil))
        (char-equal ?x ?X))                ;= nil ignore differences in case if 'case-fold-search' is non- 'nil'
      ;; string= function -> check if the two strings match exactly
      (string= "asdf" "asdf")              ;= t
      (string= "asdf" "asd")               ;= nil
      (string= "asdf" "ASDF")              ;= nil
      ;; string-equal -> another name for 'string='
      (string-equal "aaa" "aaa")           ;= t
      (string-collate-equalp "a" "a")      ;= t
      (string-collate-equalp (string ?\uFF40) (string ?\u1FEF)) ;= t characters with different coding points but the same mean might be considered as equal. Do not use this function compare file names.
      ;; string< function -> compare two strings a character at a time
      (string< "aa" "aa")                  ;= nil
      (string< "aa" "ac")                  ;= t
      (string< "" "abc")                   ;= t
      ;; string-lessp function -> another name for 'string<'
      (string-lessp "aaa" "bbb")           ;= t
      (string-greaterp "cc" "aa")          ;= t compare in the opposite order, equivalent to (string-lessp "aa" "cc")
      ;; string-collate-lessp function -> compare two strings in collation order
      (sort '("11" "12" "1 1" "1 2" "1.1" "1.2") 'string-collate-lessp) ;= ("11" "1 1" "1.1" "12" "1 2" "1.2")
      ;; string-version-lessp function -> compare numbers in two strings
      (string-version-lessp "foo2.png" "foo12.png") ;= t
      ;; string-prefix-p function -> check if string1 is a prefix of string2
      (string-prefix-p "A" "Abc")          ;= t
      (string-prefix-p "a" "Abc")          ;= nil
      (string-prefix-p "a" "Abc" t)        ;= t you can add 'ignore-case' argument
      ;; string-suffix-p function -> check if string1 is a suffix of string2
      (string-suffix-p "C" "abC")          ;= t
      (string-suffix-p "c" "abC")          ;= nil
      (string-suffix-p "c" "abC" t)        ;= t you can add 'ignore-case' argument
      ;; compare-strings function -> strings are compared by the numberic values of their characters
      (compare-strings "abcdefg" 1 3 "bbbbabc" 5 7)                 ;= t "bc" compare with "bc"
      (compare-strings "abcdefg" 1 3 "bbbbabc" 1 3)                 ;= 2 "bc" compare with "bb"
      (compare-strings "abcc" 1 3 "bcbc" 1 3)                       ;= -1 "bc" compare with "cb"
      (compare-strings "abcccccc" 1 5 "ZZZZZZZ" 2 4)                ;= 1
      (compare-strings "abcccccc" 1 5 "zzzzzzz" 2 4 t)              ;= -1
      ;; assoc-string function -> like function 'assoc'
      (assoc-string "key" (list "keys" "aaa" "key"))                ;= "key"
      (assoc-string "key" (list "keys" "aaa" "KEY"))                ;= nil
      (assoc-string "key" (list "keys" "aaa" "KEY") t)              ;= "key"
    #+END_SRC
*** String Conversion
    #+BEGIN_SRC elisp
    
    #+END_SRC
** TODO [[elisp:(info-other-window "(elisp)List")][5.List]]
** TODO [[elisp:(info-other-window "(elisp)Sequences Arrays Vectors")][6.Sequences, Arrays, and Vectors]]
** TODO [[elisp:(info-other-window "(elisp)Records")][7.Records]]
** TODO [[elisp:(info-other-window "(elisp)Hash Tables")][8.Hash Tables]]
** TODO [[elisp:(info-other-window "(elisp)Symbols")][9.Symbols]]
** TODO [[elisp:(info-other-window "(elisp)Evaluation")][10.Evaluation]]
** TODO [[elisp:(info-other-window "(elisp)Structure")][11.Control Structure]]
** TODO [[elisp:(info-other-window "(elisp)Variables")][12.Variables]]
** TODO [[elisp:(info-other-window "(elisp)Functions")][13.Functions]]
** TODO [[elisp:(info-other-window "(elisp)Macros")][14.Macros]]
** TODO [[elisp:(info-other-window "(elisp)Customization Settings")][15.Customization Settings]]
** TODO [[elisp:(info-other-window "(elisp)Loading")][16.Loading]]
** TODO [[elisp:(info-other-window "(elisp)Byte Compilation")][17.Byte Compilation]]
** TODO [[elisp:(info-other-window%20"(elisp)Debugging")][18.Debugging Lisp Programs]]
** TODO [[elisp:(info-other-window "(elisp)Read and Print")][19.Reading and Printing List Objects]]
** TODO [[elisp:(info-other-window "(elisp)Minibuffers")][20.Minibuffers]]
** TODO [[elisp:(info-other-window "(elisp)Command Loop")][21.Command Loop]]
** TODO [[elisp:(info-other-window "(elisp)Keymaps")][22.Keymaps]]
** TODO [[elisp:(info-other-window "(elisp)Modes")][23.Major and Minor Modes]]
** TODO [[elisp:(info-other-window "(elisp)Documentation")][24.Documentation]]
** TODO [[elisp:(info-other-window "(elisp)Files")][25.Files]]
** TODO [[elisp:(info-other-window "(elisp)Backups and Auto-Saving")][26.Backups and Auto-Saving]]
** TODO [[elisp:(info-other-window "(elisp)Buffers")][27.Buffers]]
** TODO [[elisp:(info-other-window "(elisp)Windows")][28.Windows]]
** TODO [[elisp:(info-other-window "(elisp)Frames")][29.Frames]]
** TODO [[elisp:(info-other-window "(elisp)Positions")][30.Positions]]
** TODO [[elisp:(info-other-window "(elisp)Markers")][31.Markers]]
** TODO [[elisp:(info-other-window "(elisp)Text")][32.Text]]
** TODO [[elisp:(info-other-window "(elisp)Non-ASCII Characters")][33.Non-ASCII Characters]]
** TODO [[elisp:(info-other-window "(elisp)Searching and Matching")][34.Searching and Matching]]
** TODO [[elisp:(info-other-window "(elisp)Syntax Tables")][35.Syntax Tables]]
** TODO [[elisp:(info-other-window "(elisp)Abbrevs")][36.Abbrevs and Abbrev Expansion]]
** TODO [[elisp:(info-other-window "(elisp)Threads")][37.Threads]]
** TODO [[elisp:(info-other-window "(elisp)Processes")][38.Processes]]
** TODO [[elisp:(info-other-window "(elisp)Display")][39.Emacs Display]]
** TODO [[elisp:(info-other-window "(elisp)Operating Interface")][40.Operating System Interface]]
** TODO [[elisp:(info-other-window "(elisp)Packaging")][41.Preparing Lisp code for distribut
