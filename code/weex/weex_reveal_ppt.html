<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Weex 源码简读</title>
    <meta name="author" content="(茄子)"/>
    <style type="text/css">
     .underline { text-decoration: underline; }
    </style>
    <link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.css"/>

    <link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/night.css" id="theme"/>

    <link rel="stylesheet" href="./export/my_reveal_style.css"/>
    <link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/css/zenburn.css"/>
    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
     if( window.location.search.match( /print-pdf/gi ) ) {
       var link = document.createElement( 'link' );
       link.rel = 'stylesheet';
       link.type = 'text/css';
       link.href = 'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css';
       document.getElementsByTagName( 'head' )[0].appendChild( link );
     }
    </script>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section id="sec-title-slide"><h1 class="title">Weex 源码简读</h1><h2 class="author">茄子</h2><p class="date">2018-11-23</p>
        </section>

        <section>
          <section id="slide-orgda42377">
            <h2 id="orgda42377">使用指南</h2>
            <div class="outline-text-2" id="text-orgda42377">
            </div>
          </section>
          <section id="slide-orge430b67">
            <h3 id="orge430b67">Weex 扩展(Android)</h3>
            <div class="outline-text-3" id="text-orge430b67">
            </div>
          </section>
          <section id="slide-org26567f2">
            <h4 id="org26567f2">Module</h4>
            <p>
              Module 用于扩展非 UI 功能
            </p>
            <ol>
              <li>extends WXModule</li>
              <li>@JsMethod(uiThread = false or true)</li>
              <li>public function</li>
              <li>-keep public class * extends com.taobao.weex.common.WXModule{*;}</li>
              <li>方法参数:int,double,float,String,Map,List</li>
              <li>Register: WXSDKEngine.registerModule("myModule", MyModule.class);</li>

            </ol>
          </section>
          <section >

            <ul class="org-ul">
              <li><a id="orgc000b24"></a>自定义一个 Module<br />
                <div class="org-src-container">

                  <pre><code class="java" >public class MyModule extends WXModule {

    //run ui thread
    @JSMethod (uiThread = true)
    public void printLog(String msg) {
        Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();
    }

    //run JS thread
    @JSMethod (uiThread = false)
    public void fireEventSyncCall(){
        //implement your module logic here
    }
}
                  </code></pre>
                </div>
              </li>

              <li><a id="org7423fcd"></a>注册一个 Module<br />
                <div class="org-src-container">

                  <pre><code class="java" >WXSDKEngine.registerModule("MyModule", MyModule.class);
                  </code></pre>
                </div>
              </li>

              <li><a id="org93126f9"></a>在 Weex 页面中调用 Module<br />
                <div class="org-src-container">

                  <pre><code class="html" ><template>
                    <div>
                      <text onclick="click">testMyModule</text>
                    </div>
                  </template>

                  <script>
                   module.exports = {
                     methods: {
                       click: function() {
                         weex.requireModule('MyModule').printLog("I am a weex Module");
                       }
                     }
                   }
                  </script>
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-org6f8bae6">
            <h4 id="org6f8bae6">Component</h4>
            <p>
              Component 扩展实现 Native 控件
            </p>
            <ol>
              <li>extends WXComponent</li>
              <li>@WXComponentProp(name=value(value is attr or style of dsl))</li>
              <li>-keep public class * extends com.taobao.weex.common.WXComponent{*;}</li>
              <li>方法参数:int,double,float,String,Map,List</li>
              <li>WXSDKEngine.registerComponent("richText", RichText.class);</li>

            </ol>
          </section>
          <section >

            <ul class="org-ul">
              <li><a id="orgac9eb4a"></a>自定义一个 Component<br />
                <div class="org-src-container">

                  <pre><code class="java" >public class RichText extends WXComponent<TextView> {

                    public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) {
                    super(instance, dom, parent);
                    }

                    @Override
                    protected TextView initComponentHostView(@NonNull Context context) {
                    TextView textView = new TextView(context);
                    textView.setTextSize(20);
                    textView.setTextColor(Color.BLACK);
                    return textView;
                    }

                    @WXComponentProp(name = "tel")
                    public void setTel(String telNumber) {
                    getHostView().setText("tel: " + telNumber);
                    }
                    }
                  </code></pre>
                </div>
              </li>

              <li><a id="org2335b99"></a>注册 Component<br />
                <div class="org-src-container">

                  <pre><code class="java" >WXSDKEngine.registerComponent("richText", RichText.class);
                  </code></pre>
                </div>
              </li>

              <li><a id="org2b8ae24"></a>在 Weex 页面中使用 Component<br />
                <div class="org-src-container">

                  <pre><code class="html" ><template>
                    <div>
                      <richText tel="12305" style="width:200;height:100">12305</richText>
                    </div>
                  </template>
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-org19221da">
            <h4 id="org19221da">Adapter</h4>
            <ul>
              <li>IWXImgLoaderAdapter</li>
              <li>IWXHttpAdapter</li>
              <li>IWXUserTrackAdapter</li>
              <li>IActivityNavBarSetter</li>
              <li>IWXStorageAdapter</li>

            </ul>

          </section>
          <section >
            <p>
              以 IWXJSExceptionAdapter 图片加载适配器为例,使用方法如下:
            </p>
            <div class="org-src-container">

              <pre><code class="java" >public class ImageAdapter implements IWXImgLoaderAdapter {

    public ImageAdapter() {
    }

    @Override
    public void setImage(final String url, final ImageView view, WXImageQuality quality, WXImageStrategy strategy) {

        WXSDKManager.getInstance().postOnUiThread(new Runnable() {

                @Override
                public void run() {
                    if(view==null||view.getLayoutParams()==null){
                        return;
                    }
                    if (TextUtils.isEmpty(url)) {
                        view.setImageBitmap(null);
                        return;
                    }
                    String temp = url;
                    if (url.startsWith("//")) {
                        temp = "http:" + url;
                    }
                    if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {
                        return;
                    }
                    Picasso.with(WXEnvironment.getApplication())
                        .load(temp)
                        .into(view);
                }
            },0);
    }
}
              </code></pre>
            </div>
          </section>
          <section id="slide-org9ca7482">
            <h3 id="org9ca7482">Lifecycle</h3>
            <div class="outline-text-3" id="text-org9ca7482">
            </div>
          </section>
          <section id="slide-org4bb6696">
            <h4 id="org4bb6696">Weex 页面生命周期控制</h4>
            <aside class="notes">
              <p>
                此处图片出处: <a href="https://github.com/alibaba/weex/issues/331?spm=a2c4e.11153940.blogcont59936.9.75012203aFrbFG">WeexLiftcycle 的讨论</a>
              </p>

            </aside>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="orgcbf4bd0"></a>Create Instance<br />
                <p>
                  在调用 <code>WXSDKInstance =&gt; render()</code> 方法时，会进到 createInstance 的流程中，具体调用流程如图：
                  <img src="./imgs/img_weex_lifecycle_create_instance.jpeg" alt="img_weex_lifecycle_create_instance.jpeg" />
                </p>

          </section>
          <section >
              </li>
              <li><a id="org837448d"></a>Refresh Instance<br />
                <p>
                  在调用 <code>WXSDKInstance =&gt; reloadPage()</code> 方法时，会进到 refreshInstance 流程中，具体调用流程如图：
                  <img src="./imgs/img_weex_lifecycle_refresh_instance.jpeg" alt="img_weex_lifecycle_refresh_instance.jpeg" />
                </p>

          </section>
          <section >
              </li>
              <li><a id="orga53d0d7"></a>Fire Event/Callback<br />
                <p>
                  当点击 Weex 页面的按钮触发点击事件时，会进入 fireEvent 流程，具体调用流程如图：
                  <img src="./imgs/img_weex_lifecycle_fire_event.jpeg" alt="img_weex_lifecycle_fire_event.jpeg" />
                </p>

          </section>
          <section >
              </li>
              <li><a id="org1a74b1d"></a>Destroy Instance<br />
                <p>
                  <code>WXSDKInstance =&gt; onActivityDestroy()</code> 当 Weex 页面伴随着所在 Activity 的生命周期方法结束时，会进入 destoryInstance 的流程，具体调用流程如图：
                  <img src="./imgs/img_weex_lifecycle_destroy_instance.jpeg" alt="img_weex_lifecycle_destroy_instance.jpeg" />
                </p>

          </section>
          <section >
              </li>
              <li><a id="org6dc872a"></a>Navigate<br />
                <div class="figure">
                  <p><img src="./imgs/img_weex_lifecycle_navigate.jpeg" alt="img_weex_lifecycle_navigate.jpeg" />
                  </p>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-org4d16f1e">
            <h4 id="org4d16f1e">组件生命周期解析</h4>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="orgd85264d"></a>生命周期图解<br />
                <div class="org-src-container">

                  <pre><code class="org" > ------      --------      -------             -----------
| init | -> | create | -> | ready |           | destroyed |
 ------      --------      -------             -----------
                  </code></pre>
                </div>

                <p>
                  生命周期用法
                </p>
                <div class="org-src-container">

                  <pre><code class="javascript" ><script>
                                                  module.exports = {
                                                    data: {},
                                                    methods: {},

                                                    init: function () {
                                                      console.log('在初始化内部变量，并且添加了事件功能后被触发');
                                                    },
                                                    created: function () {
                                                      console.log('完成数据绑定之后，模板编译之前被触发');
                                                    },
                                                    ready: function () {
                                                      console.log('模板已经编译并且生成了 Virtual DOM 之后被触发');
                                                    },
                                                    destroyed: function () {
                                                      console.log('在页面被销毁时调用');
                                                    }
                                                  }
                  </script>
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org29f052c"></a>init<br />
                <ul>
                  <li>初始化内部变量,添加事件功能</li>
                  <li>没有执行数据绑定,没有创建 Virtual-DOM,所以不能通过 this 获取到 data 中的数据,不能调用到 methods 中定义的方法,也不能获取到 Virtual-DOM 的节点</li>
                  <li>可以在方法内初始化一些内部变量,绑定一些自定义事件</li>

                </ul>
          </section>
          <section >
              </li>
              <li><a id="org7977e1a"></a>created:<br />
                <ul>
                  <li>刚完成数据绑定,还没开始编译模板</li>
                  <li>可以通过 this 操作 data 中的数据,可以调用 methods 中的方法,但是不能获取到 Virtual-DOM 的节点</li>
                  <li>可以在方法中修改 data 中数据,不会触发额外的渲染</li>

                </ul>

          </section>
          <section >
              </li>
              <li><a id="org6aa2c5e"></a>ready<br />
                <ul>
                  <li>表示组件已经渲染完成</li>
                  <li>首先执行子组件的 ready 方法</li>
                  <li>可以获得 Virtual-DOM 的节点,也可以获取子组件的 Virtual-DOM 实例</li>
                  <li>小心操作 data,避免频繁赋值</li>
                  <li>建议去除需要频繁改动的值,等操作执行结束之后再赋值</li>

                </ul>


                <div class="figure">
                  <p><img src="./imgs/img_weex_lifecycle_parent_son.png" alt="img_weex_lifecycle_parent_son.png" />
                  </p>
                </div>

                <p>
                  避免频繁赋值:
                </p>
                <div class="org-src-container">

                  <pre><code class="javascript" >// 在修改 this.count 前先获取它的值，在执行完操作后再赋值回去，如果在循环体中直接设置 this.count 的值，页面将触发 999 次局部刷新，很可能会导致页面卡顿
module.exports = {
  data: {
    count: 0
  },
  ready: function () {
    var count = this.count;
    for (var i = 0; i < 999; i++) {
      count += Math.random();
    }
    this.count = count;
  }
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org37177db"></a>destroyed<br />
                <ul>
                  <li>组件销毁时被调用</li>
                  <li>自底向上执行(先触发子组件的 destroyed 方法,再触发自身的)</li>
                  <li>先执行开发者定义的 destroyed 方法,再清除内部属性</li>
                  <li>添加的全局或者 this 的属性,建议在 destroyed 方法中手动清除,避免内存泄露</li>

                </ul>
              </li>
            </ul>

          </section>
        </section>
        <section>
          <section id="slide-org186c4cc">
            <h2 id="org186c4cc">架构分析</h2>
            <div class="outline-text-2" id="text-org186c4cc">
            </div>
          </section>
          <section id="slide-org6e524a3">
            <h3 id="org6e524a3">项目目录结构</h3>
            <p>
              选择性列了一些比较重要的目录:
            </p>
            <div class="org-src-container">

              <pre><code class="org" > ./incubator-weex                        # 根目录
-----------------------------------------------------------------------------------------
    - android/                          # Android SDK 相关目录
        - commons/                      #
        - playground/                   # Android 模板工程
        - sdk/                          # Android Weex SDK
-----------------------------------------------------------------------------------------
    - ios/                              # iOS SDK 相关
        - playground/                   # iOS 模板工程
        - sdk/                          # iOS Weex SDK
-----------------------------------------------------------------------------------------
    - packages/                         # 打包好的 JSFramework 库
        - weex-js-framework/            #
        - weex-js-runtime/              #
        - weex-legacy-framework/        #
        - weex-vanilla-framework/       #
-----------------------------------------------------------------------------------------
    - runtime/                          # JSFramework 源码目录
        - api/                          #
        - bridge/                       #
        - entries/                      #
        - frameworks/                   #
        - services/                     #
        - shared/                       #
        - vdom/                         #
-----------------------------------------------------------------------------------------
    - script/                           # 一些脚本文件
-----------------------------------------------------------------------------------------
    - weex_core/Source                  # Weex 底层支持代码(打包成 weexcore.so,SDK 引入)
        - IPC/                          # [Android] IPC 通信层
        - android/                      # [Android] JNI 层
        - base/                         #
        - core/                         #
        - include/                      #
        - third_party/                  #
        - wson/                         # wson 支持
        - CMakeLists.txt                # CMake 打包脚本
              </code></pre>
            </div>

          </section>
          <section id="slide-org8a1ec98">
            <h3 id="org8a1ec98">框架结构图</h3>
            <aside class="notes">
              <p>
                图片出处: <a href="https://zhuanlan.zhihu.com/p/25326775">https://zhuanlan.zhihu.com/p/25326775</a>
              </p>

            </aside>

            <div class="figure">
              <p><img src="./imgs/img_weex_framework_classes.jpeg" alt="img_weex_framework_classes.jpeg" />
              </p>
            </div>
          </section>
          <section id="slide-org88ee358">
            <h3 id="org88ee358">调用流程图</h3>

            <div class="figure">
              <p><img src="./imgs/img_weex_arch_flow.png" alt="img_weex_arch_flow.png" />
              </p>
            </div>
          </section>
          <section id="slide-orge03546c">
            <h3 id="orge03546c">进程模型</h3>

            <div class="figure">
              <p><img src="./imgs/img_weex_process.jpg" alt="img_weex_process.jpg" />
              </p>
            </div>
          </section>
        </section>
        <section>
          <section id="slide-orgbe40ef1">
            <h2 id="orgbe40ef1">Android SDK</h2>
            <div class="outline-text-2" id="text-orgbe40ef1">
            </div>
          </section>
          <section id="slide-org3e439b1">
            <h3 id="org3e439b1">初始化流程分析</h3>
            <p>
              整个初始化的流程,简单来说就是:
            </p>
            <ol>
              <li>获取 Application 对象</li>
              <li>读取初始化的 Config 参数</li>
              <li>配置 so 的加载方式，然后加载 weexcore.so 库</li>
              <li>加载打包在本地的 JSFramework 组件，调用 native 的方法初始化 JS 环境</li>
              <li>注册所有内置的 Weex Component 组件和 Module 组件</li>

            </ol>

          </section>
          <section id="slide-orgcb0f453">
            <h4 id="orgcb0f453">WXSDKEngine -&gt; initialize()</h4>
            <p>
              Weex 官方文档中的初始化方法：
            </p>
            <div class="org-src-container">

              <pre><code class="java" >public class WXApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();
        WXSDKEngine.initialize(this,config);
    }
}
              </code></pre>
            </div>

            <p>
              此处调用了 WXSDKEngine 方法，那么这个方法里面做了什么事情呢，我们来看下：
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >// com.taobao.weex.WXSDKEngine
public static void initialize(Application application,InitConfig config){
    synchronized (mLock) {
        if (mIsInit) {
            return;
        }
        // 此处省略，大概就是记录初始化耗时，设置日志级别什么的
        doInitInternal(application,config);
        registerApplicationOptions(application);
        mIsInit = true;
    }
}
              </code></pre>
            </div>
            <p>
              这里需要重点关注的就是 doInitInternal 和 registerApplicationOptions 这两个方法。
            </p>
          </section>
          <section id="slide-orgc011096">
            <h4 id="orgc011096">WXSDKEngine -&gt; doInitInternal()</h4>
            <p>
              其实主要初始化的工作都是由 doInitInternal 这个方法完成的，我们来看下它的代码：
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >private static void doInitInternal(final Application application,final InitConfig config){
    // 获取 Application 对象
    WXEnvironment.sApplication = application;
    // 如果 Application 对象为空，传递异常给到 JS
    if(application == null){
        WXLogUtils.e(TAG, " doInitInternal application is null");
        WXExceptionUtils.commitCriticalExceptionRT(null,
                                                   WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                   "doInitInternal",
                                                   WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "WXEnvironment sApplication is null",
                                                   null);
    }
    WXEnvironment.JsFrameworkInit = false;
    // 这里的操作在线程中完成
    WXBridgeManager.getInstance().post(new Runnable() {
            @Override
            public void run() {
                // 又要统计初始化时间什么的，忽略
                WXSDKManager sm = WXSDKManager.getInstance();
                sm.onSDKEngineInitialize();

                // 设置 Weex 初始化的 Congif 参数(可以为空)
                if(config != null ) {
                    sm.setInitConfig(config);
                }
                // 初始化 SoLoaderAdapter 默认直接调用 System.loadLibrary(so...)
                WXSoInstallMgrSdk.init(application,
                                       sm.getIWXSoLoaderAdapter(),
                                       sm.getWXStatisticsListener());
                // 加载 V8 so 库，一个叫 weexcore.so 的库
                mIsSoInit = WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
                if (!mIsSoInit) {
                    WXExceptionUtils.commitCriticalExceptionRT(null,
                                                               WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                               "doInitInternal",
                                                               WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "isSoInit false",
                                                               null);
                    return;
                }
                // 调用 WXBridgeManager 的 initScriptsFramework 方法，一系列调用最终调用到了 WXBridgeManager 的 initFramework 方法，我们后续再看
                sm.initScriptsFramework(config!=null?config.getFramework():null);
            }
        });
    // 注册了一堆默认的 Component
    register();
}
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              可以看到其中几步重要的操作通过 <code>Wxbridgemanager.Getinstance().post()</code> 在线程中完成:
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >WXBridgeManager.getInstance().post(new Runnable() {
          @Override
          public void run() {
              // do something
          }
      };
              </code></pre>
            </div>
            <p>
              其中有两个重要的方法,继续往下追 <code>initFramework</code> 方法和 <code>register</code> 方法,分两小节来介绍.
            </p>
          </section>
          <section id="slide-orgb1f5e1d">
            <h4 id="orgb1f5e1d">WXSoInstallMgrSdk =&gt; initSo()</h4>
            <p>
              加载打包在 APK 内的所有 so 文件
            </p>
            <ul>
              <li>libJavaScriptCore.so</li>
              <li>libweexcore.so</li>
              <li>libweexjsb.so</li>
              <li>libweexjss.so</li>
              <li>libweexjst.so</li>

            </ul>

          </section>
          <section >
            <p>
              <code>WXSDKEngine =&gt; doInitInternal()</code> 方法中调用了 <code>WXSoInstallMgrSdk =&gt; initSo()</code> 方法:
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >// V8_SO_NAME = "weexcore.so"
WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
              </code></pre>
            </div>

            <p>
              <code>WXSoInstallMgrSdk =&gt; initSo()</code> 方法内部实现:
            </p>
            <div class="org-src-container">

              <pre><code class="java" >/**
 * Load so library.
 *
 * If a library loader adapter exists, use this adapter to load library,
 * otherwise use {@link System#loadLibrary(String)} to load library.
 * If failed to load library, try to extract the so library and load it
 * from arembi in the .apk
 *
 * @param libName library name, like webp, not necessary to be libwep.so
 * @param version the version of the so library
 */
public static boolean initSo(String libName, int version, IWXUserTrackAdapter utAdapter) {
    // other code...

    // copy startup so
    copyStartUpSo();

    // other code...
    if (mSoLoader != null) {
        mSoLoader.doLoadLibrary(libName);
    } else {
        System.loadLibrary(libName);
    }
    // other code...
}
              </code></pre>
            </div>

          </section>
          <section id="slide-org3cc8465">
            <h4 id="org3cc8465">WXSDKEngine =&gt; regiser()</h4>
            <p>
              初始化 Framework 层之后， <code>WXSDKEngine</code> 调用了 <code>register()</code> 方法注册了一系列内置的 Component 和 Module
              内嵌的 Component 组件
            </p>
            <div class="org-src-container">

              <pre><code class="org" >| Component         | Class                         |
|-------------------+-------------------------------|
| text              | WXText.class                  |
| image             | WXImage.class                 |
| img               | WXImage.class                 |
| div               | WXDiv.class                   |
| container         | WXDiv.class                   |
| header            | WXDiv.class                   |
| footer            | WXDiv.class                   |
| scroller          | WXScroller.class              |
| slider            | WXSlider.class                |
| cycleslider       | WXSlider.class                |
| slider-neighbor   | WXSliderNeighbor.class        |
| cell              | WXCell.class                  |
| list              | WXListComponent.class         |
| vlist             | WXListComponent.class         |
| recycler          | WXListComponent.class         |
| waterfall         | WXListComponent.class         |
| simplelist        | SimpleListComponent.class     |
| recycler-list     | WXRecyclerTemplateList.class  |
| hlist             | HorizontalListComponent.class |
| cell-slot         | WXCell.class                  |
| indicator         | WXIndicator.class             |
| video             | WXVideo.class                 |
| input             | WXInput.class                 |
| textarea          | WXTextarea.class              |
| switch            | WXSwitch.class                |
| a                 | WXA.class                     |
| embed             | WXEmbed.class                 |
| web               | WXWeb.class                   |
| refresh           | WXRefresh.class               |
| loading           | WXLoading.class               |
| loading-indicator | WXLoadingIndicator.class      |
| header            | WXHeader.class                |
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              内嵌的 Module 组件
            </p>
            <div class="org-src-container">

              <pre><code class="org" >| Module       | Class                     |
|--------------+---------------------------|
| modal        | WXModalUIModule.class     |
| instanceWrap | WXInstanceWrap.class      |
| animation    | WXAnimationModule.class   |
| webview      | WXWebViewModule.class     |
| navigator    | WXNavigatorModule.class   |
| stream       | WXStreamModule.class      |
| timer        | WXTimerModule.class       |
| storage      | WXStorageModule.class     |
| clipboard    | WXClipboardModule.class   |
| globalEvent  | WXGlobalEventModule.class |
| picker       | WXPickersModule.class     |
| meta         | WXMetaModule.class        |
| webSocket    | WebSocketModule.class     |
| locale       | WXLocaleModule.class      |
              </code></pre>
            </div>

          </section>
          <section id="slide-orge140663">
            <h4 id="orge140663">WXSDKEngine -&gt; registerApplicationOptions()</h4>
            <p>
              可以认为是获取了 App 的一些环境配置
            </p>
            <div class="org-src-container">

              <pre><code class="org" >| key                  | value                                      |
|----------------------+--------------------------------------------|
| screen_width_pixels  | resources.getDisplayMetricx().widthPixels  |
| screen_height_pixels | resources.getDisplayMetricx().heightPixels |
| status_bar_height    | get status bar height                      |
              </code></pre>
            </div>

            <p>
              获取 status<sub>bar</sub><sub>height</sub> 的方式：
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >// com.taobao.weex.WXSDKEngine
int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android");
if (resourceId > 0) {
    int statusBarHeight = resources.getDimensionPixelSize(resourceId);
    registerCoreEnv("status_bar_height", String.valueOf(statusBarHeight));
}
              </code></pre>
            </div>
          </section>
          <section id="slide-org2b86252">
            <h3 id="org2b86252">Weex 页面渲染流程分析</h3>
            <div class="org-src-container">

              <pre id="Weex 加载页面的调用"><code class="java" >public class MainActivity extends AppCompatActivity implements IWXRenderListener {

    WXSDKInstance mWXSDKInstance;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mWXSDKInstance = new WXSDKInstance(this);
        mWXSDKInstance.registerRenderListener(this);
        /**
         * WXSample 可以替换成自定义的字符串，针对埋点有效。
         * template 是.we transform 后的 js 文件。
         * option 可以为空，或者通过 option 传入 js 需要的参数。例如 bundle js 的地址等。
         * jsonInitData 可以为空。
         * width 为-1 默认全屏，可以自己定制。
         * height =-1 默认全屏，可以自己定制。
         */
        mWXSDKInstance.render("WXSample", WXFileUtils.loadFileOrAsset("hello.js", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC);
    }

    /* other methods */
}
              </code></pre>
            </div>
            <p>
              来分析下 WXSDKInstance -&gt; render() 方法的内部实现, 除了参数检查之外,它其实调用的是内部的 rednerInternal 方法.
            </p>

          </section>
          <section id="slide-org1ab95b7">
            <h4 id="org1ab95b7">WXSDKInstance =&gt; renderInternal()</h4>
            <p>
              redner 方法内部调用了内部的 renderInternal 方法来进行 Weex 页面的渲染，来看下代码：
            </p>
            <div class="org-src-container">

              <pre id="WXSDKInstance.class"><code class="java" >/**
 * Render template asynchronously
 *
 * @param pageName, used for performance log.
 * @param template bundle js
 * @param options  os   iphone/android/ipad
 *                 weexversion    Weex version(like 1.0.0)
 *                 appversion     App version(like 1.0.0)
 *                 devid        Device id(like Aqh9z8dRJNBhmS9drLG5BKCmXhecHUXIZoXOctKwFebH)
 *                 sysversion    Device system version(like 5.4.4、7.0.4, should be used with os)
 *                 sysmodel     Device model(like iOS:"MGA82J/A", android:"MI NOTE LTE")
 *                 Time    UNIX timestamp, UTC+08:00
 *                 TTID(Optional)
 *                 MarkertId
 *                 Appname(Optional)  tm,tb,qa
 *                 Bundleurl(Optional)  template url
 * @param jsonInitData Initial data for rendering
 * @param flag     RenderStrategy {@link WXRenderStrategy}
 */
private void renderInternal(String pageName,
                            String template,
                            Map<String, Object> options,
                String jsonInitData,
                WXRenderStrategy flag){
                // 此处省略各种参数检查
                // 此处省略数据埋点

                // 检查 RenderContainer 是否为空，为空的话创建一个
                ensureRenderArchor();

                Map<String, Object> renderOptions = options;
                if (renderOptions == null) {
                renderOptions = new HashMap<>();
                }
                if (WXEnvironment.sDynamicMode && !TextUtils.isEmpty(WXEnvironment.sDynamicUrl) && renderOptions.get("dynamicMode") == null) {
                renderOptions.put("dynamicMode", "true");
                // 根据 URL 渲染，最终还是调用到 renderInternal 方法，最终还是会调用 WXSDKManager -> createInstance 方法
                renderByUrl(pageName, WXEnvironment.sDynamicUrl, renderOptions, jsonInitData, flag);
                return;
                }
                WXSDKManager.getInstance().setCrashInfo(WXEnvironment.WEEX_CURRENT_KEY,pageName);
                // 渲染页面，会调用 WXBridgeManager -> createInstance 方法
                WXSDKManager.getInstance().createInstance(this, template, renderOptions, jsonInitData);
                mRendered = true;
                }
              </code></pre>
            </div>

          </section>
          <section id="slide-org979110c">
            <h4 id="org979110c">WXBridgeManager =&gt; createInstance()</h4>
            <p>
              render 方法调用最终会调用到这个方法中
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >public void createInstance(final String instanceId, final String template,
                           final Map<String, Object> options, final String data) {
                final WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId);
                // 此处省略  WXSDKInstance 为空检查

                if (!isJSFrameworkInit() && reInitCount == 1 && !WXEnvironment.sDebugServerConnectable) {
                //  错误日志
                post(new Runnable() {
                @Override
                public void run() {
                // 再次初始化 JSFramework 环境
                initFramework("");
                }
                }, instanceId);
                return;
                }

                WXModuleManager.createDomModule(instance);
                post(new Runnable() {
                @Override
                public void run() {
                // 省略一堆性能日志代码
                invokeCreateInstance(instance, template, options, data);
                }
                }, instanceId);
                }
              </code></pre>
            </div>
          </section>
          <section id="slide-org7bea0d9">
            <h4 id="org7bea0d9">WXBridgeManager =&gt; invokeCreateInstance()</h4>
            <p>
              来看下 createInstance 方法最后调用到的 invokeCreateInstance 方法
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >private void invokeCreateInstance(@NonNull WXSDKInstance instance, String template, Map<String, Object> options, String data) {
                // add for sandbox, will delete on sandbox ok
                initFramework("");
                if (mMock) {
                mock(instance.getInstanceId());
                } else {
                //省略 JSFramework 环境检查
                WXModuleManager.registerWhenCreateInstance();
                try {
                BundType type = BundType.Others;
                // 创建 WXJSObject 对象
                // When render strategy is data_render, put it into options. Others keep null.
                WXJSObject renderStrategy = null;
                if (instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                renderStrategy = new WXJSObject(WXJSObject.String, WXRenderStrategy.DATA_RENDER.getFlag());
                }
                WXJSObject[] args = {instanceIdObj, instanceObj, optionsObj, dataObj, apiObj, renderStrategy};
                instance.setTemplate(template);
                instance.getApmForInstance().onStage(WXInstanceApm.KEY_PAGE_STAGES_LOAD_BUNDLE_END);

                if (!isSandBoxContext) {
                invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                return;
                }
                if (type == BundType.Vue || type == BundType.Rax || instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                invokeCreateInstanceContext(instance.getInstanceId(), null, "createInstanceContext", args, false);
                return;
                } else {
                invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                return;
                }
                } catch (Throwable e) {
                // 处理异常
                }
                }
                }
              </code></pre>
            </div>
            <p>
              后续的渲染工作就交给 native 层来完成
            </p>
          </section>
          <section id="slide-org1a3ee79">
            <h4 id="org1a3ee79">WXBridgeManager =&gt; callCreateBody()</h4>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >public int callCreateBody(String pageId, String componentType, String ref,
                          HashMap<String, String> styles, HashMap<String, String> attributes, HashSet<String> events,
                float[] margins, float[] paddings, float[] borders) {
                // 省略代码
                try {
                WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(pageId);
                if (instance != null) {
                final BasicGraphicAction action = new GraphicActionCreateBody(instance, ref, componentType,
                styles, attributes, events, margins, paddings, borders);
                WXSDKManager.getInstance().getWXRenderManager().postGraphicAction(action.getPageId(), action);
                }
                } catch (Exception e) {
                //错误处理
                }
                return IWXBridge.INSTANCE_RENDERING;
                }
              </code></pre>
            </div>

          </section>
          <section id="slide-orgc5329b0">
            <h4 id="orgc5329b0">WXBridgeManager =&gt; callAddElement()</h4>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >public int callAddElement(String pageId, String componentType, String ref, int index, String parentRef,
                          HashMap<String, String> styles, HashMap<String, String> attributes, HashSet<String> events,
                float[] margins, float[] paddings, float[] borders,boolean willLayout) {
                // 省略代码
                try {
                WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(pageId);
                if (instance != null) {
                final GraphicActionAddElement action = new GraphicActionAddElement(instance, ref, componentType, parentRef, index,
                styles, attributes, events, margins, paddings, borders);
                if(willLayout) {
                instance.addInActiveAddElementAction(ref, action);
                }else{
                WXSDKManager.getInstance().getWXRenderManager().postGraphicAction(pageId, action);
                }
                }
                } catch (Exception e) {
                // 错误处理
                }

                return IWXBridge.INSTANCE_RENDERING;
                }
              </code></pre>
            </div>
          </section>
          <section id="slide-org763ee88">
            <h3 id="org763ee88">JS Bridge</h3>
            <p>
              来看下 Android 的 SDK 中用来和 JS Engine（JavaScriptCore）进行双向通信的代码,主要的类有 WXBridgeManager.java 和 WXBridge.java.
              与 native 的 JS 方法的调用都运行在 JsBridge 线程中。
            </p>
          </section>
          <section id="slide-orgad6e9ec">
            <h4 id="orgad6e9ec">WXBridgeManager.java</h4>
            <p>
              负责通过 WXBridge.java 提供的一系列 native 接口,来完成 Java 环境和 JS 之间的交互.
            </p>

          </section>
          <section id="slide-orgce6af0d">
            <h4 id="orgce6af0d">WXBridge.java</h4>
            <p>
              封装了一层 Java 层和 JNI 层关于 JS 调用的接口,内部实现了一堆 native 调用方法.
            </p>
          </section>
          <section id="slide-orgf513cb5">
            <h4 id="orgf513cb5">注册 Component</h4>
            <p>
              来看下如何手动注册一个 Component 组件:
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >// 调用 SDK 提供的 API 注册一个 Component 实现
WXSDKEngine.registerComponent("richText", RichText.class);

// 实际调用的注册方法
public static boolean registerComponent(Map<String, Object> componentInfo, Class<? extends WXComponent> clazz) throws WXException {
                if(componentInfo == null){
                return false;
                }
                String type = (String)componentInfo.get("type");
                if(TextUtils.isEmpty(type)){
                return false;
                }
                return WXComponentRegistry.registerComponent(type,new SimpleComponentHolder(clazz), componentInfo);
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              WXComponentRegistry -&gt; registerComponent()
            </p>
            <div class="org-src-container">

              <pre id="WXComponentRegistry.java"><code class="java" >public static synchronized boolean registerComponent(final String type, final IFComponentHolder holder, final Map<String, Object> componentInfo) throws WXException {
                if (holder == null || TextUtils.isEmpty(type)) {
                return false;
                }

                //register component
                AutoScanConfigRegister.preLoad(holder);

                //execute task in js thread to make sure register order is same as the order invoke register method.
                WXBridgeManager.getInstance()
                .post(new Runnable() {
                @Override
                public void run() {
                try {
                Map<String, Object> registerInfo = componentInfo;
                if (registerInfo == null){
                registerInfo = new HashMap<>();
                }

                registerInfo.put("type",type);
                registerInfo.put("methods",holder.getMethods());
                // 注册 Component 到本地的一个静态变量 ConcurrentHashMap -> sTypeComponentMap 中
                registerNativeComponent(type, holder);
                // 调用 WXBridgeManager -> invokeRegisterComponents 方法
                registerJSComponent(registerInfo);
                sComponentInfos.add(registerInfo);
                } catch (WXException e) {
                WXLogUtils.e("register component error:", e);
                }

                }
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              WXBridgeManager -&gt; invokeRegisterComponents
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >
private void invokeRegisterComponents(List<Map<String, Object>> components, List<Map<String, Object>> failReceiver) {
                if (components == failReceiver) {
                throw new RuntimeException("Fail receiver should not use source.");
                }
                if (!isJSFrameworkInit()) {
                // JSFramework 还没初始化成功,丢到 failReceiver 列表中,等 JSFramework 初始化成功之后重新注册
                for (Map<String, Object> comp : components) {
                failReceiver.add(comp);
                }
                return;
                }
                if (components == null) {
                return;
                }
                WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(components)};
                try {
                // 调用 WXBridge.java 提供的 JNI 方法,注册到 JS 环境中
                if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_COMPONENTS, args)) {
                errorMsg = "execJS error";
                }
                } catch (Throwable e) {
                // 省略异常日志输出
                }
                // 省略异常日志输出
                }
              </code></pre>
            </div>

          </section>
          <section id="slide-org2770a17">
            <h4 id="org2770a17">注册 Module</h4>
            <p>
              来看下 Android 应用中注册 Module 的方式:
            </p>
            <div class="org-src-container">

              <pre><code class="java" >WXSDKEngine.registerModule("MyModule", MyModule.class);
              </code></pre>
            </div>

            <p>
              WXSDKEngine =&gt; registerModule()
            </p>
            <div class="org-src-container">

              <pre id="WXSDKEngine.java"><code class="java" >/**
 * Register module. This is a wrapper method for
 * {@link #registerModule(String, Class, boolean)}. The module register here only need to
 * be singleton in {@link WXSDKInstance} level.
 * @param moduleName  module name
 * @param moduleClass module to be registered.
 * @return true for registration success, false for otherwise.
 * {@link WXModuleManager#registerModule(String, ModuleFactory, boolean)}
 */
public static <T extends WXModule> boolean registerModule(String moduleName, Class<T> moduleClass,boolean global) throws WXException {
                return moduleClass != null && registerModule(moduleName, new TypeModuleFactory<>(moduleClass), global);
                }

                public static <T extends WXModule> boolean registerModule(String moduleName, ModuleFactory factory, boolean global) throws WXException {
                return WXModuleManager.registerModule(moduleName, factory,global);
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              WXModuleManager -&gt; regiserModule()
            </p>
            <div class="org-src-container">

              <pre id="WXModuleManager.java"><code class="java" >public static boolean registerModule(final String moduleName, final ModuleFactory factory, final boolean global) throws WXException {
    // 省略一系列的参数检查

    //execute task in js thread to make sure register order is same as the order invoke register method.
    WXBridgeManager.getInstance()
        .post(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 将注册的 Module 相关参数放到一个静态的 volatile ConcurrentHashMap 中
                        registerNativeModule(moduleName, factory);
                    } catch (WXException e) {
                    }
                    // 省略 global Module map

                    // 调用 WXSDKManager 的 registerJSModules 方法
                    registerJSModule(moduleName, factory);
                }
            });
    return true;
}

static boolean registerJSModule(String moduleName, ModuleFactory factory) {
    Map<String, Object> modules = new HashMap<>();
                modules.put(moduleName, factory.getMethods());
                // WXSDKManager 中调用了 WXBridgeManager -> registerModules 方法
                WXSDKManager.getInstance().registerModules(modules);
                return true;
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              WXBridgeManager =&gt; registerModules()
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >public void registerModules(final Map<String, Object> modules) {
                if (modules != null && modules.size() != 0) {
                // 确保是在 JSThread 中完成注册
                if (isJSThread()) {
                invokeRegisterModules(modules, mRegisterModuleFailList);
                } else {
                post(new Runnable() {
                @Override
                public void run() {
                invokeRegisterModules(modules, mRegisterModuleFailList);
                }
                }, null);
                }
                }
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              WXBridgeManager =&gt; invokeRegisterModules()
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >private void invokeRegisterModules(Map<String, Object> modules, List<Map<String, Object>> failReceiver) {
                if (modules == null || !isJSFrameworkInit()) {
                // JSFramework 没有初始化的情况下放到 failReceiver 列表中,下次 initFramework 的时候再次注册
                failReceiver.add(modules);
                return;
                }

                WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(modules)};
                try {
                // 通过 WXBridge.java 的 JNI 方法调用,完成 Module 注册到 JS 环境中
                if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_MODULES, args)) {
                errorMsg = "execJS error";
                }
                // 注册成功之后调用 WXModuleManager.resetModuleState(module, true); 方法更新 module 状态
                } catch (Throwable e) {
                }
                //忽略错误信息打印
                }
              </code></pre>
            </div>
          </section>
        </section>
        <section>
          <section id="slide-org02c1b2c">
            <h2 id="org02c1b2c">Weex Core</h2>
            <div class="outline-text-2" id="text-org02c1b2c">
            </div>
          </section>
          <section id="slide-org513c279">
            <h3 id="org513c279">Android &amp; JS 调用流程分析</h3>
            <p>
              Android SDK 代码分析中, <code>WXBridgeManager.java</code> 提供的很多方法都是通过 <code>WXBridge.java</code> 中定义的 JNI 接口,
              来调用 weexcore.so 中的方法, 再去调用 JSFramework 中的一些方法,来完成 Android Java 环境和 JS 环境的相互调用的.
            </p>

          </section>
          <section id="slide-org031bf49">
            <h4 id="org031bf49">WXBridge =&gt; execJS 的 JNI 接口和实现</h4>
            <div class="outline-text-4" id="text-org031bf49">
            </div>
            <ul class="org-ul">
              <li><a id="orge3b34d2"></a>JNI 接口定义和声明<br />
                <p>
                  WXBridge 中对 execJS 方法的 JNI 接口 <code>nativeExecJS()</code> 的定义:
                </p>
                <div class="org-src-container">

                  <pre id="WXBridge.java"><code class="java" >private native int nativeExecJS(String instanceId, String name, String function, WXJSObject[] args);
                  </code></pre>
                </div>

                <p>
                  JNI <code>nativeExecJS()</code> 接口在 Native 层的声明, 实际调用的是 <code>ExecJS</code> 方法：
                </p>
                <div class="org-src-container">

                  <pre id="WXBridge_jni.h"><code class="c" >// RegisterNatives.
static const JNINativeMethod kMethodsWXBridge[] =
  {
   // 省略其他 Native 方法声明
   { "nativeExecJS",
     "("
     "Ljava/lang/String;"
     "Ljava/lang/String;"
     "Ljava/lang/String;"
     "[Lcom/taobao/weex/bridge/WXJSObject;"
     ")"
     "I", reinterpret_cast<void*>(ExecJS)
                    }
                    // 省略其他 Native 方法声明
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org118237c"></a>JNI 接口的实现<br />
                <p>
                  <code>ExecJS()</code> 方法的实现, 关键的步骤就是 WeexCoreManager =&gt; PlatformBridge =&gt; CoreSide =&gt; ExecJS() ：
                </p>
                <div class="org-src-container">

                  <pre id="wx_bridge.cpp"><code class="c++" >#include "android/jniprebuild/jniheader/WXBridge_jni.h"
/**
 * Called to execute JavaScript such as . createInstance(),destroyInstance ext.
 *
 */
static jint ExecJS(JNIEnv* env, jobject jthis, jstring jinstanceid,
                   jstring jnamespace, jstring jfunction, jobjectArray jargs) {
  //省略参数检查什么的
  std::vector<VALUE_WITH_TYPE*> params;

                    for (int i = 0; i < length; i++) {
                    VALUE_WITH_TYPE* param = nullptr;

                    param = WeexCore::getValueWithTypePtr();
                    auto jni_object = base::android::ScopedLocalJavaRef<jobject>(
                    env, env->GetObjectArrayElement(jargs, i));
                    auto wx_js_object =
                    std::unique_ptr<WXJSObject>(new WXJSObject(env, jni_object.Get()));
                    addParamsFromJArgs(params, param, env, wx_js_object);
                    }
                    // 实际就是调了这一坨代码去调用 JSFramework 中的方法
                    auto result =
                    WeexCoreManager::Instance()->getPlatformBridge()->core_side()->ExecJS(instance_id.getChars(), name_space.getChars(), function.getChars(), params);
                    freeParams(params);
                    return result;
                    }
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-orgfac7ae4">
            <h4 id="orgfac7ae4">ExecJS 方法的调用流程</h4>
            <p>
              先来看下这一长串的调用,这步调用完成了调用 V8 Engine 提供的 API, 调用到了 JSFramework 的方法:
            </p>
            <div class="org-src-container">

              <pre id="wx_bridge.cpp"><code class="c++" >// JNI 实现方法中的调用
WeexCoreManager::Instance()->getPlatformBridge()->core_side()->ExecJS(instance_id.getChars(), name_space.getChars(), function.getChars(), params);
// ExecJS 方法调用
WeexCoreManager::Instance()->script_bridge()->script_side()->ExecJS(instanceId, nameSpace, func, params);
              </code></pre>
            </div>

            <p>
              整个 <code>ExecJS</code> 默认的调用链可以表示为：
            </p>
            <pre class="example" id="execJS 调用顺序">
WeexCoreManager =&gt; getPlatformBridge()       #file: wx_bridge.cpp
-&gt; AndroidBridgeInSimple =&gt; core_side()      #file: android_bridge.cpp
-&gt; CoreSideInPlatform =&gt; ExecJS()            #file: core_side_in_platform.cpp
-&gt; WeexCoreManager =&gt; script_bridge()        #file: wx_bridge.cpp
-&gt; ScriptBridgeInMultiProcess =&gt;             #file: script_bridge_in_multi_process.cpp
-&gt; ScriptSideInMultiProcess =&gt; ExecJS()      #file: script_side_in_multi_process.cpp
-&gt; IPCSender =&gt; send()                       #file: IPCSender.cpp
            </pre>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="org5d5f223"></a>WeexCoreManager =&gt; getPlatformBridge()<br />
                <div class="org-src-container">

                  <pre id="weex_core_manager.h"><code class="c" >class WeexCoreManager {
  // 省略一些方法
  inline void set_platform_bridge(PlatformBridge *bridge) {
    platform_bridge_ = bridge;
  }

  inline PlatformBridge *getPlatformBridge() { return platform_bridge_; }
  // 省略一些方法
 private:
  PlatformBridge *platform_bridge_;
  // 省略一些属性
}
                  </code></pre>
                </div>

                <p>
                  Android 中，InitFramework 方法中会调用 set<sub>platform</sub><sub>bridge</sub> 方法：
                </p>
                <div class="org-src-container">

                  <pre id="wx_bridge.cpp"><code class="c++" >static jint InitFramework(JNIEnv* env, jobject object, jstring script,
                          jobject params) {
  // other code...
  // Init platform bridge
  PlatformBridge* bridge = new AndroidBridgeInSimple;
  WeexCoreManager::Instance()->set_platform_bridge(bridge);
  // other code...
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgcc7be90"></a>-&gt; core<sub>side</sub>()<br />
                <p>
                  <code>AndroidBridgeInSimple</code> 的构造方法中会设置 CoreSide 为 <code>CoreSideInPlatform</code>
                </p>
                <div class="org-src-container">

                  <pre id="android_bridge.cpp"><code class="c++" >// AndroidBridgeInSimple 继承自 PlatformBridge
AndroidBridgeInSimple::AndroidBridgeInSimple() {
  // 调用了 PlatformBridge -> set_core_side(CoreSide* core_side) 方法
  set_core_side(new CoreSideInPlatform);
  // 调用了 PlatformBridge -> set_platform_side(PlatformSide* platform_side) 方法
  set_platform_side(new AndroidSide);
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgd68bd13"></a>-&gt; CoreSideInPlatform =&gt; ExecJS()<br />
                <p>
                  CoreSideInPlatform 的 ExecJS 方法:
                </p>
                <div class="org-src-container">

                  <pre id="core_side_in_platform.cpp"><code class="c++" >int CoreSideInPlatform::ExecJS(const char *instanceId, const char *nameSpace,
                               const char *func,
                               std::vector<VALUE_WITH_TYPE *> &params) {
                    return WeexCoreManager::Instance()->script_bridge()->script_side()->ExecJS(instanceId, nameSpace, func, params);
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgfbc9bbf"></a>-&gt; WeexCoreManager =&gt; script<sub>bridge</sub>()<br />
                <p>
                  WeexCoreManager 中，通过两个方法来操作 <code>script_bridge_</code> :
                </p>
                <div class="org-src-container">

                  <pre id="weex_core_manager.h"><code class="c" >inline ScriptBridge *script_bridge() { return script_bridge_; }

inline void set_script_bridge(ScriptBridge *script_bridge) {
  script_bridge_ = script_bridge;
}
                  </code></pre>
                </div>

          </section>
          <section >
            <p>
              Android 环境中，在 InitFramework 方法中进行设置：
            </p>
            <div class="org-src-container">

              <pre id="wx_bridge.cpp"><code class="c++" >static jint InitFramework(JNIEnv* env, jobject object, jstring script,
                          jobject params) {
  // Init params
  // initFromParam 关系到后面的 isSingleProcess()
  std::vector<INIT_FRAMEWORK_PARAMS*> params_vector =
                initFromParam(env, params, [](const char* status_code, const char* error_msg) {
                WeexCoreManager::Instance()
                ->getPlatformBridge()
                ->platform_side()
                ->ReportNativeInitStatus(status_code, error_msg);
                });
                // Set project mode
                if (isSingleProcess()) {
                WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_SO);
                } else {
                WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_PROCESS);
                }
                // Init script bridge
                if (WeexCoreManager::Instance()->project_mode() == WeexCoreManager::ProjectMode::MULTI_PROCESS) {
                WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
                } else {
                WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiSo);
                }
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              <code>isSingleProcess()</code> 的值(设置的话需要在初始化之前,默认值为 false)：
            </p>
            <div class="org-src-container">

              <pre id="params_utils.cpp"><code class="c++" >bool g_is_single_process = false;
bool isSingleProcess() { return g_is_single_process; }

std::vector<INIT_FRAMEWORK_PARAMS*> initFromParam(JNIEnv* env,
                jobject params,
                const std::function<void(const char*, const char*)>&ReportNativeInitStatus) {
                // other code...

                jmethodID m_use_single_process = env->GetMethodID(c_params, "getUseSingleProcess", "()Ljava/lang/String;");
                if (m_use_single_process == nullptr) {
                LOGE("getUseSingleProcess method is missing");
                } else {
                jobject j_use_single_process =
                env->CallObjectMethod(params, m_use_single_process);
                const char* use_single_process =
                env->GetStringUTFChars((jstring)(j_use_single_process), nullptr);
                LOGE("g_use_single_process is %s ", use_single_process);
                if (use_single_process == nullptr) {
                g_is_single_process = false;
                } else {
                g_is_single_process = strstr(use_single_process, "true") != nullptr;
                env->DeleteLocalRef(j_use_single_process);
                }
                }

                // other code...
                }
              </code></pre>
            </div>
            <p>
              这里的 <code>g_is_single_process</code> 是通过调用 JNI 接口 <code>WXParams =&gt; getUseSingleProcess()</code> 的返回值来进行配置的
            </p>

            <div class="org-src-container">

              <pre id="WXBridgeManager => setUseSingleProcess()"><code class="java" >WXBridgeManager.getInstance().setUseSingleProcess(false); // ture or false
              </code></pre>
            </div>

          </section>
          <section >
              </li>
              <li><a id="org4b66f37"></a>-&gt; script<sub>side</sub>()<br />
                <p>
                  来看下默认的实现吧,默认的 <code>script_bridge_</code> 是 <code>ScriptBridgeInMultiProcess</code>
                </p>
                <div class="org-src-container">

                  <pre id="script_bridge_in_multi_process.cpp"><code class="c++" >ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
  set_script_side(new bridge::script::ScriptSideInMultiProcess);
  set_core_side(new CoreSideInScript);

  //other code...
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgbc21e66"></a>-&gt; ExecJS() -&gt; IPCSender =&gt; send()<br />
                <p>
                  方法最终调用了 <code>IPCSender =&gt; send()</code> 方法，以 IPC 的方式与 JS 进行交互:
                </p>
                <div class="org-src-container">

                  <pre id="script_side_in_multi_process.cpp"><code class="c++" >int ScriptSideInMultiProcess::ExecJS(const char *instanceId,
                                     const char *nameSpace, const char *func,
                                     std::vector<VALUE_WITH_TYPE *> &params) {
                    try {
                    if(sender_ == nullptr) {
                    LOGE("ExecJS sender is null");
                    return false;
                    }
                    std::unique_ptr<IPCSerializer> serializer(createIPCSerializer());
                    serializer->setMsg(static_cast<uint32_t>(IPCJSMsg::EXECJS));
                    serializer->add(instanceId, strlen(instanceId));
                    if (nameSpace)
                    serializer->add(nameSpace, strlen(nameSpace));
                    else {
                    uint16_t tmp = 0;
                    serializer->add(&tmp, 0);
                    }
                    serializer->add(func, strlen(func));

                    for (int i = 0; i < params.size(); i++) {
                    VALUE_WITH_TYPE *param = params[i];
                    addParamsToIPCSerializer(serializer.get(), param);
                    }

                    std::unique_ptr<IPCBuffer> buffer = serializer->finish();

                    // 在这里通过 IPC 的方式被发送走了,有 IPC 的地方,就有进程间通讯 emmmmm.... 继续往下跟吧
                    std::unique_ptr<IPCResult> result = sender_->send(buffer.get());
                    if (result->getType() != IPCType::INT32) {
                    LOGE("execJS Unexpected result type");
                    return false;
                    }

                    return result->get<jint>();

                    } catch (IPCException &e) {
                    LOGE("%s", e.msg());
                    // report crash here
                    WeexCoreManager::Instance()
                    ->getPlatformBridge()
                    ->platform_side()
                    ->ReportServerCrash(instanceId);
                    return false;
                    }
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org194b341"></a>-&gt; weex<sub>js</sub><sub>engine</sub> =&gt; exexJS()&#xa0;&#xa0;&#xa0;<span class="tag"><span class="confirm">confirm</span></span><br />
                <p>
                  在项目里中的代码中没有找到接收 <code>IPCJSMsg::EXECJS</code>, 在 weex 内核的代码中找到了关于执行 JS 的一段方法：
                </p>
                <div class="org-src-container">

                  <pre id="com_taobao_weex_bridge_WXBridge.cpp"><code class="c++" >/**
 * Called to execute JavaScript such as . createInstance(),destroyInstance ext.
 *
 */
jint Java_com_taobao_weex_bridge_WXBridge_execJS(JNIEnv *env, jobject this1, jstring jinstanceid,
                                                 jstring jnamespace, jstring jfunction,
                                                 jobjectArray jargs) {
  v8::HandleScope handleScope;
  v8::Isolate::Scope isolate_scope(globalIsolate);
  v8::Context::Scope ctx_scope(V8context);
  v8::TryCatch try_catch;
  int length = env->GetArrayLength(jargs);
  v8::Handle<v8::Value> obj[length];

                    // 省略将 jargs 转换为 obj[] 的代码

                    const char *func = env->GetStringUTFChars(jfunction, 0);
                    v8::Handle<v8::Object> global = V8context->Global();
                    v8::Handle<v8::Function> function;
                    v8::Handle<v8::Value> result;
                    // 根据 jnamespace 和 jfunction 找到需要运行的函数，并获得返回值
                    if (jnamespace == NULL) {
                    function = v8::Handle<v8::Function>::Cast(global->Get(v8::String::New(func)));
                    result = function->Call(global, length, obj);
                    }
                    else {
                    v8::Handle<v8::Object> master = v8::Handle<v8::Object>::Cast(global->Get(jString2V8String(env, jnamespace)));
                    function = v8::Handle<v8::Function>::Cast(master->Get(jString2V8String(env, jfunction)));
                    result = function->Call(master, length, obj);
                    }

                    if (result.IsEmpty()) {
                    assert(try_catch.HasCaught());
                    ReportException(globalIsolate, &try_catch, jinstanceid, func);
                    env->ReleaseStringUTFChars(jfunction, func);
                    return false;
                    }
                    env->ReleaseStringUTFChars(jfunction, func);
                    return true;
                    }
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-orgc266336">
            <h4 id="orgc266336">WeexJSConnection 创建并启动 IPC 服务</h4>
            <p>
              IPC 服务其实实在 WeexSDK 初始化的时候创建的, 通过 JNI 调用 weexcore.so 中的方法创建并启动.
            </p>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="org30e0b6e"></a>WXBridge 初始化<br />
                <p>
                  <code>WXBridge =&gt; initFramework()</code> 调用 JNI <code>InitFramework()</code> 的时候会设置 <code>ScriptBridge</code> 对象(<code>ScriptBridgeInMultiProcess</code>):
                </p>
                <div class="org-src-container">

                  <pre id="wx_bridge.cpp"><code class="c++" >static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
  // other code...
  WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
  // other code...
}
                  </code></pre>
                </div>

          </section>
          <section >
            <p>
              <code>ScriptBridgeInMultiProcess</code> 对象的初始化方法中会创建 <code>MultiProcessAndSoInitializer</code> 对象:
            </p>
            <div class="org-src-container">

              <pre id="script_bridge_in_multi_process.cpp"><code class="c++" >ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
  // 之前的 script_side 配置
  set_script_side(new bridge::script::ScriptSideInMultiProcess);
  set_core_side(new CoreSideInScript);

  // 多进程通信初始化,里面包含了对 IPC 监听的启动过程
  std::unique_ptr<MultiProcessAndSoInitializer> initializer(new MultiProcessAndSoInitializer);
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              <code>MultiProcessAndSoInitializer</code> 对象初始化的时候调用 <code>WeexJSConnection</code> 的 <code>start()</code> 方法启动 IPC 服务:
            </p>
            <div class="org-src-container">

              <pre id="multi_process_and_so_initializer.cpp"><code class="c++" >bool MultiProcessAndSoInitializer::Init(const std::function<void(IPCHandler*)>& OnHandlerCreated,
                const std::function<bool(std::unique_ptr<WeexJSConnection>, std::unique_ptr<IPCHandler>, std::unique_ptr<IPCHandler>)>& OnInitFinished,
                const std::function<void(const char*, const char*, const char*)>& ReportException){
                // other code...
                startInitFrameWork:
                try {
                auto handler = std::move(createIPCHandler());
                auto server_handler = std::move(createIPCHandler());
                OnHandlerCreated(server_handler.get());
                std::unique_ptr<WeexJSConnection> connection(new WeexJSConnection());
                // 启动 IPC 服务,开启 listen()
                auto sender = connection->start(handler.get(), server_handler.get(), reinit);
                // other code...
                } catch (IPCException& e) {
                // other code...
                }
                return true;
                }
              </code></pre>
            </div>

          </section>
          <section >
              </li>
              <li><a id="orgd7e7a1b"></a>WeexJSConnection 启动 IPC 服务线程<br />
                <p>
                  要创建线程，先来看下 <code>pthread_create</code> 方法:
                </p>
                <div class="org-src-container">

                  <pre><code class="c++" >#include <pthread.h>
                    /*
                    * pthread_t: 指向线程标识符的指针
                    * pthread_attr_t: 设置线程属性
                    * start_routine: 线程运行函数的起始地址
                    * arg: 最后一个参数是运行函数的参数
                    */
                    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
                  </code></pre>
                </div>

                <p>
                  在 <code>WeexJSConnection</code> 的 <code>start</code> 方法中调用了 <code>pthread_create()</code> 来创建 IPC 服务线程:
                </p>
                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >IPCSender *WeexJSConnection::start(IPCHandler *handler, IPCHandler *serverHandler, bool reinit) {
  // other code...
  int i = pthread_create(&ipcServerThread, &threadAttr, newIPCServer, &td);
  while (newThreadStatus == UNFINISH) {
    continue;
  }

  if(newThreadStatus == ERROR) {
    throw IPCException("failed to map ashmem region");
  }
  // other code...
}
                  </code></pre>
                </div>

                <p>
                  <code>pthread_create()</code> 方法中传入的函数参数 <code>newIPCServer()</code> 的定义,在这个方法中开启了监听 <code>IPCListener =&gt; listen()</code> :
                  <a id="org4dc6828"></a>
                </p>
                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >static void *newIPCServer(void *_td) {
  // other code...
  // 初始化 IPCHandler 来处理消息
  const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
                    // 初始化 IPCSender 来发送消息
                    std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
                    // 创建了 IPCListener 来接收消息
                    std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
                    newThreadStatus = SUCCESS;

                    try {
                    futexPageQueue->spinWaitPeer();
                    // 启动 IPC 消息监听 looper
                    listener->listen();
                    } catch (IPCException &e) {
                    LOGE("server died");
                    close(td->ipcServerFd);
                    base::android::DetachFromVM();
                    pthread_exit(NULL);
                    }
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org2e30027"></a>IPCSender/IPCListener/IPCHandler 的创建<br />
                <p>
                  <code>newIPCServer()</code> 方法中完成了 IPC 流程中三个重要角色的创建：
                </p>

                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >// 初始化 IPCHandler 来处理消息
const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
                    // 初始化 IPCSender 来发送消息
                    std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
                    // 创建了 IPCListener 来接收消息
                    std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
                  </code></pre>
                </div>
              </li>
            </ul>
          </section>
          <section id="slide-org40489cd">
            <h4 id="org40489cd">Android IPCSender</h4>
            <p>
              WXBridge 的 execJS 方法实际是调用了 CoreSideInMultiProcess 中的 IPCSender 的 send() 方法发送 IPC 消息的.
            </p>

          </section>
          <section >
            <ul class="org-ul">
              <li><a id="org7c79f1d"></a>CoreSideInMultiProcess -&gt; WeexJSConnection =&gt; sender()<br />
                <p>
                  先来看下这个 <code>sender_</code> 对象, <code>ScriptBridgeInMultiProcess</code> 的 <code>sender_</code> 是在 <code>ScriptSideInMultiProcess</code> 中被赋值的:
                </p>
                <div class="org-src-container">

                  <pre id="script_bridge_in_multi_process.cpp"><code class="c++" >ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
  // other code...
  bool passable = initializer->Init
    (
     [this](IPCHandler *handler) { RegisterIPCCallback(handler); },
     [this](std::unique_ptr<WeexJSConnection> connection,

                    std::unique_ptr<IPCHandler> handler,
                    std::unique_ptr<IPCHandler> server_handler) {
                    // 将 ScriptSideInMultiProcess 中的 sender 赋值为 WeexJSConnection -> sender()
                    static_cast<bridge::script::ScriptSideInMultiProcess *>(script_side())->set_sender(connection->sender());
                    connection_ = std::move(connection);
                    handler_ = std::move(handler);
                    server_handler_ = std::move(server_handler);
                    LOGE("ScriptBridgeInMultiProcess finish %x %x", server_handler_.get(),
                    server_handler.get());
                    return true;
                    },
                    [this](const char *page_id, const char *func,
                    const char *exception_string) {
                    WeexCoreManager::Instance()
                    ->getPlatformBridge()
                    ->platform_side()
                    ->ReportException(page_id, func, exception_string);
                    });
                    // other code...
                    }
                  </code></pre>
                </div>

                <p>
                  WeexJSConnection =&gt; sender()
                </p>
                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >// m_impl: new WeexJSConnectionImpl
IPCSender* WeexJSConnection::sender() {
  return m_impl->serverSender.get();
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgf2fb660"></a>-&gt; WeexJSConnection =&gt; sender()<br />
                <p>
                  这里的实际发送消息的 IPCSender 对象，实际是在 <a href="#/slide-org4dc6828">IPC 服务创建</a> 的时候进行初始化的.
                </p>

                <p>
                  初始化的时候调用的设置 IPCSender 代码：
                </p>
                <div class="org-src-container">

                  <pre><code class="c++" >std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
                  </code></pre>
                </div>

                <p>
                  IPCSender 中的 <code>createIPCSender()</code> 方法, 实际上就是创建了一个 <code>IPCSenderImpl</code>  实例：
                </p>
                <div class="org-src-container">

                  <pre id="IPCSender.cpp"><code class="c++" >std::unique_ptr<IPCSender> createIPCSender(IPCFutexPageQueue* futexPageQueue, IPCHandler* handler)
                    {
                    return std::unique_ptr<IPCSender>(new IPCSenderImpl(futexPageQueue, handler));
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgbd99370"></a>-&gt; IPCSenderImpl =&gt; send()<br />
                <p>
                  实际调用了 <code>IPCCommunicator =&gt; doSendBufferOnly()</code> 来发送 IPC 消息：
                </p>
                <div class="org-src-container">

                  <pre id="IPCSender.cpp"><code class="c++" >std::unique_ptr<IPCResult> IPCSenderImpl::send(IPCBuffer* buffer)
                    {
                    doSendBufferOnly(buffer);
                    if (checkBufferAsync(buffer))
                    return createVoidResult();

                    while (true) {
                    uint32_t msg = doReadPackage();
                    bool isAsync = !!(msg & MSG_FLAG_ASYNC);
                    msg &= MSG_MASK;
                    // 通过抛异常方式结束消息发送循环
                    if (msg == MSG_END) {
                    std::unique_ptr<IPCResult> result = assembleResult();
                    releaseBlob();
                    return result;
                    } else if (msg == MSG_TERMINATE) {
                    releaseBlob();
                    throw IPCException("peer terminates");
                    }
                    std::unique_ptr<IPCArguments> arguments = assembleArguments();
                    releaseBlob();
                    std::unique_ptr<IPCResult> sendBack = m_handler->handle(msg, arguments.get());
                    if (!isAsync) {
                    std::unique_ptr<IPCBuffer> resultBuffer = generateResultBuffer(sendBack.get());
                    doSendBufferOnly(resultBuffer.get());
                    }
                    }
                    }
                  </code></pre>
                </div>

                <p>
                  Weex 底层提供的 IPC 交互方式是通过 <code>memcpy()</code> 方法创建共享内存的方式来实现的：
                </p>
                <div class="org-src-container">

                  <pre id="IPCCommunicator.cpp"><code class="c++" >void IPCCommunicator::doSendBufferOnly(const void* _data, size_t length)
{
  const char* data = static_cast<const char*>(_data);
                    size_t pageSize = m_futexPageQueue->getPageSize();
                    ssize_t byteTransfered;
                    uint32_t* dstLength = static_cast<uint32_t*>(m_futexPageQueue->getCurrentWritePage());
                    // special handle the first part, which need a size
                    // as header.
                    dstLength[0] = length;

                    IPC_LOGD("send bytes: length: %zu", length);
                    byteTransfered = std::min(length, pageSize - sizeof(uint32_t));
                    // 将发送的消息，写到共享内存中
                    memcpy(dstLength + 1, data, byteTransfered);
                    m_futexPageQueue->stepWrite();
                    // multiple page package
                    if (length > byteTransfered) {
                    data += byteTransfered;
                    length -= byteTransfered;
                    IPC_LOGD("sent bytes: remaining length: %zu, transfered: %zu", length, byteTransfered);

                    while (length > 0) {
                    byteTransfered = doSendBufferPage(data, length, pageSize);
                    data += byteTransfered;
                    length -= byteTransfered;
                    IPC_LOGD("sent bytes: remaining length: %zu, transfered: %zu", length, byteTransfered);
                    }
                    }
                    }
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-org5691999">
            <h4 id="org5691999">Android IPCListener</h4>
            <p>
              IPCListener 用来监听 IPC 消息，并传递给 IPCHandler
            </p>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="org5df59d5"></a>WeexJSConnection =&gt; newIPCServer() -&gt; listener<br />
                <p>
                  在创建 IPC 服务的时候创建了 IPCListener 的实例,并开启了消息监听:
                </p>
                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >static void *newIPCServer(void *_td) {
  // other code...
  // 创建了 IPCListener 来接收消息
  std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
                    try {
                    // 启动 IPC 消息监听 looper
                    listener->listen();
                    } catch (IPCException &e) {
                    // other code...
                    }
                    }

                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="orge0f1c5d"></a>-&gt; IPCListener =&gt; createIPCListener()<br />
                <p>
                  创建一个 <code>IPCListener</code>, 实际创建的是 <code>IPCListenerImpl</code> 的一个实例,它内部实现了 <code>listen()</code> 方法:
                </p>

                <div class="org-src-container">

                  <pre id="IPCListener.cpp"><code class="c++" >std::unique_ptr<IPCListener> createIPCListener(IPCFutexPageQueue* futexPageQueue, IPCHandler* handler) {
                    return std::unique_ptr<IPCListener>(new IPCListenerImpl(futexPageQueue, handler));
                    }
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org5de3199"></a>-&gt; Ipclistenerimpl =&gt; listen()<br />
                <p>
                  <code>IPCListenerImpl</code> 内部实现的 <code>listen()</code> 方法, 在线程中开启消息队列, 从共享内存中读取 <code>IPCSender</code> 写入的消息, 并交给 <code>IPCHandler</code> 来处理:
                </p>
                <div class="org-src-container">

                  <pre id="IPCListener.cpp"><code class="c++" >void IPCListenerImpl::listen() {
  // 开启一个消息循环
  while (true) {
    uint32_t msg = doReadPackage();
    bool isAsync = !!(msg & MSG_FLAG_ASYNC);
    msg &= MSG_MASK;
    // 抛异常的方式结束消息循环
    if (msg == MSG_END)
      throw IPCException("unexpected MSG_END");
    else if (msg == MSG_TERMINATE) {
      releaseBlob();
      throw IPCException("peer terminates");
    }
    std::unique_ptr<IPCArguments> arguments = assembleArguments();
                    releaseBlob();
                    IPCArguments*  pArguments = arguments.get();
                    // IPCHandler 来处理收到的消息和参数
                    std::unique_ptr<IPCResult> sendBack = m_handler->handle(msg, pArguments);
                    if (!isAsync) {
                    std::unique_ptr<IPCBuffer> resultBuffer = generateResultBuffer(sendBack.get());
                    doSendBufferOnly(resultBuffer.get());
                    }
                    }
                    }
                  </code></pre>
                </div>
              </li>
            </ul>

          </section>
          <section id="slide-orgae2a51a">
            <h4 id="orgae2a51a">Android IPCHandler</h4>
            <p>
              IPCHandler 用来处理接收到的 IPC 消息
            </p>
          </section>
          <section >
            <ul class="org-ul">
              <li><a id="orgbb4939b"></a>WeexJSConnection =&gt; newIPCServer() -&gt; handler<br />
                <div class="org-src-container">

                  <pre id="WeexJSConnection.cpp"><code class="c++" >static void *newIPCServer(void *_td) {
  // other code...
  // 初始化 IPCHandler 来处理消息
  const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
                    // other code...
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="org49c4d8a"></a>-&gt; IPCHandler =&gt; createIPCHandler()<br />
                <p>
                  <code>createIPCHandler()</code> 实际上创建了一个 <code>IPCHandlerImpl</code> 的实例，它内部实现了 <code>handle()</code> 方法:
                </p>
                <div class="org-src-container">

                  <pre><code class="c++" >std::unique_ptr<IPCHandler> createIPCHandler()
                    {
                    return std::unique_ptr<IPCHandler>(new IPCHandlerImpl);
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="org0bd5891"></a>-&gt; IPCHandlerImpl =&gt; handler()<br />
                <div class="org-src-container">

                  <pre><code class="c++" >std::unique_ptr<IPCResult> IPCHandlerImpl::handle(uint32_t msg, IPCArguments* arguments)
                    {
                    auto it = m_map.find(msg);
                    if (it == m_map.end()) {
                    IPC_LOGE("unable to find msg: %d", msg);
                    return createVoidResult();
                    }
                    return it->second(arguments);
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="orgb9ab2ba"></a>注册 IPCHandler<br />
                <p>
                  IPCHandlerImpl 中用一个 Map 数据结构来存储各种 IPC 消息的回调方法:
                </p>
                <div class="org-src-container">

                  <pre id="IPCHandler.cpp"><code class="c++" >class IPCHandlerImpl : public IPCHandler {
  // other code...
private:
  typedef std::unordered_map<int, std::function<std::unique_ptr<IPCResult>(IPCArguments*)>> MapType;
                    // IPCHandlerImpl 中持有一个消息回调方法的 map
                    MapType m_map;
                    };
                  </code></pre>
                </div>

                <p>
                  注册消息回调的方法, 比较简单，就是将一个 int 值作为 key，将一个回调方法作为 value 插入到声明好的一个 Map 中:
                </p>
                <div class="org-src-container">

                  <pre id="IPCHandler.cpp"><code class="c++" >void IPCHandlerImpl::registerHandler(int msg, const std::function<std::unique_ptr<IPCResult>(IPCArguments*)>& handler)
                    {
                    m_map.insert(MapType::value_type(msg, handler));
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="org57bc20e"></a>内部的 IPCHandler 注册时机<br />
                <p>
                  是的,还是这个熟悉的方法 <code>WXBridge=&gt;nativeInitFramework()</code> -&gt; <code>wx_bridge =&gt; InitFramework()</code>.
                  由于 IPC 的方式只存在于开启多进程的情况下，所以内置的 <code>IPCHandler</code> 也只在多进程模式下被注册：
                </p>
                <div class="org-src-container">

                  <pre id="wx_bridge.cpp"><code class="c++" >static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
  // other code
  // Android SDK 中默认的 ProjectMode = MULTI_PROCESS，所以会初始化 ScriptBridgeInMultiProcess.
  if (WeexCoreManager::Instance()->project_mode() == WeexCoreManager::ProjectMode::MULTI_PROCESS) {
    WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
  }
  // other code
}
                  </code></pre>
                </div>

                <p>
                  <code>ScriptBridgeInMultiProcess</code> 的构造方法中，会调用内部的 IPCCallback 注册：
                </p>
                <div class="org-src-container">

                  <pre id="script_bridge_in_multi_process.cpp"><code class="c++" >ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
  // other code...
  [this](IPCHandler *handler) { RegisterIPCCallback(handler); }
    // other code...
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgf983cf5"></a>默认注册的 IPCHandler<br />
                <p>
                  <code>ScriptBridgeInMultiProcess =&gt; RegisterIPCCallback()</code> 方法中，注册了很多内置的 IPC 回调方法:
                </p>
                <div class="org-src-container">

                  <pre id="script_bridge_in_multi_process.cpp"><code class="c++" >void ScriptBridgeInMultiProcess::RegisterIPCCallback(IPCHandler *handler) {
  LOGE("RegisterIPCCallback is running");
  handler->registerHandler(static_cast<uint32_t>(IPCProxyMsg::SETJSFVERSION),
                    HandleSetJSVersion);
                    //省略了一系列 registerHandler 方法
                    }
                  </code></pre>
                </div>

                <p>
                  <code>RegisterIPCCallback()</code> 方法中注册的所有的 <code>IPCHandler</code> 回调：
                </p>
                <table id="org785a80a" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


                  <colgroup>
                    <col  class="org-left" />

                    <col  class="org-left" />

                    <col  class="org-left" />

                    <col  class="org-left" />
                  </colgroup>
                  <thead>
                    <tr>
                      <th scope="col" class="org-left">Key(enum IPCProxyMsg)</th>
                      <th scope="col" class="org-left">Handler Value</th>
                      <th scope="col" class="org-left">Function(Ignore arguments)</th>
                      <th scope="col" class="org-left">Source File</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="org-left">SETJSFVERSION</td>
                      <td class="org-left">HandleSetJSVersion</td>
                      <td class="org-left">public void setJSFrmVersion()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">REPORTEXCEPTION</td>
                      <td class="org-left">HandleReportException</td>
                      <td class="org-left">public void reportJSException()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLNATIVE</td>
                      <td class="org-left">HandleCallNative</td>
                      <td class="org-left">public int callNative()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLNATIVEMODULE</td>
                      <td class="org-left">HandleCallNativeModule</td>
                      <td class="org-left">public Object callNativeModule()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLNATIVECOMPONENT</td>
                      <td class="org-left">HandleCallNativeComponent</td>
                      <td class="org-left">public void callNativeComponent()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLADDELEMENT</td>
                      <td class="org-left">HandleCallAddElement</td>
                      <td class="org-left">public int callAddElement()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">SETTIMEOUT</td>
                      <td class="org-left">HandleSetTimeout</td>
                      <td class="org-left">public void setTimeoutNative()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">NATIVELOG</td>
                      <td class="org-left">HandleCallNativeLog</td>
                      <td class="org-left">public void d(String msg)</td>
                      <td class="org-left">WXLogUtils.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLCREATEBODY</td>
                      <td class="org-left">FunctionCallCreateBody</td>
                      <td class="org-left">public int callCreateBody()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLUPDATEFINISH</td>
                      <td class="org-left">FunctionCallUpdateFinish</td>
                      <td class="org-left">public int callUpdateFinish()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLCREATEFINISH</td>
                      <td class="org-left">FunctionCallCreateFinish</td>
                      <td class="org-left">public int callCreateFinish()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLREFRESHFINISH</td>
                      <td class="org-left">FunctionCallRefreshFinish</td>
                      <td class="org-left">public int callRefreshFinish()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLUPDATEATTRS</td>
                      <td class="org-left">FunctionCallUpdateAttrs</td>
                      <td class="org-left">public int callUpdateAttrs()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLUPDATESTYLE</td>
                      <td class="org-left">FunctionCallUpdateStyle</td>
                      <td class="org-left">public int callUpdateStyle()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLREMOVEELEMENT</td>
                      <td class="org-left">FunctionCallRemoveElement</td>
                      <td class="org-left">public int callRemoveElement()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLMOVEELEMENT</td>
                      <td class="org-left">FunctionCallMoveElement</td>
                      <td class="org-left">public int callMoveElement()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLADDEVENT</td>
                      <td class="org-left">FunctionCallAddEvent</td>
                      <td class="org-left">public int callAddEvent()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLREMOVEEVENT</td>
                      <td class="org-left">FunctionCallRemoveEvent</td>
                      <td class="org-left">public int callRemoveElement()</td>
                      <td class="org-left">WXBridge.java</td>
                    </tr>
                  </tbody>
                  <tbody>
                    <tr>
                      <td class="org-left">CALLGCANVASLINK</td>
                      <td class="org-left">HandleCallGCanvasLinkNative</td>
                      <td class="org-left">const char *CallGCanvasFun()</td>
                      <td class="org-left">ExtendJSApi.cpp</td>
                    </tr>

                    <tr>
                      <td class="org-left">CALLT3DLINK</td>
                      <td class="org-left">HandleT3DLinkNative</td>
                      <td class="org-left">const char* CallT3dFunc()</td>
                      <td class="org-left">ExtendJSApi.cpp</td>
                    </tr>

                    <tr>
                      <td class="org-left">SETINTERVAL</td>
                      <td class="org-left">HandleSetInterval</td>
                      <td class="org-left">int CoreSideInScript::SetInterval()</td>
                      <td class="org-left">code<sub>side</sub><sub>in</sub><sub>script.cpp</sub></td>
                    </tr>

                    <tr>
                      <td class="org-left">CLEARINTERVAL</td>
                      <td class="org-left">HandleClearInterval</td>
                      <td class="org-left">int CoreSideInScript::ClearInterval()</td>
                      <td class="org-left">code<sub>side</sub><sub>in</sub><sub>script.cpp</sub></td>
                    </tr>

                    <tr>
                      <td class="org-left">POSTMESSAGE</td>
                      <td class="org-left">HandlePostMessage</td>
                      <td class="org-left">static void Java<sub>WMLBridge</sub><sub>postMessage</sub>()</td>
                      <td class="org-left">wml<sub>bridge.cpp</sub></td>
                    </tr>

                    <tr>
                      <td class="org-left">DISPATCHMESSAGE</td>
                      <td class="org-left">HandleDispatchMessage</td>
                      <td class="org-left">static void Java<sub>WMLBridge</sub><sub>dispatchMessage</sub>()</td>
                      <td class="org-left">wml<sub>bridge.cpp</sub></td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>

          </section>
          <section id="slide-org48aaabd">
            <h3 id="org48aaabd">Native 渲染流程分析</h3>
            <p>
              <code>WXBridgeManager =&gt; invokeExecJS()</code> 之后通过 <code>WXBridge =&gt; execJS()</code> 调用到了底层的方法：
            </p>
            <div class="org-src-container">

              <pre id="WXBridgeManager.java"><code class="java" >// METHOD_CREATE_INSTANCE = "createInstance"
invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
              </code></pre>
            </div>

            <p>
              之后的流程就是通过 IPC 以消息的方式通知到 JSFramework 环境调用响应的方法。
            </p>

          </section>
        </section>
        <section>
          <section id="slide-org8da878b">
            <h2 id="org8da878b">JSFramework</h2>
            <div class="outline-text-2" id="text-org8da878b">
            </div>
          </section>
          <section id="slide-org643a26c">
            <h3 id="org643a26c">JSFramework</h3>
            <p>
              Weex 通过调用 JS Framework 提供的接口来调用原生功能并且渲染真实 UI.代码层面其实就是 weex 提供的一个 js 库,用来完成 js 调用原生功能的一个组件.
            </p>
          </section>
          <section id="slide-org0b5e61c">
            <h4 id="org0b5e61c">配置 framework</h4>
            <p>
              在 weex 初始化时,通过设置 InitConfig 的 framework 参数,来配置 framework:
            </p>
            <div class="org-src-container">

              <pre id="InitConfig.java"><code class="java" >// 如果不设置,默认为打包在 Android SDK 中的 main.js
InitConfig config=new InitConfig.Builder().setFramework("your framework").build();
              </code></pre>
            </div>
          </section>
          <section id="slide-org7031a7c">
            <h3 id="org7031a7c">JSFramework 初始化</h3>
            <div class="outline-text-3" id="text-org7031a7c">
            </div>
          </section>
          <section id="slide-orge63e6ec">
            <h4 id="orge63e6ec">Android SDK 中的初始化流程</h4>
            <div class="outline-text-4" id="text-orge63e6ec">
            </div>
            <ul class="org-ul">
              <li><a id="org0fce789"></a>WXSDKEngine =&gt; doInitInternal()<br />
                <p>
                  WeexSDK 初始化的时候会在 <code>WXSDKEngine.java</code> 的 ~doInitInternal()~方法中进行 JSFramework 的初始化:
                </p>
                <div class="org-src-container">

                  <pre id="WXSDKEngine.java"><code class="java" >private static void doInitInternal(final Application application,final InitConfig config){
    WXBridgeManager.getInstance().post(new Runnable() {
            @Override
            public void run() {
                WXSDKManager sm = WXSDKManager.getInstance();
                // code init SO libs
                // 调用 WXSDKManager 的 initScriptsFramework()方法
                sm.initScriptsFramework(config!=null?config.getFramework():null);
            }
        });
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org9d56236"></a>-&gt; WXSDKManager =&gt; initScriptsFramework()<br />
                <p>
                  WXSDKManager 的 <code>initScriptsFramework()</code> 方法调用了 <code>WXBridgeManager</code> 的 ~initScriptsFramework()~方法.
                </p>

          </section>
          <section >
              </li>
              <li><a id="org0415f66"></a>-&gt; WXBridgeManager =&gt; initScriptsFramework()<br />
                <p>
                  将初始化 JSFramework 的工作交给 JSHandler 来处理, 调用了 <code>WXBridgeManager =&gt; invokeInitFramework(Message)</code> 方法:
                </p>
                <div class="org-src-container">

                  <pre id="WXBridgeManager.java"><code class="java" >public synchronized void initScriptsFramework(String framework) {
    Message msg = mJSHandler.obtainMessage();
    msg.obj = framework;
    msg.what = WXJSBridgeMsgType.INIT_FRAMEWORK;
    msg.setTarget(mJSHandler);
    msg.sendToTarget();
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org1982a41"></a>-&gt; WXBridgeManager =&gt; invokeInitFramework()<br />
                <p>
                  简单检查了下参数和内存情况, 内存允许(可用内容大于 120MB)的情况下, 去初始化 JSFramework, 否则是在渲染页面的时候再去初始化 JSFramework
                </p>
                <div class="org-src-container">

                  <pre><code class="java" >private void invokeInitFramework(Message msg) {
    String framework = "";
    if (msg.obj != null) {
        framework = (String) msg.obj;
    }

    // LOW_MEM_VALUE = 120(单位是 MB)
    if (WXUtils.getAvailMemory(WXEnvironment.getApplication()) > LOW_MEM_VALUE) {
        initFramework(framework);
    }
}
                  </code></pre>
                </div>

                <p>
                  顺便围观下怎么取可用内存:
                </p>
                <div class="org-src-container">

                  <pre id="WXUtils.java"><code class="java" >public static long getAvailMemory(Context context){
    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
    am.getMemoryInfo(mi);
    //mi.availMem; 当前系统的可用内存
    //return Formatter.formatFileSize(context, mi.availMem);// 将获取的内存大小规格化
    WXLogUtils.w("app AvailMemory ---->>>"+mi.availMem/(1024*1024));
    return mi.availMem/(1024*1024);
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="orgb542c15"></a>-&gt; WXBridgeManager =&gt; initFramework()<br />
                <div class="org-src-container">

                  <pre id="WXBridgeManager.java"><code class="java" >private void initFramework(String framework) {
    if (WXSDKEngine.isSoInitialized() && !isJSFrameworkInit()) {
        // other code
        if (TextUtils.isEmpty(framework)) {
            IWXJsFileLoaderAdapter wxJsFileLoaderAdapter = WXSDKEngine.getIWXJsFileLoaderAdapter();
            if (!isSandBoxContext) {
                // adapter
                if(TextUtils.isEmpty(framework)) {
                    framework = WXFileUtils.loadAsset("main.js", WXEnvironment.getApplication());
                }
            } else {
                // adapter
                if(TextUtils.isEmpty(framework)) {
                    framework = WXFileUtils.loadAsset("weex-main-jsfm.js", WXEnvironment.getApplication());
                }
            }
        }
        // check framework
        try {
            // 监听 code
            boolean pieSupport = true;
            try {
                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
                    pieSupport = false;
                }
            } catch (Exception e) {
            }
            // extends initFramework
            if (mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport) == INIT_FRAMEWORK_OK) {
                // 日志+监听
                execRegisterFailTask();
                WXEnvironment.JsFrameworkInit = true;
                registerDomModule();
            } else {
                // 错误日志
            }
        } catch (Throwable e) {
            // 错误日志
        }

    }
}
                  </code></pre>
                </div>
              </li>
            </ul>
          </section>
          <section id="slide-orgace996f">
            <h4 id="orgace996f">Android WeexCore 中的处理</h4>
            <div class="outline-text-4" id="text-orgace996f">
            </div>
            <ul class="org-ul">
              <li><a id="org6fead9d"></a>JNI =&gt; initFrameworkEnv<br />
                <p>
                  <code>mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport)</code> 实际调用的是 native 层的代码.
                  先来看下它对应的 JNI 的接口声明：
                </p>
                <div class="org-src-container">

                  <pre id="WXBridge_jni.h"><code class="c++" >static const JNINativeMethod kMethodsWXBridge[] =
  {
  // 对应 private native int nativeInitFrameworkEnv(String framework, WXParams params, String cacheDir, boolean pieSupport);
  // Z 对应 Java 中的 boolean
   { "nativeInitFrameworkEnv",
     "("
     "Ljava/lang/String;"
     "Lcom/taobao/weex/bridge/WXParams;"
     "Ljava/lang/String;"
     "Z"
     ")"
     "I", reinterpret_cast<void*>(InitFrameworkEnv) }
                    // other native methods...
                    }
                  </code></pre>
                </div>

          </section>
          <section >
            <p>
              跟直接用包名声明的方式不用, 这里使用了 <code>JNIEnv =&gt; RegisterNatives()</code> 方式来绑定调用关系.
              <code>reinterpret_cast&lt;void*&gt;(InitFrameworkEnv)</code> 指定了 Native 实现的方法名: InitFrameworkEnv
            </p>
            <div class="org-src-container">

              <pre id="wx_bridge.cpp"><code class="c++" >// framework
// cacheDir 为 App 的 CacheDir
// pirSupport 默认为 true (SDK < JELLY_BEAN)
static jint InitFrameworkEnv(JNIEnv* env, jobject jcaller, jstring framework,
                             jobject params, jstring cacheDir,
                             jboolean pieSupport) {
  const char* cache = env->GetStringUTFChars(cacheDir, nullptr);
  if (strlen(cache) > 0) {
    SoUtils::set_cache_dir(const_cast<char*>(cache));
                }
                SoUtils::set_pie_support(pieSupport);
                jint ret = InitFramework(env, jcaller, framework, params);
                env->ReleaseStringUTFChars(cacheDir, cache);
                return ret;
                }
              </code></pre>
            </div>

          </section>
          <section >
            <p>
              <code>InitFramework()</code> 方法:
            </p>
            <div class="org-src-container">

              <pre id="wx_bridge.cpp"><code class="c++" >static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
  WXBridge::Instance()->Reset(env, object);
  // Init platform thread --- ScriptThread
  WeexCoreManager::Instance()->InitScriptThread();
  // Exception handler for so
  SoUtils::RegisterExceptionHanler([](const char* status_code, const char* error_msg)
                                   {
                                     WeexCoreManager::Instance()
                                       ->getPlatformBridge()
                                       ->platform_side()
                                       ->ReportNativeInitStatus(status_code, error_msg);
                                   });
  // Init platform bridge
  PlatformBridge* bridge = new AndroidBridgeInSimple;
  WeexCoreManager::Instance()->set_platform_bridge(bridge);
  // Init params
  std::vector<INIT_FRAMEWORK_PARAMS*> params_vector =
                initFromParam(env, params, [](const char* status_code, const char* error_msg)
                {
                WeexCoreManager::Instance()
                ->getPlatformBridge()
                ->platform_side()
                ->ReportNativeInitStatus(status_code, error_msg);
                });
                // If parse init params error, return false
                if (params_vector.empty()) return false;
                // Set project mode

                WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_PROCESS);
                WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);

                // It means initialization failed when any bridge is not passable
                if (!WeexCoreManager::Instance()->getPlatformBridge()->is_passable() ||
                !WeexCoreManager::Instance()->script_bridge()->is_passable()) {

                if(isSingleProcess()) {
                WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_SO);
                WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiSo);

                if (!WeexCoreManager::Instance()->getPlatformBridge()->is_passable() ||
                !WeexCoreManager::Instance()->script_bridge()->is_passable()) {
                return false;
                }
                }
                }

                // for environment
                bridge->core_side()->SetPlatform(WXCoreEnvironment::getInstance()->platform());
                bridge->core_side()->SetDeviceWidthAndHeight(WXCoreEnvironment::getInstance()->DeviceWidth(), WXCoreEnvironment::getInstance()->DeviceHeight());
                auto options = WXCoreEnvironment::getInstance()->options();
                auto it = options.begin();
                for (; it != options.end(); it++) {
                bridge->core_side()->AddOption(it->first, it->second);
                }
                // Set measure function
                WeexCoreManager::Instance()->set_measure_function_adapter(new MeasureFunctionAdapterImplAndroid());
                bridge->core_side()->SetMeasureFunctionAdapter();
                ScopedJStringUTF8 c_script(env, script);
                // Call InitFramework
                auto result =
                bridge->core_side()->InitFramework(c_script.getChars(), params_vector);
                freeParams(params_vector);
                return result;
                }
              </code></pre>
            </div>
          </section>
          <section >
              </li>
              <li><a id="org6e7f6ee"></a>-&gt; CoreSideInPlatform =&gt; InitFramework()<br />
                <div class="org-src-container">

                  <pre id="core_side_in_platform.cpp"><code class="c++" >int CoreSideInPlatform::InitFramework(const char *script, std::vector<INIT_FRAMEWORK_PARAMS *> &params) {
                    return WeexCoreManager::Instance()
                    ->script_bridge()
                    ->script_side()
                    ->InitFramework(script, params);
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="orgbcddb63"></a>-&gt; ScriptSideInMultiProcess =&gt; InitFramework()<br />
                <div class="org-src-container">

                  <pre id="script_side_in_multi_process.cpp"><code class="c++" >
int ScriptSideInMultiProcess::InitFramework(const char *script, std::vector<INIT_FRAMEWORK_PARAMS *> &params) {
                    try {
                    // check sender != null
                    std::unique_ptr<IPCSerializer> serializer(createIPCSerializer());
                    serializer->setMsg(static_cast<uint32_t>(IPCJSMsg::INITFRAMEWORK));
                    serializer->add(script, strlen(script));
                    for (auto it = params.begin(); it != params.end(); ++it) {
                    serializer->add((*it)->type->content, (*it)->type->length);
                    serializer->add((*it)->value->content, (*it)->value->length);
                    }
                    std::unique_ptr<IPCBuffer> buffer = serializer->finish();
                    std::unique_ptr<IPCResult> result = sender_->send(buffer.get());
                    if (result->getType() != IPCType::INT32) {
                    LOGE("initFramework Unexpected result type");
                    bridge()->core_side()->ReportException("", "initFramework", "error, initFramework Unexpected result type");
                    return false;
                    }
                    } catch (IPCException &e) {
                    LOGE("%s", e.msg());
                    return false;
                    }
                    return true;
                    }
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="orgef6b1dc"></a>-&gt; weex<sub>js</sub><sub>engine</sub> =&gt; initFramework()&#xa0;&#xa0;&#xa0;<span class="tag"><span class="confirm">confirm</span></span><br />
                <p>
                  IPC 接收 <code>IPCJSMsg::INITFRAMEWORK</code> 方法没有在项目中暴露出来，查看 weex<sub>js</sub><sub>engine</sub> 中有这么一个实现方法,　在这个方法中实际加载了 main.js 文件：
                </p>
                <div class="org-src-container">

                  <pre id="com_taobao_weex_bridge_WXBridge.cpp"><code class="c++" >jint Java_com_taobao_weex_bridge_WXBridge_initFramework(JNIEnv *env,
                                                        jobject object, jstring script,
                                                        jobject params) {
  // 配置 WXEnvironment
  WXEnvironment->Set(c_key, jString2V8String(env, jvalue));
  // 创建 V8Context
  V8context = CreateShellContext();
  const char *scriptStr = env->GetStringUTFChars(script, NULL);
  // 执行 script 脚本内容
  if (scriptStr == NULL || !ExecuteJavaScript(globalIsolate, v8::String::New(scriptStr), true)) {
    return false;
  }
  setJSFVersion(env);
  env->ReleaseStringUTFChars(script, scriptStr);
  env->DeleteLocalRef(c_params);
  return true;
}
                  </code></pre>
                </div>
              </li>
            </ul>
          </section>
          <section id="slide-orge261026">
            <h3 id="orge261026">JSFramework 处理 Native 的调用</h3>
            <div class="outline-text-3" id="text-orge261026">
            </div>
            <ul class="org-ul">
              <li><a id="org6eec4c0"></a>Methods<br />
                <p>
                  列了下 <code>WXBridgeManager.java</code> 中声明的一些 call JS 的方法:
                </p>
                <div class="org-src-container">

                  <pre id="Native Call JS Function"><code class="org" >| Methods                   |
|---------------------------|
| createInstance            |
| destroyInstance           |
| callJS                    |
| setTimeoutCallback        |
| registerModules           |
| registerComponents        |
| fireEvent                 |
| fireEventSync             |
| componentHook             |
| callback                  |
| refreshInstance           |
| fireEventOnDataRenderNode |
| notifyTrimMemory          |
| notifySerializeCodeCache  |
| createInstanceContext     |
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org853d983"></a>注册 Component<br />
                <div class="org-src-container">

                  <pre id="runtime/api/component.js"><code class="javascript" >/**
 * Register native components information.
 * @param {array} newComponents
 */
export function registerComponents (newComponents) {
  if (Array.isArray(newComponents)) {
    newComponents.forEach(component => {
      if (!component) {
        return
      }
      if (typeof component === 'string') {
        weexComponents[component] = true
      }
      else if (typeof component === 'object' && typeof component.type === 'string') {
        weexComponents[component.type] = component
        registerElement(component.type, component.methods)
      }
    })
  }
}
                  </code></pre>
                </div>

          </section>
          <section >
              </li>
              <li><a id="org2a119e4"></a>注册 Module<br />
                <div class="org-src-container">

                  <pre id="runtime/api/module.js"><code class="javascript" >/**
 * Register native modules information.
 * @param {object} newModules
 */
export function registerModules (newModules) {
  for (const name in newModules) {
    if (!weexModules[name]) {
      weexModules[name] = {}
    }
    newModules[name].forEach(method => {
      if (typeof method === 'string') {
        weexModules[name][method] = true
      }
      else {
        weexModules[name][method.name] = method.args
      }
    })
  }
}
                  </code></pre>
                </div>
          </section>
          <section >
              </li>
              <li><a id="org4bef760"></a>Weex 页面渲染过程分析<br />
                <ul class="org-ul">
                  <li><a id="org1dd5ee8"></a>Native =&gt; render("weex<sub>page.js</sub>")<br />
                    <p>
                      <code>WXSDKInstance =&gt; render()</code> 来渲染一个 weex 页面:
                    </p>
                    <div class="org-src-container">

                      <pre id="Weex render demo"><code class="java" >/**
 * WXSample 可以替换成自定义的字符串，针对埋点有效。
 * template 是.we transform 后的 js 文件。
 * option 可以为空，或者通过 option 传入 js 需要的参数。例如 bundle js 的地址等。
 * jsonInitData 可以为空。
 * width 为-1 默认全屏，可以自己定制。
 * height =-1 默认全屏，可以自己定制。
 */
mWXSDKInstance.render("WXSample", WXFileUtils.loadFileContent("hello.js", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC);
                      </code></pre>
                    </div>
                    <p>
                      内部其实时把这个 render 调用转成了 IPC 消息的方式来调用到 JSFramework 中的 <code>createInstance()</code> 方法,这里的具体步骤文档中有提到,就不详细展开了.
                    </p>

          </section>
          <section >
                  </li>
                  <li><a id="org6e9cea9"></a>-&gt; JSFramework =&gt; createInstance()<br />
                    <div class="org-src-container">

                      <pre id="runtime/api/init.js"><code class="javascript" >function createInstance (id, code, config, data) {
  // 忽略各种检查和配置参数的代码
  const instanceContext = createInstanceContext(id, config, data)
  if (typeof framework.createInstance === 'function') {
    // Temporary compatible with some legacy APIs in Rax,
    // some Rax page is using the legacy ".we" framework.
    if (bundleType === 'Rax' || bundleType === 'Weex') {
      const raxInstanceContext = Object.assign({
        config,
        created: Date.now(),
        framework: bundleType
      }, instanceContext)
      return framework.createInstance(id, code, config, data, raxInstanceContext)
    }
    return framework.createInstance(id, code, config, data, instanceContext)
  }
  // console.error(`[JS Framework] Can't find available "createInstance" method in ${bundleType}!`)
  runInContext(code, instanceContext)
}
                      </code></pre>
                    </div>

          </section>
          <section >
                  </li>
                  <li><a id="org60c4353"></a>-&gt; JS =&gt; createInstanceContext()<br />
                    <div class="org-src-container">

                      <pre id="runtime/api/init.js"><code class="javascript" >function createInstanceContext (id, options = {}, data) {
  const weex = new WeexInstance(id, options)
  const bundleType = options.bundleType || 'Vue'
  instanceTypeMap[id] = bundleType
  const framework = runtimeConfig.frameworks[bundleType]
  if (!framework) {
    return new Error(`[JS Framework] Invalid bundle type "${bundleType}".`)
  }

  // prepare js service
  const services = createServices(id, {
    weex,
    config: options,
    created: Date.now(),
    framework: bundleType,
    bundleType
  }, runtimeConfig)
  Object.freeze(services)

  // prepare runtime context
  const runtimeContext = Object.create(null)
  Object.assign(runtimeContext, services, {
    weex,
    getJSFMVersion,
    requireModule: (...args) => weex.requireModule(...args),
    __WEEX_CALL_JAVASCRIPT__: receiveTasks,
    services // Temporary compatible with some legacy APIs in Rax
  })
  Object.freeze(runtimeContext)

  // prepare instance context
  const instanceContext = Object.assign({}, runtimeContext)
  // 检查 framework 中有没有 createInstanceContext 方法,有的话就调用,没有的话就用 runtimeContext
  if (typeof framework.createInstanceContext === 'function') {
    Object.assign(instanceContext, framework.createInstanceContext(id, runtimeContext, data))
  }
  Object.freeze(instanceContext)
  return instanceContext
}
                      </code></pre>
                    </div>

          </section>
          <section >
                  </li>
                  <li><a id="orgf02582f"></a>-&gt; framework(legacy) =&gt; createInstance()<br />
                    <div class="org-src-container">

                      <pre id="runtime/api/frameworks/legacy/static/create.js"><code class="javascript" >/**
 * Create a Weex instance.
 *
 * @param  {string} id
 * @param  {string} code
 * @param  {object} options
 *         option `HAS_LOG` enable print log
 * @param  {object} data
 * @param  {object} info { created, ... services }
 */
export function createInstance (id, code, options, data, info) {
  const { services } = info || {}
  resetTarget()
  let instance = instanceMap[id]
  /* istanbul ignore else */
  options = options || {}
  let result
  /* istanbul ignore else */
  if (!instance) {
    instance = new App(id, options)
    instanceMap[id] = instance
    result = initApp(instance, code, data, services)
  }
  else {
    result = new Error(`invalid instance id "${id}"`)
  }
  return (result instanceof Error) ? result : instance
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org2b265e4"></a>-&gt; initApp()<br />
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/app/ctrl/init.js"><code class="javascript" >export function init (app, code, data, services) {
  console.debug('[JS Framework] Intialize an instance with:\n', data)
  let result

  // prepare app env methods
  const bundleDefine = (...args) => defineFn(app, ...args)
  const bundleBootstrap = (name, config, _data) => {
    result = bootstrap(app, name, config, _data || data)
    // misc.js => updateActions()
    updateActions(app)
    // 会调用 callCreateFinish 方法
    app.doc.listener.createFinish()
    console.debug(`[JS Framework] After intialized an instance(${app.id})`)
  }
  const bundleVm = Vm
  /* istanbul ignore next */
  const bundleRegister = (...args) => register(app, ...args)
  /* istanbul ignore next */
  const bundleRender = (name, _data) => {
    result = bootstrap(app, name, {}, _data)
  }
  /* istanbul ignore next */
  const bundleRequire = name => _data => {
    result = bootstrap(app, name, {}, _data)
  }
  const bundleDocument = app.doc
  /* istanbul ignore next */
  const bundleRequireModule = name => app.requireModule(removeWeexPrefix(name))

  const weexGlobalObject = {
    config: app.options,
    define: bundleDefine,
    bootstrap: bundleBootstrap,
    requireModule: bundleRequireModule,
    document: bundleDocument,
    Vm: bundleVm
  }

  Object.freeze(weexGlobalObject)

  // prepare code
  let functionBody
  /* istanbul ignore if */
  if (typeof code === 'function') {
    // `function () {...}` -> `{...}`
    // not very strict
    functionBody = code.toString().substr(12)
  }
  /* istanbul ignore next */
  else if (code) {
    functionBody = code.toString()
  }
  // wrap IFFE and use strict mode
  functionBody = `(function(global){\n\n"use strict";\n\n ${functionBody} \n\n})(Object.create(this))`

  // run code and get result
  const { WXEnvironment } = global
  const timerAPIs = {}

  /* istanbul ignore if */
  if (WXEnvironment && WXEnvironment.platform !== 'Web') {
    // timer APIs polyfill in native
    const timer = app.requireModule('timer')
    Object.assign(timerAPIs, {
      setTimeout: (...args) => {
        const handler = function () {
          args[0](...args.slice(2))
        }
        timer.setTimeout(handler, args[1])
        return app.doc.taskCenter.callbackManager.lastCallbackId.toString()
      },
      setInterval: (...args) => {
        const handler = function () {
          args[0](...args.slice(2))
        }
        timer.setInterval(handler, args[1])
        return app.doc.taskCenter.callbackManager.lastCallbackId.toString()
      },
      clearTimeout: (n) => {
        timer.clearTimeout(n)
      },
      clearInterval: (n) => {
        timer.clearInterval(n)
      }
    })
  }
  // run code and get result
  const globalObjects = Object.assign({
    define: bundleDefine,
    require: bundleRequire,
    bootstrap: bundleBootstrap,
    register: bundleRegister,
    render: bundleRender,
    __weex_define__: bundleDefine, // alias for define
    __weex_bootstrap__: bundleBootstrap, // alias for bootstrap
    __weex_document__: bundleDocument,
    __weex_require__: bundleRequireModule,
    __weex_viewmodel__: bundleVm,
    weex: weexGlobalObject
  }, timerAPIs, services)
  if (!callFunctionNative(globalObjects, functionBody)) {
    // If failed to compile functionBody on native side,
    // fallback to callFunction.
    callFunction(globalObjects, functionBody)
  }

  return result
}
                      </code></pre>
                    </div>

          </section>
          <section >
                  </li>
                  <li><a id="orgd976a74"></a>-&gt; runInContext()<br />
                    <div class="org-src-container">

                      <pre id="runtime/api/init.js"><code class="javascript" >/**
 * Run js code in a specific context.
 * @param {string} code
 * @param {object} context
 */
function runInContext (code, context) {
  const keys = []
  const args = []
  for (const key in context) {
    keys.push(key)
    args.push(context[key])
  }

  const bundle = `
    (function (global) {
      ${code}
    })(Object.create(this))
  `
  return (new Function(...keys, bundle))(...args)
}
                      </code></pre>
                    </div>

          </section>
          <section >
                  </li>
                  <li><a id="org8c5811a"></a>-&gt; 打包生成的 JS 文件<br />
                    <p>
                      根据 <code>runInContext()</code> 方法中的 JS 代码生成规则，最终生成的 JavaScript Function 对象如下：
                    </p>
                    <div class="org-src-container">

                      <pre><code class="javascript" >(function (global) {
  (function (modules) { // webpackBootstrap
    // 省略代码
    return __webpack_require__(__webpack_require__.s = 3);
  })
  ([
    (function (module, exports, __webpack_require__) {
      // 省略代码
      // module.exports
    }),
    (function (module, exports) {
      //省略代码
      //module.exports
    }),
    ,
    (function (module, exports, __webpack_require__) {
      //省略代码
      //module.exports
    }),
    (function (module, exports, __webpack_require__) {
      //省略代码
      //module.exports
    }), (function (module, exports) {
      //省略代码
      //module.exports
    }), (function (module, exports, __webpack_require__) {
      //省略代码
      //module.exports
    }), (function (module, exports) {
      //省略代码
      //module.exports
    })
  ]);
})(Object.create(this));
                      </code></pre>
                    </div>

          </section>
          <section >
                  </li>
                  <li><a id="org5ef088c"></a>-&gt; 加载实际页面<br />
                    <p>
                      开发中创建一个 text 标签：
                    </p>
                    <div class="org-src-container">

                      <pre id="weex page"><code class="javascript" ><template>
                        <text class="message">Now, let's use Vue.js to build your Weex app.</text>
                      </template>
                      </code></pre>
                    </div>

                    <p>
                      实际打包生产的代码，提前剧透，这里每次执行的 <code>_c()</code> 方法，其实就是 compile.js 中的 <code>compile (vm, target, dest, meta)</code> 方法，具体的可以继续往下看。
                    </p>
                    <div class="org-src-container">

                      <pre><code class="javascript" >
/* 1 */
(function(module, exports) {
  module.exports={render:function (){
    var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
    return _c('text', {
      staticClass: ["message"]
    }, [_vm._v("Now, let's use Vue.js to build your Weex app.")])
  },staticRenderFns: []}
  module.exports.render._withStripped = true

  /***/ })
                      </code></pre>
                    </div>

                    <p>
                      那么问题来了，Weex 是如何加载打包之后的 JS 文件，并解析成 Weex 页面的呢？
                    </p>
          </section>
          <section >
                  </li>
                  <li><a id="org78266d0"></a>-&gt; Vm 构造方法<br />
                    <p>
                      关键方法： <code>build(this);</code> 完成了对生成的 JS 对象的解析，这里的 <code>build()</code> 方法，对应了 compile.js 中的 <code>build()</code> 方法。
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/index.js"><code class="javascript" >export default function Vm (
  type,
  options,
  parentVm,
  parentEl,
  mergedData,
  externalEvents
) {
  parentVm = parentVm || {}
  this._parent = parentVm._realParent ? parentVm._realParent : parentVm
  this._app = parentVm._app || {}
  parentVm._childrenVms && parentVm._childrenVms.push(this)

  if (!options && this._app.customComponentMap) {
    options = this._app.customComponentMap[type]
  }
  options = options || {}

  const data = options.data || {}

  this._options = options
  this._methods = options.methods || {}
  this._computed = options.computed || {}
  this._css = options.style || {}
  this._ids = {}
  this._vmEvents = {}
  this._childrenVms = []
  this._type = type

  // bind events and lifecycles
  initEvents(this, externalEvents)

  console.debug(`[JS Framework] "init" lifecycle in Vm(${this._type})`)
  this.$emit('hook:init')
  this._inited = true

  // proxy data and methods
  // observe data and add this to vms
  this._data = typeof data === 'function' ? data() : data
  if (mergedData) {
    extend(this._data, mergedData)
  }
  initState(this)

  console.debug(`[JS Framework] "created" lifecycle in Vm(${this._type})`)
  this.$emit('hook:created')
  this._created = true

  // backward old ready entry
  if (options.methods && options.methods.ready) {
    console.warn('"exports.methods.ready" is deprecated, ' +
                 'please use "exports.created" instead')
    options.methods.ready.call(this)
  }

  if (!this._app.doc) {
    return
  }

  // if no parentElement then specify the documentElement
  this._parentEl = parentEl || this._app.doc.documentElement
  build(this)
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="orgcbe5abf"></a>-&gt; Compile =&gt; build()<br />
                    <p>
                      具体解析的 JS 文件的方法，关键的方法是 <code>compile()</code>
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/compile.js"><code class="javascript" >/**
 * build()
 *   compile(template, parentNode)
 *     if (type is content) create contentNode
 *     else if (dirs have v-for) foreach -> create context
 *       -> compile(templateWithoutFor, parentNode): diff(list) onchange
 *     else if (dirs have v-if) assert
 *       -> compile(templateWithoutIf, parentNode): toggle(shown) onchange
 *     else if (type is dynamic)
 *       -> compile(templateWithoutDynamicType, parentNode): watch(type) onchange
 *     else if (type is custom)
 *       addChildVm(vm, parentVm)
 *       build(externalDirs)
 *       foreach childNodes -> compile(childNode, template)
 *     else if (type is native)
 *       set(dirs): update(id/attr/style/class) onchange
 *       append(template, parentNode)
 *       foreach childNodes -> compile(childNode, template)
 */
export function build (vm) {
  const opt = vm._options || {}
  const template = opt.template || {}

  if (opt.replace) {
    if (template.children && template.children.length === 1) {
      compile(vm, template.children[0], vm._parentEl)
    }
    else {
      compile(vm, template.children, vm._parentEl)
    }
  }
  else {
    compile(vm, template, vm._parentEl)
  }

  console.debug(`[JS Framework] "ready" lifecycle in Vm(${vm._type})`)
  vm.$emit('hook:ready')
  vm._ready = true
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org6af24f9"></a>-&gt; Compile =&gt; compile()<br />
                    <p>
                      <code>compile()</code> 方法中，对传入的参数进行解析，并调用渲染的环节:
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/compile.js"><code class="javascript" >/**
 * Generate elements by child or children and append to parent elements.
 * Root element info would be merged if has. The first argument may be an array
 * if the root element with options.replace has not only one child.
 *
 * @param {object|array} target
 * @param {object}       dest
 * @param {object}       meta
 */
function compile (vm, target, dest, meta) {
  const app = vm._app || {}

  if (app.lastSignal === -1) {
    return
  }

  if (target.attr && target.attr.hasOwnProperty('static')) {
    vm._static = true
  }

  if (targetIsFragment(target)) {
    compileFragment(vm, target, dest, meta)
    return
  }
  meta = meta || {}
  if (targetIsContent(target)) {
    console.debug('[JS Framework] compile "content" block by', target)
    vm._content = createBlock(vm, dest)
    return
  }

  if (targetNeedCheckRepeat(target, meta)) {
    console.debug('[JS Framework] compile "repeat" logic by', target)
    if (dest.type === 'document') {
      console.warn('[JS Framework] The root element does\'t support `repeat` directive!')
    }
    else {
      compileRepeat(vm, target, dest)
    }
    return
  }
  if (targetNeedCheckShown(target, meta)) {
    console.debug('[JS Framework] compile "if" logic by', target)
    if (dest.type === 'document') {
      console.warn('[JS Framework] The root element does\'t support `if` directive!')
    }
    else {
      compileShown(vm, target, dest, meta)
    }
    return
  }
  const typeGetter = meta.type || target.type
  if (targetNeedCheckType(typeGetter, meta)) {
    compileType(vm, target, dest, typeGetter, meta)
    return
  }
  const type = typeGetter
  const component = targetIsComposed(vm, target, type)
  if (component) {
    console.debug('[JS Framework] compile composed component by', target)
    compileCustomComponent(vm, component, target, dest, type, meta)
    return
  }
  console.debug('[JS Framework] compile native component by', target)
  compileNativeComponent(vm, target, dest, type)
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="orgb6a67cc"></a>-&gt; Compile =&gt; compileNativeComponent()<br />
                    <p>
                      对于 UI 组件的渲染，都会走到这个方法中，可以看到，在这个方法里面调用了 <code>createElement()</code> 方法，就是通过它来创建一个组件对象。创建完成之后，通过 <code>dom-helper =&gt; attachTarget()</code> 方法把生成的 Element 添加到页面上（）。
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/compile.js"><code class="javascript" >/**
 * Generate element from template and attach to the dest if needed.
 * The time to attach depends on whether the mode status is node or tree.
 *
 * @param {object} template
 * @param {object} dest
 * @param {string} type
 */
function compileNativeComponent (vm, template, dest, type) {
  applyNaitveComponentOptions(template)

  let element
  if (dest.ref === '_documentElement') {
    // if its parent is documentElement then it's a body
    console.debug(`[JS Framework] compile to create body for ${type}`)
    element = createBody(vm, type)
  }
  else {
    console.debug(`[JS Framework] compile to create element for ${type}`)
    //就是在这里创建的每个组件对象
    element = createElement(vm, type)
  }

  if (!vm._rootEl) {
    vm._rootEl = element
    // bind event earlier because of lifecycle issues
    const binding = vm._externalBinding || {}
    const target = binding.template
    const parentVm = binding.parent
    if (target && target.events && parentVm && element) {
      for (const type in target.events) {
        const handler = parentVm[target.events[type]]
        if (handler) {
          element.addEvent(type, bind(handler, parentVm))
        }
      }
    }
  }

  bindElement(vm, element, template)

  if (template.attr && template.attr.append) { // backward, append prop in attr
    template.append = template.attr.append
  }

  if (template.append) { // give the append attribute for ios adaptation
    element.attr = element.attr || {}
    element.attr.append = template.append
  }

  const treeMode = template.append === 'tree'
  const app = vm._app || {}
  if (app.lastSignal !== -1 && !treeMode) {
    console.debug('[JS Framework] compile to append single node for', element)
    app.lastSignal = attachTarget(vm, element, dest)
  }
  if (app.lastSignal !== -1) {
    compileChildren(vm, template, element)
  }
  if (app.lastSignal !== -1 && treeMode) {
    console.debug('[JS Framework] compile to append whole tree for', element)
    app.lastSignal = attachTarget(vm, element, dest)
  }
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org264e677"></a>-&gt; DomHelper =&gt; createElement()<br />
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/dom-helper.js"><code class="javascript" >/**
 * Create an element by type
 * Using this._app.doc
 *
 * @param  {string} type
 */
export function createElement (vm, type) {
  // 这个_app 是个啥？剧透下把，是 framework 提供的 App 对象
  const doc = vm._app.doc
  return doc.createElement(type)
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org24f25a3"></a>-&gt; App =&gt; doc<br />
                    <p>
                      可以看到 App 的 doc 属性来来自于 <code>new renderer.Document()</code> 方法:
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/app/instance.js"><code class="javascript" >import renderer from '../config' // renderer 的声明在 config.js 中
/**
 * App constructor for Weex framework.
 * @param {string} id
 * @param {object} options
 */
export default function App (id, options) {
  this.id = id
  this.options = options || {}
  this.vm = null
  this.customComponentMap = {}
  this.commonModules = {}

  // document
  this.doc = new renderer.Document(
    id,
    this.options.bundleUrl,
    null,
    renderer.Listener
  )
  this.differ = new Differ(id)
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="orgdb58aeb"></a>-&gt; Document =&gt; createElement()<br />
                    <p>
                      这里调用的 <code>new Element()</code> 方法最终调用了 <code>new WeexElement()</code>
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/vdom/Document.js"><code class="javascript" >/**
 * Create an element.
 * @param {string} tagName
 * @param {objct} props
 * @return {object} element
 */
createElement (tagName, props) {
  const el = new Element(tagName, props)
  if (checkLevel('debug')) {
    debugLog(`[createElement](${this.id},${el.type},${el.ref}) `
             + `(${JSON.stringify(el.toJSON(true))}).`)
  }
  return el
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org1a0b2c3"></a>-&gt; DomHelper =&gt;attachTarget()<br />
                    <p>
                      <code>attachTarget()</code> 中调用的 <code>Element =&gt; insertBefore()</code> 和 <code>Element =&gt; appendChild()</code> ，在这些方法中通过发送事件的方式来调用原生的方法
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/frameworks/legacy/vm/dom-helper.js"><code class="javascript" >/**
 * Attach target to a certain dest using appendChild by default.
 * If the dest is a frag block then insert before the ender.
 * If the target is a frag block then attach the starter and ender in order.
 *
 * @param  {object} target
 * @param  {object} dest
 */
export function attachTarget (vm, target, dest) {
  if (dest.element) {
    const before = dest.end
    const after = dest.updateMark
    // push new target for watch list update later
    if (dest.children) {
      dest.children.push(target)
    }
    // for check repeat case
    if (after) {
      const signal = moveTarget(vm, target, after)
      dest.updateMark = target.element ? target.end : target
      return signal
    }
    else if (target.element) {
      dest.element.insertBefore(target.start, before)
      dest.element.insertBefore(target.end, before)
    }
    else {
      return dest.element.insertBefore(target, before)
    }
  }
  else {
    if (target.element) {
      dest.appendChild(target.start)
      dest.appendChild(target.end)
    }
    else {
      return dest.appendChild(target)
    }
  }
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="orgf2a5ce6"></a>-&gt; Element =&gt; 发送渲染的消息<br />
                    <p>
                      Element 类的 <code>appendChild()</code> 方法, <code>insertBefore()</code> 和 <code>inserAfter()</code> 这些方法，都会去调用 taskCenter 的发送消息方法
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/vdom/Element.js"><code class="javascript" >// 发送 "addElement" 消息，告诉 JSFramework 需要调用 callNative 方法渲染原生组件
const taskCenter = getTaskCenter(this.docId)
  if (taskCenter) {
    return taskCenter.send(
      'dom',
      { action: 'addElement' },
      [this.ref, node.toJSON(), -1]
    )
  }
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org708a913"></a>-&gt; TaskCenter =&gt; send()<br />
                    <p>
                      DOM 操作的方法会通过消息传递给 JavaScriptCore
                    </p>
                    <div class="org-src-container">

                      <pre id="runtime/bridge/TaskCenter.js"><code class="javascript" >send (type, params, args, options) {
  const { action, component, ref, module, method } = params

  // normalize args and options
  args = args.map(arg => this.normalize(arg))
  if (typof(options) === 'Object') {
    options = this.normalize(options, true)
  }

  switch (type) {
  case 'dom': {
    if (checkLevel('debug')) {
      debugLog(`[task](${this.instanceId},${this.type},${action}) ${JSON.stringify(args)}`)
    }
    return this[action](this.instanceId, args)
  }
  case 'component':
    return this.componentHandler(this.instanceId, ref, method, args, Object.assign({ component }, options))
  default: {
    if (checkLevel('debug')) {
      debugLog(`[task](${this.instanceId},${module},${method}) ${JSON.stringify(args)}`)
    }
    return this.moduleHandler(this.instanceId, module, method, args, options)
  }
  }
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="orgb217d58"></a>-&gt; TaskCenter 中注册的 DOM<sub>METHODS</sub><br />
                    <div class="org-src-container">

                      <pre id="runtime/bridge/TaskCenter.js"><code class="javascript" >const DOM_METHODS = {
  createFinish: global.callCreateFinish,
  updateFinish: global.callUpdateFinish,
  refreshFinish: global.callRefreshFinish,

  createBody: global.callCreateBody,

  addElement: global.callAddElement,
  removeElement: global.callRemoveElement,
  moveElement: global.callMoveElement,
  updateAttrs: global.callUpdateAttrs,
  updateStyle: global.callUpdateStyle,

  addEvent: global.callAddEvent,
  removeEvent: global.callRemoveEvent
}
                      </code></pre>
                    </div>
          </section>
          <section >
                  </li>
                  <li><a id="org74cd7ff"></a>-&gt; JavaScriptCore =&gt; callAddElement()<br />
                    <p>
                      <code>callAddElement()</code> 最终调用了 IPC 消息调用了各自 SDK 中的 callAddElement 方法，使用原生的方式渲染页面
                    </p>
          </section>
          <section >
                  </li>
                </ul>
              </li>
            </ul>
          </section>
        </section>
        <section>
          <section id="slide-orge659e2e">
            <h2 id="orge659e2e">Thank You</h2>
            <p>
              Q&amp;A
            </p>
          </section>
        </section>
      </div>
    </div>
    <script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
    <script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.js"></script>

    <script>
     // Full list of configuration options available here:
     // https://github.com/hakimel/reveal.js#configuration
     Reveal.initialize({

       controls: true,
       progress: true,
       history: false,
       center: true,
       slideNumber: 'c',
       rollingLinks: false,
       keyboard: true,
       overview: true,

       theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
       transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
       transitionSpeed: 'default',
       multiplex: {
         secret: '', // null if client
         id: '', // id, obtained from socket.io server
         url: '' // Location of socket.io server
       },

       // Optional libraries used to extend on reveal.js
       dependencies: [
         { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
     });
    </script>
  </body>
</html>
