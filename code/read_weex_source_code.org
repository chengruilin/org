#+TITLE: Weex 源码分析
#+TODO: TODO(t) DOING(d!) PAUSE(p!) RESUME(r!) | DONE(e)

* TODO Weex Source Code [5/7]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:

** DOING Weex 使用相关
   - State "DOING"      from "TODO"       [2018-10-10 三 17:56]
*** DONE Weex 扩展(Android)
    CLOSED: [2018-10-11 四 11:11]

**** DONE Module
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "TODO"       [2018-10-10 三 17:42]

     Module 扩展非 UI 功能
     1. extends WXModule
     2. @JsMethod(uiThread = false or true)
     3. public function
     4. -keep public class * extends com.taobao.weex.common.WXModule{*;}
     5. 方法参数:int,double,float,String,Map,List
     6. Register: WXSDKEngine.registerModule("myModule", MyModule.class);

     Weex Module Sample:
     #+BEGIN_SRC java
       public class MyModule extends WXModule {

           //run ui thread
           @JSMethod (uiThread = true)
           public void printLog(String msg) {
               Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();
           }

           //run JS thread
           @JSMethod (uiThread = false)
           public void fireEventSyncCall(){
               //implement your module logic here
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <text onclick="click">testMyModule</text>
         </div>
       </template>

       <script>
         module.exports = {
           methods: {
             click: function() {
               weex.requireModule('MyModule').printLog("I am a weex Module");
             }
           }
         }
       </script>
     #+END_SRC

**** DONE Component
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "TODO"       [2018-10-10 三 17:42]

     Component 扩展实现 Native 控件
     1. extends WXComponent
     2. @WXComponentProp(name=value(value is attr or style of dsl))
     3. -keep public class * extends com.taobao.weex.common.WXComponent{*;}
     4. 方法参数:int,double,float,String,Map,List
     5. WXSDKEngine.registerComponent("richText", RichText.class);

     Weex Component Sample:
     #+BEGIN_SRC java
       public class RichText extends WXComponent<TextView> {

           public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) {
               super(instance, dom, parent);
           }

           @Override
           protected TextView initComponentHostView(@NonNull Context context) {
               TextView textView = new TextView(context);
               textView.setTextSize(20);
               textView.setTextColor(Color.BLACK);
               return textView;
           }

           @WXComponentProp(name = "tel")
           public void setTel(String telNumber) {
               getHostView().setText("tel: " + telNumber);
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerComponent("richText", RichText.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <richText tel="12305" style="width:200;height:100">12305</richText>
         </div>
       </template>
     #+END_SRC

**** DONE Adapter
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "DOING"      [2018-10-10 三 17:55]
***** IWXImgLoaderAdapter
      图片加载适配器,使用方法:
      #+BEGIN_SRC java
        public class ImageAdapter implements IWXImgLoaderAdapter {

            public ImageAdapter() {
            }

            @Override
            public void setImage(final String url, final ImageView view,
                                 WXImageQuality quality, WXImageStrategy strategy) {

                WXSDKManager.getInstance().postOnUiThread(new Runnable() {

                        @Override
                        public void run() {
                            if(view==null||view.getLayoutParams()==null){
                                return;
                            }
                            if (TextUtils.isEmpty(url)) {
                                view.setImageBitmap(null);
                                return;
                            }
                            String temp = url;
                            if (url.startsWith("//")) {
                                temp = "http:" + url;
                            }
                            if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {
                                return;
                            }
                            Picasso.with(WXEnvironment.getApplication())
                                .load(temp)
                                .into(view);
                        }
                    },0);
            }
        }
      #+END_SRC
***** IWXHttpAdapter
      网络请求适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXHttpAdapter {
            void sendRequest(WXRequest request, OnHttpListener listener);
        }
      #+END_SRC
***** IWXUserTrackAdapter
      埋点适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXUserTrackAdapter {
            void commit(Context context, String eventId, String type, WXPerformance perf, Map<String, Serializable> params);
        }
      #+END_SRC
***** IActivityNavBarSetter
      Weex 导航适配器,使用方法:
      #+BEGIN_SRC java
      WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){});
      #+END_SRC
***** IWXStorageAdapter
      本地存储适配器,默认 DefaultWXStorage
***** IWXJSExceptionAdapter
      处理 JS 异常,默认忽略
      
*** DONE Lifecycle
    CLOSED: [2018-10-11 四 10:31]
    - State "DOING"      from "TODO"       [2018-10-10 三 18:12]
**** Workflow
     此处图片出处: [[https://github.com/alibaba/weex/issues/331?spm=a2c4e.11153940.blogcont59936.9.75012203aFrbFG][WeexLiftcycle 的讨论]]
     Create Instance:
     [[./weex/imgs/img_weex_lifecycle_create_instance.jpeg]]

     Refresh Instance:
     [[./weex/imgs/img_weex_lifecycle_refresh_instance.jpeg]]

     Fire Event/Callback:
     [[./weex/imgs/img_weex_lifecycle_fire_event.jpeg]]

     Destroy Instance:
     [[./weex/imgs/img_weex_lifecycle_destroy_instance.jpeg]]

     Navigate:
     [[./weex/imgs/img_weex_lifecycle_navigate.jpeg]]

**** 组件生命周期解析

     生命周期图解:
     #+BEGIN_EXAMPLE
      ------      --------      -------             -----------
     | init | -> | create | -> | ready |           | destroyed |
      ------      --------      -------             -----------
     #+END_EXAMPLE

     生命周期用法:
     #+BEGIN_SRC javascript
       <script>
         module.exports = {
           data: {},
           methods: {},

           init: function () {
             console.log('在初始化内部变量，并且添加了事件功能后被触发');
           },
           created: function () {
             console.log('完成数据绑定之后，模板编译之前被触发');
           },
           ready: function () {
             console.log('模板已经编译并且生成了 Virtual DOM 之后被触发');
           },
           destroyed: function () {
             console.log('在页面被销毁时调用');
           }
         }
       </script>
     #+END_SRC

***** init:
      - 初始化内部变量,添加事件功能
      - 没有执行数据绑定,没有创建 Virtual-DOM,所以不能通过 this 获取到 data 中的数据,不能调用到 methods 中定义的方法,也不能获取到 Virtual-DOM 的节点
      - 可以在方法内初始化一些内部变量,绑定一些自定义事件

      created:
      - 刚完成数据绑定,还没开始编译模板
      - 可以通过 this 操作 data 中的数据,可以调用 methods 中的方法,但是不能获取到 Virtual-DOM 的节点
      - 可以在方法中修改 data 中数据,不会触发额外的渲染

***** ready:
      - 表示组件已经渲染完成
      - 首先执行子组件的 ready 方法
      - 可以获得 Virtual-DOM 的节点,也可以获取子组件的 Virtual-DOM 实例
      - 小心操作 data,避免频繁赋值
      - 建议去除需要频繁改动的值,等操作执行结束之后再赋值

      [[./weex/imgs/img_weex_lifecycle_parent_son.png]]

      避免频繁赋值:
      #+BEGIN_SRC javascript
       // 在修改 this.count 前先获取它的值，在执行完操作后再赋值回去，如果在循环体中直接设置 this.count 的值，页面将触发 999 次局部刷新，很可能会导致页面卡顿
       module.exports = {
         data: {
           count: 0
         },
         ready: function () {
           var count = this.count;
           for (var i = 0; i < 999; i++) {
             count += Math.random();
           }
           this.count = count;
         }
       }
      #+END_SRC

***** destroyed
      - 组件销毁时被调用
      - 自底向上执行(先触发子组件的 destroyed 方法,再触发自身的)
      - 先执行开发者定义的 destroyed 方法,再清除内部属性
      - 添加的全局或者 this 的属性,建议在 destroyed 方法中手动清除,避免内存泄露

** TODO 源码分析
