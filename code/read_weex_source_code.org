#+TITLE: Weex 源码分析
#+TODO: TODO(t) DOING(d) PAUSE(p!) RESUME(r!) | DONE(e)
#+STARTUP: overview

* TODO Weex Source Code [13/18]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:

** DONE Weex 使用相关
   CLOSED: [2018-10-22 一 10:57]
*** DONE Weex 扩展(Android)
    CLOSED: [2018-10-11 四 11:11]

**** DONE Module
     CLOSED: [2018-10-10 三 17:56]

     实现源码分析:[[weex_register_module][传送门]]

     Module 扩展非 UI 功能
     1. extends WXModule
     2. @JsMethod(uiThread = false or true)
     3. public function
     4. -keep public class * extends com.taobao.weex.common.WXModule{*;}
     5. 方法参数:int,double,float,String,Map,List
     6. Register: WXSDKEngine.registerModule("myModule", MyModule.class);

     Weex Module Sample:
     #+BEGIN_SRC java
       public class MyModule extends WXModule {

           //run ui thread
           @JSMethod (uiThread = true)
           public void printLog(String msg) {
               Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();
           }

           //run JS thread
           @JSMethod (uiThread = false)
           public void fireEventSyncCall(){
               //implement your module logic here
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <text onclick="click">testMyModule</text>
         </div>
       </template>

       <script>
         module.exports = {
           methods: {
             click: function() {
               weex.requireModule('MyModule').printLog("I am a weex Module");
             }
           }
         }
       </script>
     #+END_SRC

**** DONE Component
     CLOSED: [2018-10-10 三 17:56]

     实现源码分析:[[weex_register_component][传送门]]

     Component 扩展实现 Native 控件
     1. extends WXComponent
     2. @WXComponentProp(name=value(value is attr or style of dsl))
     3. -keep public class * extends com.taobao.weex.common.WXComponent{*;}
     4. 方法参数:int,double,float,String,Map,List
     5. WXSDKEngine.registerComponent("richText", RichText.class);

     Weex Component Sample:
     #+BEGIN_SRC java
       public class RichText extends WXComponent<TextView> {

           public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) {
               super(instance, dom, parent);
           }

           @Override
           protected TextView initComponentHostView(@NonNull Context context) {
               TextView textView = new TextView(context);
               textView.setTextSize(20);
               textView.setTextColor(Color.BLACK);
               return textView;
           }

           @WXComponentProp(name = "tel")
           public void setTel(String telNumber) {
               getHostView().setText("tel: " + telNumber);
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerComponent("richText", RichText.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <richText tel="12305" style="width:200;height:100">12305</richText>
         </div>
       </template>
     #+END_SRC

**** DONE Adapter
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "DOING"      [2018-10-10 三 17:55]
***** IWXImgLoaderAdapter
      图片加载适配器,使用方法:
      #+BEGIN_SRC java
        public class ImageAdapter implements IWXImgLoaderAdapter {

            public ImageAdapter() {
            }

            @Override
            public void setImage(final String url, final ImageView view,
                                 WXImageQuality quality, WXImageStrategy strategy) {

                WXSDKManager.getInstance().postOnUiThread(new Runnable() {

                        @Override
                        public void run() {
                            if(view==null||view.getLayoutParams()==null){
                                return;
                            }
                            if (TextUtils.isEmpty(url)) {
                                view.setImageBitmap(null);
                                return;
                            }
                            String temp = url;
                            if (url.startsWith("//")) {
                                temp = "http:" + url;
                            }
                            if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {
                                return;
                            }
                            Picasso.with(WXEnvironment.getApplication())
                                .load(temp)
                                .into(view);
                        }
                    },0);
            }
        }
      #+END_SRC
***** IWXHttpAdapter
      网络请求适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXHttpAdapter {
            void sendRequest(WXRequest request, OnHttpListener listener);
        }
      #+END_SRC
***** IWXUserTrackAdapter
      埋点适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXUserTrackAdapter {
            void commit(Context context, String eventId, String type, WXPerformance perf, Map<String, Serializable> params);
        }
      #+END_SRC
***** IActivityNavBarSetter
      Weex 导航适配器,使用方法:
      #+BEGIN_SRC java
      WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){});
      #+END_SRC
***** IWXStorageAdapter
      本地存储适配器,默认 DefaultWXStorage
***** IWXJSExceptionAdapter
      处理 JS 异常,默认忽略

*** DONE Lifecycle
    CLOSED: [2018-10-11 四 10:31]
    - State "DOING"      from "TODO"       [2018-10-10 三 18:12]
**** Workflow
     此处图片出处: [[https://github.com/alibaba/weex/issues/331?spm=a2c4e.11153940.blogcont59936.9.75012203aFrbFG][WeexLiftcycle 的讨论]]
     Create Instance:
     [[./weex/imgs/img_weex_lifecycle_create_instance.jpeg]]

     Refresh Instance:
     [[./weex/imgs/img_weex_lifecycle_refresh_instance.jpeg]]

     Fire Event/Callback:
     [[./weex/imgs/img_weex_lifecycle_fire_event.jpeg]]

     Destroy Instance:
     [[./weex/imgs/img_weex_lifecycle_destroy_instance.jpeg]]

     Navigate:
     [[./weex/imgs/img_weex_lifecycle_navigate.jpeg]]

**** 组件生命周期解析

     生命周期图解:
     #+BEGIN_EXAMPLE
      ------      --------      -------             -----------
     | init | -> | create | -> | ready |           | destroyed |
      ------      --------      -------             -----------
     #+END_EXAMPLE

     生命周期用法:
     #+BEGIN_SRC javascript
       <script>
         module.exports = {
           data: {},
           methods: {},

           init: function () {
             console.log('在初始化内部变量，并且添加了事件功能后被触发');
           },
           created: function () {
             console.log('完成数据绑定之后，模板编译之前被触发');
           },
           ready: function () {
             console.log('模板已经编译并且生成了 Virtual DOM 之后被触发');
           },
           destroyed: function () {
             console.log('在页面被销毁时调用');
           }
         }
       </script>
     #+END_SRC

***** init:
      - 初始化内部变量,添加事件功能
      - 没有执行数据绑定,没有创建 Virtual-DOM,所以不能通过 this 获取到 data 中的数据,不能调用到 methods 中定义的方法,也不能获取到 Virtual-DOM 的节点
      - 可以在方法内初始化一些内部变量,绑定一些自定义事件

      created:
      - 刚完成数据绑定,还没开始编译模板
      - 可以通过 this 操作 data 中的数据,可以调用 methods 中的方法,但是不能获取到 Virtual-DOM 的节点
      - 可以在方法中修改 data 中数据,不会触发额外的渲染

***** ready:
      - 表示组件已经渲染完成
      - 首先执行子组件的 ready 方法
      - 可以获得 Virtual-DOM 的节点,也可以获取子组件的 Virtual-DOM 实例
      - 小心操作 data,避免频繁赋值
      - 建议去除需要频繁改动的值,等操作执行结束之后再赋值

      [[./weex/imgs/img_weex_lifecycle_parent_son.png]]

      避免频繁赋值:
      #+BEGIN_SRC javascript
       // 在修改 this.count 前先获取它的值，在执行完操作后再赋值回去，如果在循环体中直接设置 this.count 的值，页面将触发 999 次局部刷新，很可能会导致页面卡顿
       module.exports = {
         data: {
           count: 0
         },
         ready: function () {
           var count = this.count;
           for (var i = 0; i < 999; i++) {
             count += Math.random();
           }
           this.count = count;
         }
       }
      #+END_SRC

***** destroyed
      - 组件销毁时被调用
      - 自底向上执行(先触发子组件的 destroyed 方法,再触发自身的)
      - 先执行开发者定义的 destroyed 方法,再清除内部属性
      - 添加的全局或者 this 的属性,建议在 destroyed 方法中手动清除,避免内存泄露

** DONE 架构分析
   CLOSED: [2018-10-24 三 16:33]
*** 调用流程图
    [[./weex/imgs/img_weex_arch_flow.png]]

*** 框架结构图
    图片出处: https://zhuanlan.zhihu.com/p/25326775
    [[./weex/imgs/img_weex_framework_classes.jpeg]]

*** 线程模型
    <<weex_thread>>

**** Weex 线程间交互关系图
     [[./weex/imgs/img_weex_threads.jpg]]
*** 项目目录结构

    #+NAME: Weex 目录结构(选择性列了一些比较重要的目录)
    #+BEGIN_EXAMPLE
    ./incubator-weex                        # 根目录
    -----------------------------------------------------------------------------------------
        - android/                          # Android SDK 相关目录
            - commons/                      #
            - playground/                   # Android 模板工程
            - sdk/                          # Android Weex SDK
    -----------------------------------------------------------------------------------------
        - ios/                              # iOS SDK 相关
            - playground/                   # iOS 模板工程
            - sdk/                          # iOS Weex SDK
    -----------------------------------------------------------------------------------------
        - packages/                         # 打包好的 JSFramework 库
            - weex-js-framework/            #
            - weex-js-runtime/              #
            - weex-legacy-framework/        #
            - weex-vanilla-framework/       #
    -----------------------------------------------------------------------------------------
        - runtime/                          # JSFramework 源码目录
            - api/                          #
            - bridge/                       #
            - entries/                      #
            - frameworks/                   #
            - services/                     #
            - shared/                       #
            - vdom/                         #
    -----------------------------------------------------------------------------------------
        - script/                           # 一些脚本文件
    -----------------------------------------------------------------------------------------
        - weex_core/Source                  # Weex 底层支持代码(打包成 weexcore.so,SDK 引入)
            - IPC/                          # [Android] IPC 通信层
            - android/                      # [Android] JNI 层
            - base/                         #
            - core/                         #
            - include/                      #
            - third_party/                  #
            - wson/                         # wson 支持
            - CMakeLists.txt                # CMake 打包脚本
    #+END_EXAMPLE

** DOING 源码分析-Android
*** 初始化流程分析
    整个初始化的流程,简单来说就是:
    1. 获取 Application 对象
    2. 读取初始化的 Config 参数
    3. 配置 so 的加载方式，然后加载 weexcore.so 库
    4. 加载打包在本地的 JSFramework 组件，调用 native 的方法初始化 JS 环境
    5. 注册所有内置的 Weex Component 组件和 Module 组件

**** WXSDKEngine -> initialize
     Weex 官方文档中的初始化方法：
     #+BEGIN_SRC java
       public class WXApplication extends Application {
           @Override
           public void onCreate() {
               super.onCreate();
               InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();
               WXSDKEngine.initialize(this,config);
           }
       }
     #+END_SRC

     此处调用了 WXSDKEngine 方法，那么这个方法里面做了什么事情呢，我们来看下：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // com.taobao.weex.WXSDKEngine
       public static void initialize(Application application,InitConfig config){
           synchronized (mLock) {
               if (mIsInit) {
                   return;
               }
               // 此处省略，大概就是记录初始化耗时，设置日志级别什么的
               doInitInternal(application,config);
               registerApplicationOptions(application);
               mIsInit = true;
           }
       }
     #+END_SRC
     这里需要重点关注的就是 doInitInternal 和 registerApplicationOptions 这两个方法。
**** WXSDKEngine -> doInitInternal
     其实主要初始化的工作都是由 doInitInternal 这个方法完成的，我们来看下它的代码：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       private static void doInitInternal(final Application application,final InitConfig config){
           // 获取 Application 对象
           WXEnvironment.sApplication = application;
           // 如果 Application 对象为空，传递异常给到 JS
           if(application == null){
               WXLogUtils.e(TAG, " doInitInternal application is null");
               WXExceptionUtils.commitCriticalExceptionRT(null,
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                          "doInitInternal",
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "WXEnvironment sApplication is null",
                                                          null);
           }
           WXEnvironment.JsFrameworkInit = false;
           // 这里的操作在线程中完成
           WXBridgeManager.getInstance().post(new Runnable() {
                   @Override
                   public void run() {
                       // 又要统计初始化时间什么的，忽略
                       WXSDKManager sm = WXSDKManager.getInstance();
                       sm.onSDKEngineInitialize();

                       // 设置 Weex 初始化的 Congif 参数(可以为空)
                       if(config != null ) {
                           sm.setInitConfig(config);
                       }
                       // 初始化 SoLoaderAdapter 默认直接调用 System.loadLibrary(so...)
                       WXSoInstallMgrSdk.init(application,
                                              sm.getIWXSoLoaderAdapter(),
                                              sm.getWXStatisticsListener());
                       // 加载 V8 so 库，一个叫 weexcore.so 的库
                       mIsSoInit = WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
                       if (!mIsSoInit) {
                           WXExceptionUtils.commitCriticalExceptionRT(null,
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                                      "doInitInternal",
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "isSoInit false",
                                                                      null);
                           return;
                       }
                       // 调用 WXBridgeManager 的 initScriptsFramework 方法，一系列调用最终调用到了 WXBridgeManager 的 initFramework 方法，我们后续再看
                       sm.initScriptsFramework(config!=null?config.getFramework():null);
                   }
               });
           // 注册了一堆默认的 Component
           register();
       }
     #+END_SRC

     可以看到其中几步重要的操作通过 ~WXBridgeManager.getInstance().post()~ 在线程中完成,详细的线程模型可以查 [[weex_thread]]:
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
     WXBridgeManager.getInstance().post(new Runnable() {
               @Override
               public void run() {
                   // do something
               }
           };
     #+END_SRC
     其中有两个重要的方法,继续往下追 ~initFramework~ 方法和 ~register~ 方法,分两小节来介绍.
***** WXSoInstallMgrSdk => initSo

      加载打包在 APK 内的所有 so 文件
      - libJavaScriptCore.so
      - libweexcore.so
      - libweexjsb.so
      - libweexjss.so
      - libweexjst.so

      ~WXSDKEngine => doInitInternal()~ 方法中调用了 ~WXSoInstallMgrSdk => initSo()~ 方法:
      #+NAME: WXSDKEngine.java
      #+BEGIN_SRC java
      // V8_SO_NAME = "weexcore.so"
      WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
      #+END_SRC

      ~WXSoInstallMgrSdk => initSo()~ 方法内部实现:
      #+BEGIN_SRC java
        /**
         ,* Load so library.
         ,*
         ,* If a library loader adapter exists, use this adapter to load library,
         ,* otherwise use {@link System#loadLibrary(String)} to load library.
         ,* If failed to load library, try to extract the so library and load it
         ,* from arembi in the .apk
         ,*
         ,* @param libName library name, like webp, not necessary to be libwep.so
         ,* @param version the version of the so library
         ,*/
        public static boolean initSo(String libName, int version, IWXUserTrackAdapter utAdapter) {
            // other code...

            // copy startup so
            copyStartUpSo();

            // other code...
            if (mSoLoader != null) {
                mSoLoader.doLoadLibrary(libName);
            } else {
                System.loadLibrary(libName);
            }
            // other code...
        }
      #+END_SRC

***** WXBridgeManager => initFramework
      可能需要了解下这里的 framework 是什么概念, [[weex_jsframework][传送门]].
      关于 JSFramework 的初始化: [[weex_jsframework_init][传送门]]
      有关 Module 注册: [[weex_register_module][传送门]]
      有关 Component 注册: [[weex_register_module][传送门]]

***** WXSDKEngine => regiser
      初始化 Framework 层之后， ~WXSDKEngine~ 调用了 ~register()~ 方法注册了一系列内置的 Component 和 Module
      #+NAME: 内嵌的 Component 组件
      | Component         | Class                         |
      |-------------------+-------------------------------|
      | text              | WXText.class                  |
      | image             | WXImage.class                 |
      | img               | WXImage.class                 |
      | div               | WXDiv.class                   |
      | container         | WXDiv.class                   |
      | header            | WXDiv.class                   |
      | footer            | WXDiv.class                   |
      | scroller          | WXScroller.class              |
      | slider            | WXSlider.class                |
      | cycleslider       | WXSlider.class                |
      | slider-neighbor   | WXSliderNeighbor.class        |
      | cell              | WXCell.class                  |
      | list              | WXListComponent.class         |
      | vlist             | WXListComponent.class         |
      | recycler          | WXListComponent.class         |
      | waterfall         | WXListComponent.class         |
      | simplelist        | SimpleListComponent.class     |
      | recycler-list     | WXRecyclerTemplateList.class  |
      | hlist             | HorizontalListComponent.class |
      | cell-slot         | WXCell.class                  |
      | indicator         | WXIndicator.class             |
      | video             | WXVideo.class                 |
      | input             | WXInput.class                 |
      | textarea          | WXTextarea.class              |
      | switch            | WXSwitch.class                |
      | a                 | WXA.class                     |
      | embed             | WXEmbed.class                 |
      | web               | WXWeb.class                   |
      | refresh           | WXRefresh.class               |
      | loading           | WXLoading.class               |
      | loading-indicator | WXLoadingIndicator.class      |
      | header            | WXHeader.class                |

      #+NAME: 内嵌的 Module 组件
      | Module       | Class                     |
      |--------------+---------------------------|
      | modal        | WXModalUIModule.class     |
      | instanceWrap | WXInstanceWrap.class      |
      | animation    | WXAnimationModule.class   |
      | webview      | WXWebViewModule.class     |
      | navigator    | WXNavigatorModule.class   |
      | stream       | WXStreamModule.class      |
      | timer        | WXTimerModule.class       |
      | storage      | WXStorageModule.class     |
      | clipboard    | WXClipboardModule.class   |
      | globalEvent  | WXGlobalEventModule.class |
      | picker       | WXPickersModule.class     |
      | meta         | WXMetaModule.class        |
      | webSocket    | WebSocketModule.class     |
      | locale       | WXLocaleModule.class      |
**** WXSDKEngine -> registerApplicationOptions
     可以认为是获取了 App 的一些环境配置
     | key                  | value                                      |
     |----------------------+--------------------------------------------|
     | screen_width_pixels  | resources.getDisplayMetricx().widthPixels  |
     | screen_height_pixels | resources.getDisplayMetricx().heightPixels |
     | status_bar_height    | get status bar height                      |

     获取 status_bar_height 的方式：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // com.taobao.weex.WXSDKEngine
       int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android");
       if (resourceId > 0) {
           int statusBarHeight = resources.getDimensionPixelSize(resourceId);
           registerCoreEnv("status_bar_height", String.valueOf(statusBarHeight));
       }
     #+END_SRC
*** Weex 页面渲染流程分析
    #+NAME: Weex 加载页面的调用
    #+BEGIN_SRC java
      public class MainActivity extends AppCompatActivity implements IWXRenderListener {

          WXSDKInstance mWXSDKInstance;

          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);

              mWXSDKInstance = new WXSDKInstance(this);
              mWXSDKInstance.registerRenderListener(this);
              /**
               ,* WXSample 可以替换成自定义的字符串，针对埋点有效。
               ,* template 是.we transform 后的 js 文件。
               ,* option 可以为空，或者通过 option 传入 js 需要的参数。例如 bundle js 的地址等。
               ,* jsonInitData 可以为空。
               ,* width 为-1 默认全屏，可以自己定制。
               ,* height =-1 默认全屏，可以自己定制。
               ,*/
              mWXSDKInstance.render("WXSample", WXFileUtils.loadFileOrAsset("hello.js", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC);
          }

          /* other methods */
      }
    #+END_SRC
    来分析下 WXSDKInstance -> render() 方法的内部实现, 除了参数检查之外,它其实调用的是内部的 rednerInternal 方法.

**** WXSDKInstance -> renderInternal
     redner 方法内部调用了内部的 renderInternal 方法来进行 Weex 页面的渲染，来看下代码：
     #+NAME: WXSDKInstance.class
     #+BEGIN_SRC java
      /**
       ,* Render template asynchronously
       ,*
       ,* @param pageName, used for performance log.
       ,* @param template bundle js
       ,* @param options  os   iphone/android/ipad
       ,*                 weexversion    Weex version(like 1.0.0)
       ,*                 appversion     App version(like 1.0.0)
       ,*                 devid        Device id(like Aqh9z8dRJNBhmS9drLG5BKCmXhecHUXIZoXOctKwFebH)
       ,*                 sysversion    Device system version(like 5.4.4、7.0.4, should be used with os)
       ,*                 sysmodel     Device model(like iOS:"MGA82J/A", android:"MI NOTE LTE")
       ,*                 Time    UNIX timestamp, UTC+08:00
       ,*                 TTID(Optional)
       ,*                 MarkertId
       ,*                 Appname(Optional)  tm,tb,qa
       ,*                 Bundleurl(Optional)  template url
       ,* @param jsonInitData Initial data for rendering
       ,* @param flag     RenderStrategy {@link WXRenderStrategy}
       ,*/
      private void renderInternal(String pageName,
                                  String template,
                                  Map<String, Object> options,
                                  String jsonInitData,
                                  WXRenderStrategy flag){
          // 此处省略各种参数检查
          // 此处省略数据埋点

          // 检查 RenderContainer 是否为空，为空的话创建一个
          ensureRenderArchor();

          Map<String, Object> renderOptions = options;
          if (renderOptions == null) {
              renderOptions = new HashMap<>();
          }
          if (WXEnvironment.sDynamicMode && !TextUtils.isEmpty(WXEnvironment.sDynamicUrl) && renderOptions.get("dynamicMode") == null) {
              renderOptions.put("dynamicMode", "true");
              // 根据 URL 渲染，最终还是调用到 renderInternal 方法，最终还是会调用 WXSDKManager -> createInstance 方法
              renderByUrl(pageName, WXEnvironment.sDynamicUrl, renderOptions, jsonInitData, flag);
              return;
          }
          WXSDKManager.getInstance().setCrashInfo(WXEnvironment.WEEX_CURRENT_KEY,pageName);
          // 渲染页面，会调用 WXBridgeManager -> createInstance 方法
          WXSDKManager.getInstance().createInstance(this, template, renderOptions, jsonInitData);
          mRendered = true;
      }
     #+END_SRC

**** WXBridgeManager -> createInstance
     render 方法调用最终会调用到这个方法中
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       public void createInstance(final String instanceId, final String template,
                                  final Map<String, Object> options, final String data) {
           final WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId);
           // 此处省略  WXSDKInstance 为空检查

           if (!isJSFrameworkInit() && reInitCount == 1 && !WXEnvironment.sDebugServerConnectable) {
               //  错误日志
               post(new Runnable() {
                       @Override
                       public void run() {
                           // 再次初始化 JSFramework 环境
                           initFramework("");
                       }
                   }, instanceId);
               return;
           }

           WXModuleManager.createDomModule(instance);
           post(new Runnable() {
                   @Override
                   public void run() {
                       // 省略一堆性能日志代码
                       invokeCreateInstance(instance, template, options, data);
                   }
               }, instanceId);
       }
     #+END_SRC

     来看下 createInstance 方法最后调用到的 invokeCreateInstance 方法
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       private void invokeCreateInstance(@NonNull WXSDKInstance instance, String template,
                                         Map<String, Object> options, String data) {
           // add for sandbox, will delete on sandbox ok
           initFramework("");

           if (mMock) {
               mock(instance.getInstanceId());
           } else {

               //省略 JSFramework 环境检查

               WXModuleManager.registerWhenCreateInstance();
               try {
                   BundType type = BundType.Others;
                   try {
                       // BundType.Vue or BundType.Rax
                       type = getBundleType(instance.getBundleUrl(), template);
                   } catch (Throwable e) {
                   }

                   try {
                       if (options == null) {
                           options = new HashMap<>();
                       }
                       // on file there is { "framework": "Vue" } or others
                       if (options.get(BUNDLE_TYPE) == null) {
                           // may vue or Rax
                           if (type == BundType.Vue) {
                               options.put(BUNDLE_TYPE, "Vue");
                           } else if (type == BundType.Rax) {
                               options.put(BUNDLE_TYPE, "Rax");
                           } else {
                               options.put(BUNDLE_TYPE, "Others");
                           }
                           instance.getApmForInstance().addProperty(WXInstanceApm.KEY_PAGE_PROPERTIES_BUNDLE_TYPE, options.get(BUNDLE_TYPE));
                       }
                       if (options.get("env") == null) {
                           options.put("env", mInitParams.toMap());
                       }
                   } catch (Throwable e) {
                       e.printStackTrace();
                   }
                   instance.bundleType = type;

                   // 省略日志什么的

                   WXJSObject instanceIdObj = new WXJSObject(WXJSObject.String, instance.getInstanceId());
                   // template 为加载的 JS 内容
                   WXJSObject instanceObj = new WXJSObject(WXJSObject.String, template);
                   WXJSObject optionsObj = new WXJSObject(WXJSObject.JSON,options == null ? "{}" : WXJsonUtils.fromObjectToJSONString(options));
                   optionsObj = optionObjConvert(isSandBoxContext, type, optionsObj);
                   WXJSObject dataObj = new WXJSObject(WXJSObject.JSON, data == null ? "{}" : data);

                   WXJSObject apiObj;
                   if (type == BundType.Rax) {
                       if (mRaxApi == null) {
                           mRaxApi =  WXFileUtils.loadAsset("weex-rax-api.js", WXEnvironment.getApplication());
                       }
                       apiObj = new WXJSObject(WXJSObject.String,
                                               mRaxApi);
                   } else {
                       apiObj = new WXJSObject(WXJSObject.String,
                                               "");
                   }

                   // When render strategy is data_render, put it into options. Others keep null.
                   WXJSObject renderStrategy = null;
                   if (instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                       renderStrategy = new WXJSObject(WXJSObject.String, WXRenderStrategy.DATA_RENDER.getFlag());
                   }

                   WXJSObject[] args = {instanceIdObj, instanceObj, optionsObj,
                                        dataObj, apiObj, renderStrategy};
                   instance.setTemplate(template);
                   instance.getApmForInstance().onStage(WXInstanceApm.KEY_PAGE_STAGES_LOAD_BUNDLE_END);

                   if (!isSandBoxContext) {
                       invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                       return;
                   }
                   if (type == BundType.Vue || type == BundType.Rax
                       || instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                       invokeCreateInstanceContext(instance.getInstanceId(), null, "createInstanceContext", args, false);
                       return;
                   } else {
                       invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                       return;
                   }
               } catch (Throwable e) {
                   // 处理异常
               }
           }
       }
     #+END_SRC
     后续的渲染工作就交给 native 层来完成,可以看下底层的实现:  [[weex_core_render][传送门]]

**** JSFramework 渲染过程
     [[weex_jsf_render][JSFramework 页面渲染]]
*** JS Bridge
    来看下 Android 的 SDK 中用来和 JS Engine（V8）进行双向通信的代码,主要的类有 WXBridgeManager.java 和 WXBridge.java.
    与 native 的 JS 方法的调用都运行在 JsBridge 线程中。
**** WXBridgeManager.java
     负责通过 WXBridge.java 提供的一系列 native 接口,来完成 Java 环境和 JS 之间的交互.

**** WXBridge.java
     封装了一层 Java 层和 JNI 层关于 JS 调用的接口,内部实现了一堆 native 调用方法.
**** 注册 Component
     <<weex_register_component>>

     再来看下如何手动注册一个 Component 组件:
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // 调用 SDK 提供的 API 注册一个 Component 实现
       WXSDKEngine.registerComponent("richText", RichText.class);

       // 实际调用的注册方法
       public static boolean registerComponent(Map<String, Object> componentInfo, Class<? extends WXComponent> clazz) throws WXException {
           if(componentInfo == null){
               return false;
           }
           String type = (String)componentInfo.get("type");
           if(TextUtils.isEmpty(type)){
               return false;
           }
           return WXComponentRegistry.registerComponent(type,new SimpleComponentHolder(clazz), componentInfo);
       }
     #+END_SRC

     WXComponentRegistry -> registerComponent
     #+NAME: WXComponentRegistry.java
     #+BEGIN_SRC java
       public static synchronized boolean registerComponent(final String type, final IFComponentHolder holder, final Map<String, Object> componentInfo) throws WXException {
           if (holder == null || TextUtils.isEmpty(type)) {
               return false;
           }

           //register component
           AutoScanConfigRegister.preLoad(holder);

           //execute task in js thread to make sure register order is same as the order invoke register method.
           WXBridgeManager.getInstance()
               .post(new Runnable() {
                       @Override
                       public void run() {
                           try {
                               Map<String, Object> registerInfo = componentInfo;
                               if (registerInfo == null){
                                   registerInfo = new HashMap<>();
                               }

                               registerInfo.put("type",type);
                               registerInfo.put("methods",holder.getMethods());
                               // 注册 Component 到本地的一个静态变量 ConcurrentHashMap -> sTypeComponentMap 中
                               registerNativeComponent(type, holder);
                               // 调用 WXBridgeManager -> invokeRegisterComponents 方法
                               registerJSComponent(registerInfo);
                               sComponentInfos.add(registerInfo);
                           } catch (WXException e) {
                               WXLogUtils.e("register component error:", e);
                           }

                       }
       }
     #+END_SRC

     WXBridgeManager -> invokeRegisterComponents
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java

       private void invokeRegisterComponents(List<Map<String, Object>> components, List<Map<String, Object>> failReceiver) {
           if (components == failReceiver) {
               throw new RuntimeException("Fail receiver should not use source.");
           }
           if (!isJSFrameworkInit()) {
               // JSFramework 还没初始化成功,丢到 failReceiver 列表中,等 JSFramework 初始化成功之后重新注册
               for (Map<String, Object> comp : components) {
                   failReceiver.add(comp);
               }
               return;
           }
           if (components == null) {
               return;
           }
           WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(components)};
           try {
               // 调用 WXBridge.java 提供的 JNI 方法,注册到 JS 环境中
               if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_COMPONENTS, args)) {
                   errorMsg = "execJS error";
               }
           } catch (Throwable e) {
               // 省略异常日志输出
           }
           // 省略异常日志输出
       }
     #+END_SRC

     Native 注册 Component: [[weex_core_register_component][传送门]]

**** 注册 Module
     <<weex_register_module>>

     来看下 Android 应用中注册 Module 的方式:
     #+BEGIN_SRC java
     WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC

     WXSDKEngine -> registerModule
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       /**
        ,* Register module. This is a wrapper method for
        ,* {@link #registerModule(String, Class, boolean)}. The module register here only need to
        ,* be singleton in {@link WXSDKInstance} level.
        ,* @param moduleName  module name
        ,* @param moduleClass module to be registered.
        ,* @return true for registration success, false for otherwise.
        ,* {@link WXModuleManager#registerModule(String, ModuleFactory, boolean)}
        ,*/
       public static <T extends WXModule> boolean registerModule(String moduleName, Class<T> moduleClass,boolean global) throws WXException {
           return moduleClass != null && registerModule(moduleName, new TypeModuleFactory<>(moduleClass), global);
       }

       public static <T extends WXModule> boolean registerModule(String moduleName, ModuleFactory factory, boolean global) throws WXException {
           return WXModuleManager.registerModule(moduleName, factory,global);
       }
     #+END_SRC

     WXModuleManager -> regiserModule
     #+NAME: WXModuleManager.java
     #+BEGIN_SRC java
       public static boolean registerModule(final String moduleName, final ModuleFactory factory, final boolean global) throws WXException {
           // 省略一系列的参数检查

           //execute task in js thread to make sure register order is same as the order invoke register method.
           WXBridgeManager.getInstance()
               .post(new Runnable() {
                       @Override
                       public void run() {
                           try {
                               // 将注册的 Module 相关参数放到一个静态的 volatile ConcurrentHashMap 中
                               registerNativeModule(moduleName, factory);
                           } catch (WXException e) {
                           }
                           // 省略 global Module map

                           // 调用 WXSDKManager 的 registerJSModules 方法
                           registerJSModule(moduleName, factory);
                       }
                   });
           return true;
       }

       static boolean registerJSModule(String moduleName, ModuleFactory factory) {
           Map<String, Object> modules = new HashMap<>();
           modules.put(moduleName, factory.getMethods());
           // WXSDKManager 中调用了 WXBridgeManager -> registerModules 方法
           WXSDKManager.getInstance().registerModules(modules);
           return true;
       }
     #+END_SRC

     WXBridgeManager -> registerModules
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       public void registerModules(final Map<String, Object> modules) {
           if (modules != null && modules.size() != 0) {
               // 确保是在 JSThread 中完成注册
               if (isJSThread()) {
                   invokeRegisterModules(modules, mRegisterModuleFailList);
               } else {
                   post(new Runnable() {
                           @Override
                           public void run() {
                               invokeRegisterModules(modules, mRegisterModuleFailList);
                           }
                       }, null);
               }
           }
       }
     #+END_SRC

     WXBridgeManager -> invokeRegisterModules
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       private void invokeRegisterModules(Map<String, Object> modules, List<Map<String, Object>> failReceiver) {
           if (modules == null || !isJSFrameworkInit()) {
               // JSFramework 没有初始化的情况下放到 failReceiver 列表中,下次 initFramework 的时候再次注册
               failReceiver.add(modules);
               return;
           }

           WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(modules)};
           try {
               // 通过 WXBridge.java 的 JNI 方法调用,完成 Module 注册到 JS 环境中
               if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_MODULES, args)) {
                   errorMsg = "execJS error";
               }
               // 注册成功之后调用 WXModuleManager.resetModuleState(module, true); 方法更新 module 状态
           } catch (Throwable e) {
           }
           //忽略错误信息打印
       }
     #+END_SRC

     Native 注册 Component: [[weex_core_register_module][传送门]]

*** Android Render Engine
** TODO 源码分析-iOS
*** 初始化流程分析

*** JS Bridge

*** iOS Render Engine

** DOING 源码分析-JS
*** JSFramework
    <<weex_jsframework>>
**** framework 是个啥?
     Weex 通过调用 JS Framework 提供的接口来调用原生功能并且渲染真实 UI.代码层面其实就是 weex 提供的一个 js 库,用来完成 js 调用原生功能的一个组件.
**** 配置 framework
     在 weex 初始化时,通过设置 InitConfig 的 framework 参数,来配置 framework:
     #+NAME: InitConfig.java
     #+BEGIN_SRC java
     // 如果不设置,默认为打包在 Android SDK 中的 main.js
     InitConfig config=new InitConfig.Builder().setFramework("your framework").build();
     #+END_SRC
*** JSFramework 初始化
    <<weex_jsframework_init>>
**** Android SDK 中的初始化流程
***** WXSDKEngine => doInitInternal()
      WeexSDK 初始化的时候会在 ~WXSDKEngine.java~ 的 ~doInitInternal()~方法中进行 JSFramework 的初始化:
      #+NAME: WXSDKEngine.java
      #+BEGIN_SRC java
        private static void doInitInternal(final Application application,final InitConfig config){
            WXBridgeManager.getInstance().post(new Runnable() {
                    @Override
                    public void run() {
                        WXSDKManager sm = WXSDKManager.getInstance();
                        // code init SO libs
                        // 调用 WXSDKManager 的 initScriptsFramework()方法
                        sm.initScriptsFramework(config!=null?config.getFramework():null);
                    }
                });
        }
      #+END_SRC

***** -> WXSDKManager => initScriptsFramework()
      WXSDKManager 的 ~initScriptsFramework()~ 方法调用了 ~WXBridgeManager~ 的 ~initScriptsFramework()~方法.

***** -> WXBridgeManager => initScriptsFramework()

      将初始化 JSFramework 的工作交给 JSHandler 来处理, 调用了 ~WXBridgeManager => invokeInitFramework(Message)~ 方法:
      #+NAME: WXBridgeManager.java
      #+BEGIN_SRC java
        public synchronized void initScriptsFramework(String framework) {
            Message msg = mJSHandler.obtainMessage();
            msg.obj = framework;
            msg.what = WXJSBridgeMsgType.INIT_FRAMEWORK;
            msg.setTarget(mJSHandler);
            msg.sendToTarget();
        }
      #+END_SRC

***** -> WXBridgeManager => invokeInitFramework()
      简单检查了下参数和内存情况, 内存允许(可用内容大于 120MB)的情况下, 去初始化 JSFramework, 否则是在渲染页面的时候再去初始化 JSFramework
      #+BEGIN_SRC java
        private void invokeInitFramework(Message msg) {
            String framework = "";
            if (msg.obj != null) {
                framework = (String) msg.obj;
            }

            // LOW_MEM_VALUE = 120(单位是 MB)
            if (WXUtils.getAvailMemory(WXEnvironment.getApplication()) > LOW_MEM_VALUE) {
                initFramework(framework);
            }
        }
      #+END_SRC

      顺便围观下怎么取可用内存:
      #+NAME: WXUtils.java
      #+BEGIN_SRC java
        public static long getAvailMemory(Context context){
            ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
            am.getMemoryInfo(mi);
            //mi.availMem; 当前系统的可用内存
            //return Formatter.formatFileSize(context, mi.availMem);// 将获取的内存大小规格化
            WXLogUtils.w("app AvailMemory ---->>>"+mi.availMem/(1024*1024));
            return mi.availMem/(1024*1024);
        }
      #+END_SRC

***** -> WXBridgeManager => initFramework()
      #+NAME: WXBridgeManager.java
      #+BEGIN_SRC java
        private void initFramework(String framework) {
            if (WXSDKEngine.isSoInitialized() && !isJSFrameworkInit()) {
                // other code
                if (TextUtils.isEmpty(framework)) {
                    IWXJsFileLoaderAdapter wxJsFileLoaderAdapter = WXSDKEngine.getIWXJsFileLoaderAdapter();
                    if (!isSandBoxContext) {
                        // adapter
                        if(TextUtils.isEmpty(framework)) {
                            framework = WXFileUtils.loadAsset("main.js", WXEnvironment.getApplication());
                        }
                    } else {
                        // adapter
                        if(TextUtils.isEmpty(framework)) {
                            framework = WXFileUtils.loadAsset("weex-main-jsfm.js", WXEnvironment.getApplication());
                        }
                    }
                }
                // check framework
                try {
                    // 监听 code
                    boolean pieSupport = true;
                    try {
                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
                            pieSupport = false;
                        }
                    } catch (Exception e) {
                    }
                    // extends initFramework
                    if (mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport) == INIT_FRAMEWORK_OK) {
                        // 日志+监听
                        execRegisterFailTask();
                        WXEnvironment.JsFrameworkInit = true;
                        registerDomModule();
                    } else {
                        // 错误日志
                    }
                } catch (Throwable e) {
                    // 错误日志
                }

            }
        }
      #+END_SRC
**** Android WeexCore 中的处理
***** JNI => initFrameworkEnv
      ~mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport)~ 实际调用的是 native 层的代码.
      先来看下它对应的 JNI 的接口声明：
      #+NAME: WXBridge_jni.h
      #+BEGIN_SRC c++
         static const JNINativeMethod kMethodsWXBridge[] =
           {
           // 对应 private native int nativeInitFrameworkEnv(String framework, WXParams params, String cacheDir, boolean pieSupport);
           // Z 对应 Java 中的 boolean
            { "nativeInitFrameworkEnv",
              "("
              "Ljava/lang/String;"
              "Lcom/taobao/weex/bridge/WXParams;"
              "Ljava/lang/String;"
              "Z"
              ")"
              "I", reinterpret_cast<void*>(InitFrameworkEnv) }
            // other native methods...
           }
      #+END_SRC

      跟直接用包名声明的方式不用, 这里使用了 ~JNIEnv => RegisterNatives()~ 方式来绑定调用关系.
      ~reinterpret_cast<void*>(InitFrameworkEnv)~ 指定了 Native 实现的方法名: InitFrameworkEnv
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
         // framework
         // cacheDir 为 App 的 CacheDir
         // pirSupport 默认为 true (SDK < JELLY_BEAN)
         static jint InitFrameworkEnv(JNIEnv* env, jobject jcaller, jstring framework,
                                      jobject params, jstring cacheDir,
                                      jboolean pieSupport) {
           const char* cache = env->GetStringUTFChars(cacheDir, nullptr);
           if (strlen(cache) > 0) {
             SoUtils::set_cache_dir(const_cast<char*>(cache));
           }
           SoUtils::set_pie_support(pieSupport);
           jint ret = InitFramework(env, jcaller, framework, params);
           env->ReleaseStringUTFChars(cacheDir, cache);
           return ret;
         }
      #+END_SRC

      ~InitFramework()~ 方法:
      #+NAME:wx_bridge.cpp
      #+BEGIN_SRC c++
        static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
          WXBridge::Instance()->Reset(env, object);
          // Init platform thread --- ScriptThread
          WeexCoreManager::Instance()->InitScriptThread();
          // Exception handler for so
          SoUtils::RegisterExceptionHanler([](const char* status_code, const char* error_msg)
                                           {
                                             WeexCoreManager::Instance()
                                               ->getPlatformBridge()
                                               ->platform_side()
                                               ->ReportNativeInitStatus(status_code, error_msg);
                                           });
          // Init platform bridge
          PlatformBridge* bridge = new AndroidBridgeInSimple;
          WeexCoreManager::Instance()->set_platform_bridge(bridge);
          // Init params
          std::vector<INIT_FRAMEWORK_PARAMS*> params_vector =
            initFromParam(env, params, [](const char* status_code, const char* error_msg)
                                       {
                                         WeexCoreManager::Instance()
                                           ->getPlatformBridge()
                                           ->platform_side()
                                           ->ReportNativeInitStatus(status_code, error_msg);
                                       });
          // If parse init params error, return false
          if (params_vector.empty()) return false;
          // Set project mode

          WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_PROCESS);
          WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);

          // It means initialization failed when any bridge is not passable
          if (!WeexCoreManager::Instance()->getPlatformBridge()->is_passable() ||
              !WeexCoreManager::Instance()->script_bridge()->is_passable()) {

            if(isSingleProcess()) {
              WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_SO);
              WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiSo);

              if (!WeexCoreManager::Instance()->getPlatformBridge()->is_passable() ||
                  !WeexCoreManager::Instance()->script_bridge()->is_passable()) {
                return false;
              }
            }
          }

          // for environment
          bridge->core_side()->SetPlatform(WXCoreEnvironment::getInstance()->platform());
          bridge->core_side()->SetDeviceWidthAndHeight(WXCoreEnvironment::getInstance()->DeviceWidth(), WXCoreEnvironment::getInstance()->DeviceHeight());
          auto options = WXCoreEnvironment::getInstance()->options();
          auto it = options.begin();
          for (; it != options.end(); it++) {
            bridge->core_side()->AddOption(it->first, it->second);
          }
          // Set measure function
          WeexCoreManager::Instance()->set_measure_function_adapter(new MeasureFunctionAdapterImplAndroid());
          bridge->core_side()->SetMeasureFunctionAdapter();
          ScopedJStringUTF8 c_script(env, script);
          // Call InitFramework
          auto result =
            bridge->core_side()->InitFramework(c_script.getChars(), params_vector);
          freeParams(params_vector);
          return result;
        }
      #+END_SRC
***** -> CoreSideInPlatform => InitFramework()
      #+NAME: core_side_in_platform.cpp
      #+BEGIN_SRC c++
        int CoreSideInPlatform::InitFramework(const char *script, std::vector<INIT_FRAMEWORK_PARAMS *> &params) {
          return WeexCoreManager::Instance()
            ->script_bridge()
            ->script_side()
            ->InitFramework(script, params);
        }
      #+END_SRC
***** -> ScriptSideInMultiProcess => InitFramework()
      #+NAME: script_side_in_multi_process.cpp
      #+BEGIN_SRC c++

        int ScriptSideInMultiProcess::InitFramework(const char *script, std::vector<INIT_FRAMEWORK_PARAMS *> &params) {
          try {
            // check sender != null
            std::unique_ptr<IPCSerializer> serializer(createIPCSerializer());
            serializer->setMsg(static_cast<uint32_t>(IPCJSMsg::INITFRAMEWORK));
            serializer->add(script, strlen(script));
            for (auto it = params.begin(); it != params.end(); ++it) {
              serializer->add((*it)->type->content, (*it)->type->length);
              serializer->add((*it)->value->content, (*it)->value->length);
            }
            std::unique_ptr<IPCBuffer> buffer = serializer->finish();
            std::unique_ptr<IPCResult> result = sender_->send(buffer.get());
            if (result->getType() != IPCType::INT32) {
              LOGE("initFramework Unexpected result type");
              bridge()->core_side()->ReportException("", "initFramework", "error, initFramework Unexpected result type");
              return false;
            }
          } catch (IPCException &e) {
            LOGE("%s", e.msg());
            return false;
          }
          return true;
        }
      #+END_SRC
***** -> weex_js_engine => initFramework()                         :confirm:
      IPC 接收 ~IPCJSMsg::INITFRAMEWORK~ 方法没有在项目中暴露出来，查看 weex_js_engine 中有这么一个实现方法,　在这个方法中实际加载了 main.js 文件：
      #+NAME: com_taobao_weex_bridge_WXBridge.cpp
      #+BEGIN_SRC c++
        jint Java_com_taobao_weex_bridge_WXBridge_initFramework(JNIEnv *env,
                                                                jobject object, jstring script,
                                                                jobject params) {
          // 配置 WXEnvironment
          WXEnvironment->Set(c_key, jString2V8String(env, jvalue));
          // 创建 V8Context
          V8context = CreateShellContext();
          const char *scriptStr = env->GetStringUTFChars(script, NULL);
          // 执行 script 脚本内容
          if (scriptStr == NULL || !ExecuteJavaScript(globalIsolate, v8::String::New(scriptStr), true)) {
            return false;
          }
          setJSFVersion(env);
          env->ReleaseStringUTFChars(script, scriptStr);
          env->DeleteLocalRef(c_params);
          return true;
        }
      #+END_SRC
*** JSFramework 处理 Native 的调用
    <<weex_jsf_render>>

***** Methods
      列了下 ~WXBridgeManager.java~ 中声明的一些 call JS 的方法:
      #+NAME: Native Call JS Function
      | Methods                   | Description |
      |---------------------------+-------------|
      | createInstance            |             |
      | destroyInstance           |             |
      | callJS                    |             |
      | setTimeoutCallback        |             |
      | registerModules           |             |
      | registerComponents        |             |
      | fireEvent                 |             |
      | fireEventSync             |             |
      | componentHook             |             |
      | callback                  |             |
      | refreshInstance           |             |
      | fireEventOnDataRenderNode |             |
      | notifyTrimMemory          |             |
      | notifySerializeCodeCache  |             |
      | createInstanceContext     |             |

***** 渲染 Weex 页面
****** Native => render("weex_page.js")
       ~WXSDKInstance => render()~ 来渲染一个 weex 页面:
       #+NAME: Weex render demo
       #+BEGIN_SRC java
         /**
          ,* WXSample 可以替换成自定义的字符串，针对埋点有效。
          ,* template 是.we transform 后的 js 文件。
          ,* option 可以为空，或者通过 option 传入 js 需要的参数。例如 bundle js 的地址等。
          ,* jsonInitData 可以为空。
          ,* width 为-1 默认全屏，可以自己定制。
          ,* height =-1 默认全屏，可以自己定制。
          ,*/
         mWXSDKInstance.render("WXSample", WXFileUtils.loadFileContent("hello.js", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC);
       #+END_SRC
       内部其实时把这个 render 调用转成了 IPC 消息的方式来调用到 JSFramework 中的 ~createInstance()~ 方法,这里的具体步骤文档中有提到,就不详细展开了.
       
****** -> JSFramework => createInstance()
       #+NAME: runtime/api/init.js
       #+BEGIN_SRC javascript
         function createInstance (id, code, config, data) {
           // 忽略各种检查和配置参数的代码
           const instanceContext = createInstanceContext(id, config, data)
           if (typeof framework.createInstance === 'function') {
             // Temporary compatible with some legacy APIs in Rax,
             // some Rax page is using the legacy ".we" framework.
             if (bundleType === 'Rax' || bundleType === 'Weex') {
               const raxInstanceContext = Object.assign({
                 config,
                 created: Date.now(),
                 framework: bundleType
               }, instanceContext)
               return framework.createInstance(id, code, config, data, raxInstanceContext)
             }
             return framework.createInstance(id, code, config, data, instanceContext)
           }
           // console.error(`[JS Framework] Can't find available "createInstance" method in ${bundleType}!`)
           runInContext(code, instanceContext)
         }
       #+END_SRC

****** -> JS => createInstanceContext()
       #+NAME: runtime/api/init.js
       #+BEGIN_SRC javascript
         function createInstanceContext (id, options = {}, data) {
           const weex = new WeexInstance(id, options)
           const bundleType = options.bundleType || 'Vue'
           instanceTypeMap[id] = bundleType
           const framework = runtimeConfig.frameworks[bundleType]
           if (!framework) {
             return new Error(`[JS Framework] Invalid bundle type "${bundleType}".`)
           }

           // prepare js service
           const services = createServices(id, {
             weex,
             config: options,
             created: Date.now(),
             framework: bundleType,
             bundleType
           }, runtimeConfig)
           Object.freeze(services)

           // prepare runtime context
           const runtimeContext = Object.create(null)
           Object.assign(runtimeContext, services, {
             weex,
             getJSFMVersion,
             requireModule: (...args) => weex.requireModule(...args),
             __WEEX_CALL_JAVASCRIPT__: receiveTasks,
             services // Temporary compatible with some legacy APIs in Rax
           })
           Object.freeze(runtimeContext)

           // prepare instance context
           const instanceContext = Object.assign({}, runtimeContext)
           // 检查 framework 中有没有 createInstanceContext 方法,有的话就调用,没有的话就用 runtimeContext
           if (typeof framework.createInstanceContext === 'function') {
             Object.assign(instanceContext, framework.createInstanceContext(id, runtimeContext, data))
           }
           Object.freeze(instanceContext)
           return instanceContext
         }
       #+END_SRC

****** -> framework(legacy) => createInstance()
       #+NAME: runtime/api/frameworks/legacy/static/create.js
       #+BEGIN_SRC javascript
         /**
          ,* Create a Weex instance.
          ,*
          ,* @param  {string} id
          ,* @param  {string} code
          ,* @param  {object} options
          ,*         option `HAS_LOG` enable print log
          ,* @param  {object} data
          ,* @param  {object} info { created, ... services }
          ,*/
         export function createInstance (id, code, options, data, info) {
           const { services } = info || {}
           resetTarget()
           let instance = instanceMap[id]
           /* istanbul ignore else */
           options = options || {}
           let result
           /* istanbul ignore else */
           if (!instance) {
             instance = new App(id, options)
             instanceMap[id] = instance
             result = initApp(instance, code, data, services)
           }
           else {
             result = new Error(`invalid instance id "${id}"`)
           }
           return (result instanceof Error) ? result : instance
         }
       #+END_SRC
****** -> initApp()
       #+NAME: runtime/frameworks/legacy/app/ctrl/init.js
       #+BEGIN_SRC javascript
         export function init (app, code, data, services) {
           console.debug('[JS Framework] Intialize an instance with:\n', data)
           let result

           // prepare app env methods
           const bundleDefine = (...args) => defineFn(app, ...args)
           const bundleBootstrap = (name, config, _data) => {
             result = bootstrap(app, name, config, _data || data)
             updateActions(app)
             app.doc.listener.createFinish()
             console.debug(`[JS Framework] After intialized an instance(${app.id})`)
           }
           const bundleVm = Vm
           /* istanbul ignore next */
           const bundleRegister = (...args) => register(app, ...args)
           /* istanbul ignore next */
           const bundleRender = (name, _data) => {
             result = bootstrap(app, name, {}, _data)
           }
           /* istanbul ignore next */
           const bundleRequire = name => _data => {
             result = bootstrap(app, name, {}, _data)
           }
           const bundleDocument = app.doc
           /* istanbul ignore next */
           const bundleRequireModule = name => app.requireModule(removeWeexPrefix(name))

           const weexGlobalObject = {
             config: app.options,
             define: bundleDefine,
             bootstrap: bundleBootstrap,
             requireModule: bundleRequireModule,
             document: bundleDocument,
             Vm: bundleVm
           }

           Object.freeze(weexGlobalObject)

           // prepare code
           let functionBody
           /* istanbul ignore if */
           if (typeof code === 'function') {
             // `function () {...}` -> `{...}`
             // not very strict
             functionBody = code.toString().substr(12)
           }
           /* istanbul ignore next */
           else if (code) {
             functionBody = code.toString()
           }
           // wrap IFFE and use strict mode
           functionBody = `(function(global){\n\n"use strict";\n\n ${functionBody} \n\n})(Object.create(this))`

           // run code and get result
           const { WXEnvironment } = global
           const timerAPIs = {}

           /* istanbul ignore if */
           if (WXEnvironment && WXEnvironment.platform !== 'Web') {
             // timer APIs polyfill in native
             const timer = app.requireModule('timer')
             Object.assign(timerAPIs, {
               setTimeout: (...args) => {
                 const handler = function () {
                   args[0](...args.slice(2))
                 }
                 timer.setTimeout(handler, args[1])
                 return app.doc.taskCenter.callbackManager.lastCallbackId.toString()
               },
               setInterval: (...args) => {
                 const handler = function () {
                   args[0](...args.slice(2))
                 }
                 timer.setInterval(handler, args[1])
                 return app.doc.taskCenter.callbackManager.lastCallbackId.toString()
               },
               clearTimeout: (n) => {
                 timer.clearTimeout(n)
               },
               clearInterval: (n) => {
                 timer.clearInterval(n)
               }
             })
           }
           // run code and get result
           const globalObjects = Object.assign({
             define: bundleDefine,
             require: bundleRequire,
             bootstrap: bundleBootstrap,
             register: bundleRegister,
             render: bundleRender,
             __weex_define__: bundleDefine, // alias for define
             __weex_bootstrap__: bundleBootstrap, // alias for bootstrap
             __weex_document__: bundleDocument,
             __weex_require__: bundleRequireModule,
             __weex_viewmodel__: bundleVm,
             weex: weexGlobalObject
           }, timerAPIs, services)
           if (!callFunctionNative(globalObjects, functionBody)) {
             // If failed to compile functionBody on native side,
             // fallback to callFunction.
             callFunction(globalObjects, functionBody)
           }

           return result
         }
       #+END_SRC
****** -> runInContext()
       #+NAME: runtime/api/init.js
       #+BEGIN_SRC javascript
         /**
          ,* Run js code in a specific context.
          ,* @param {string} code
          ,* @param {object} context
          ,*/
         function runInContext (code, context) {
           const keys = []
           const args = []
           for (const key in context) {
             keys.push(key)
             args.push(context[key])
           }

           const bundle = `
             (function (global) {
               ${code}
             })(Object.create(this))
           `

           return (new Function(...keys, bundle))(...args)
         }
       #+END_SRC

*** JSFramework 调用 Native 方法
** DOING Weex Core 代码分析
*** Android & JS 调用流程分析
    Android SDK 代码分析中, ~WXBridgeManager.java~ 提供的很多方法都是通过 ~WXBridge.java~ 中定义的 JNI 接口,
    来调用 weexcore.so 中的方法, 再去调用 JSFramework 中的一些方法,来完成 Android Java 环境和 JS 环境的相互调用的.

**** TODO Android Java 和 JS 通信关系图
**** DONE WXBridge => execJS 的 JNI 接口和实现
     CLOSED: [2018-10-26 五 18:11]

***** JNI 接口定义和声明
      WXBridge 中对 execJS 方法的 JNI 接口 ~nativeExecJS()~ 的定义:
      #+NAME: WXBridge.java
      #+BEGIN_SRC java
        private native int nativeExecJS(String instanceId, String name, String function, WXJSObject[] args);
      #+END_SRC

      JNI ~nativeExecJS()~ 接口在 Native 层的声明, 实际调用的是 ~ExecJS~ 方法：
      #+NAME: WXBridge_jni.h
      #+BEGIN_SRC c
        // RegisterNatives.
        static const JNINativeMethod kMethodsWXBridge[] =
          {
           // 省略其他 Native 方法声明
           { "nativeExecJS",
             "("
             "Ljava/lang/String;"
             "Ljava/lang/String;"
             "Ljava/lang/String;"
             "[Lcom/taobao/weex/bridge/WXJSObject;"
             ")"
             "I", reinterpret_cast<void*>(ExecJS)
           }
           // 省略其他 Native 方法声明
          }
      #+END_SRC

***** JNI 接口的实现
      ~ExecJS()~ 方法的实现, 关键的步骤就是 WeexCoreManager => PlatformBridge => CoreSide => ExecJS() ：
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
        #include "android/jniprebuild/jniheader/WXBridge_jni.h"
        /**
         ,* Called to execute JavaScript such as . createInstance(),destroyInstance ext.
         ,*
         ,*/
        static jint ExecJS(JNIEnv* env, jobject jthis, jstring jinstanceid,
                           jstring jnamespace, jstring jfunction, jobjectArray jargs) {
          //省略参数检查什么的
          std::vector<VALUE_WITH_TYPE*> params;

          for (int i = 0; i < length; i++) {
            VALUE_WITH_TYPE* param = nullptr;

            param = WeexCore::getValueWithTypePtr();
            auto jni_object = base::android::ScopedLocalJavaRef<jobject>(
                                                                         env, env->GetObjectArrayElement(jargs, i));
            auto wx_js_object =
              std::unique_ptr<WXJSObject>(new WXJSObject(env, jni_object.Get()));
            addParamsFromJArgs(params, param, env, wx_js_object);
          }
          // 实际就是调了这一坨代码去调用 JSFramework 中的方法
          auto result =
              WeexCoreManager::Instance()->getPlatformBridge()->core_side()->ExecJS(instance_id.getChars(), name_space.getChars(), function.getChars(), params);
          freeParams(params);
          return result;
        }
      #+END_SRC

**** DONE ExecJS 方法的调用流程
     CLOSED: [2018-10-27 Sat 00:12]

     先来看下这一长串的调用,这步调用完成了调用 V8 Engine 提供的 API, 调用到了 JSFramework 的方法:
     #+NAME: wx_bridge.cpp
     #+BEGIN_SRC c++
       // JNI 实现方法中的调用
       WeexCoreManager::Instance()->getPlatformBridge()->core_side()->ExecJS(instance_id.getChars(), name_space.getChars(), function.getChars(), params);
       // ExecJS 方法调用
       WeexCoreManager::Instance()->script_bridge()->script_side()->ExecJS(instanceId, nameSpace, func, params);
     #+END_SRC

     整个 ~ExecJS~ 默认的调用链可以表示为：
     #+NAME: execJS 调用顺序
     #+BEGIN_EXAMPLE
     WeexCoreManager => getPlatformBridge()       #file: wx_bridge.cpp
     -> AndroidBridgeInSimple => core_side()      #file: android_bridge.cpp
     -> CoreSideInPlatform => ExecJS()            #file: core_side_in_platform.cpp
     -> WeexCoreManager => script_bridge()        #file: wx_bridge.cpp
     -> ScriptBridgeInMultiProcess =>             #file: script_bridge_in_multi_process.cpp
     -> ScriptSideInMultiProcess => ExecJS()      #file: script_side_in_multi_process.cpp
     -> IPCSender => send()                       #file: IPCSender.cpp
     #+END_EXAMPLE

***** WeexCoreManager => getPlatformBridge()
      #+NAME: weex_core_manager.h
      #+BEGIN_SRC c
        class WeexCoreManager {
          // 省略一些方法
          inline void set_platform_bridge(PlatformBridge *bridge) {
            platform_bridge_ = bridge;
          }

          inline PlatformBridge *getPlatformBridge() { return platform_bridge_; }
          // 省略一些方法
         private:
          PlatformBridge *platform_bridge_;
          // 省略一些属性
        }
      #+END_SRC

      Android 中，InitFramework 方法中会调用 set_platform_bridge 方法：
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
        static jint InitFramework(JNIEnv* env, jobject object, jstring script,
                                  jobject params) {
          // other code...
          // Init platform bridge
          PlatformBridge* bridge = new AndroidBridgeInSimple;
          WeexCoreManager::Instance()->set_platform_bridge(bridge);
          // other code...
        }
      #+END_SRC

***** -> core_side()
      ~AndroidBridgeInSimple~ 的构造方法中会设置 CoreSide 为 ~CoreSideInPlatform~
      #+NAME: android_bridge.cpp
      #+BEGIN_SRC c++
        // AndroidBridgeInSimple 继承自 PlatformBridge
        AndroidBridgeInSimple::AndroidBridgeInSimple() {
          // 调用了 PlatformBridge -> set_core_side(CoreSide* core_side) 方法
          set_core_side(new CoreSideInPlatform);
          // 调用了 PlatformBridge -> set_platform_side(PlatformSide* platform_side) 方法
          set_platform_side(new AndroidSide);
        }
      #+END_SRC

***** -> CoreSideInPlatform => ExecJS()
      CoreSideInPlatform 的 ExecJS 方法:
      #+NAME: core_side_in_platform.cpp
      #+BEGIN_SRC c++
        int CoreSideInPlatform::ExecJS(const char *instanceId, const char *nameSpace,
                                       const char *func,
                                       std::vector<VALUE_WITH_TYPE *> &params) {
          return WeexCoreManager::Instance()->script_bridge()->script_side()->ExecJS(instanceId, nameSpace, func, params);
        }
      #+END_SRC

***** -> WeexCoreManager => script_bridge()

      WeexCoreManager 中，通过两个方法来操作 ~script_bridge_~ :
      #+NAME: weex_core_manager.h
      #+BEGIN_SRC c
        inline ScriptBridge *script_bridge() { return script_bridge_; }

        inline void set_script_bridge(ScriptBridge *script_bridge) {
          script_bridge_ = script_bridge;
        }
      #+END_SRC

      Android 环境中，在 InitFramework 方法中进行设置：
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
        static jint InitFramework(JNIEnv* env, jobject object, jstring script,
                                  jobject params) {
          // Init params
          // initFromParam 关系到后面的 isSingleProcess()
          std::vector<INIT_FRAMEWORK_PARAMS*> params_vector =
            initFromParam(env, params, [](const char* status_code, const char* error_msg) {
                                         WeexCoreManager::Instance()
                                           ->getPlatformBridge()
                                           ->platform_side()
                                           ->ReportNativeInitStatus(status_code, error_msg);
                                       });
          // Set project mode
          if (isSingleProcess()) {
            WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_SO);
          } else {
            WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_PROCESS);
          }
          // Init script bridge
          if (WeexCoreManager::Instance()->project_mode() == WeexCoreManager::ProjectMode::MULTI_PROCESS) {
            WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
          } else {
            WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiSo);
          }
        }
      #+END_SRC

      ~isSingleProcess()~ 的值(设置的话需要在初始化之前,默认值为 false)：
      #+NAME:params_utils.cpp
      #+BEGIN_SRC c++
        bool g_is_single_process = false;
        bool isSingleProcess() { return g_is_single_process; }

        std::vector<INIT_FRAMEWORK_PARAMS*> initFromParam(JNIEnv* env,
                                                          jobject params,
                                                          const std::function<void(const char*, const char*)>&ReportNativeInitStatus) {
          // other code...

          jmethodID m_use_single_process = env->GetMethodID(c_params, "getUseSingleProcess", "()Ljava/lang/String;");
          if (m_use_single_process == nullptr) {
            LOGE("getUseSingleProcess method is missing");
          } else {
            jobject j_use_single_process =
              env->CallObjectMethod(params, m_use_single_process);
            const char* use_single_process =
              env->GetStringUTFChars((jstring)(j_use_single_process), nullptr);
            LOGE("g_use_single_process is %s ", use_single_process);
            if (use_single_process == nullptr) {
              g_is_single_process = false;
            } else {
              g_is_single_process = strstr(use_single_process, "true") != nullptr;
              env->DeleteLocalRef(j_use_single_process);
            }
          }

          // other code...
        }
      #+END_SRC
      这里的 ~g_is_single_process~ 是通过调用 JNI 接口 ~WXParams => getUseSingleProcess()~ 的返回值来进行配置的

      #+NAME: WXBridgeManager => setUseSingleProcess()
      #+BEGIN_SRC java
      WXBridgeManager.getInstance().setUseSingleProcess(false); // ture or false
      #+END_SRC

***** -> script_side()
      来看下默认的实现吧,默认的 ~script_bridge_~ 是 ~ScriptBridgeInMultiProcess~
      #+NAME: script_bridge_in_multi_process.cpp
      #+BEGIN_SRC c++
        ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
          set_script_side(new bridge::script::ScriptSideInMultiProcess);
          set_core_side(new CoreSideInScript);

          //other code...
        }
      #+END_SRC

***** -> ExecJS() -> IPCSender => send()
      方法最终调用了 ~IPCSender => send()~ 方法，以 IPC 的方式与 JS 进行交互:
      #+NAME: script_side_in_multi_process.cpp
      #+BEGIN_SRC c++
        int ScriptSideInMultiProcess::ExecJS(const char *instanceId,
                                             const char *nameSpace, const char *func,
                                             std::vector<VALUE_WITH_TYPE *> &params) {
          try {
            if(sender_ == nullptr) {
              LOGE("ExecJS sender is null");
              return false;
            }
            std::unique_ptr<IPCSerializer> serializer(createIPCSerializer());
            serializer->setMsg(static_cast<uint32_t>(IPCJSMsg::EXECJS));
            serializer->add(instanceId, strlen(instanceId));
            if (nameSpace)
              serializer->add(nameSpace, strlen(nameSpace));
            else {
              uint16_t tmp = 0;
              serializer->add(&tmp, 0);
            }
            serializer->add(func, strlen(func));

            for (int i = 0; i < params.size(); i++) {
              VALUE_WITH_TYPE *param = params[i];
              addParamsToIPCSerializer(serializer.get(), param);
            }

            std::unique_ptr<IPCBuffer> buffer = serializer->finish();

            // 在这里通过 IPC 的方式被发送走了,有 IPC 的地方,就有进程间通讯 emmmmm.... 继续往下跟吧
            std::unique_ptr<IPCResult> result = sender_->send(buffer.get());
            if (result->getType() != IPCType::INT32) {
              LOGE("execJS Unexpected result type");
              return false;
            }

            return result->get<jint>();

          } catch (IPCException &e) {
            LOGE("%s", e.msg());
            // report crash here
            WeexCoreManager::Instance()
              ->getPlatformBridge()
              ->platform_side()
              ->ReportServerCrash(instanceId);
            return false;
          }
        }
      #+END_SRC

***** -> weex_js_engine => exexJS()                                :confirm:
      在项目里中的代码中没有找到接收 ~IPCJSMsg::EXECJS~, 在 weex 内核的代码中找到了关于执行 JS 的一段方法：
      #+NAME: com_taobao_weex_bridge_WXBridge.cpp
      #+BEGIN_SRC c++
        /**
         ,* Called to execute JavaScript such as . createInstance(),destroyInstance ext.
         ,*
         ,*/
        jint Java_com_taobao_weex_bridge_WXBridge_execJS(JNIEnv *env, jobject this1, jstring jinstanceid,
                                                         jstring jnamespace, jstring jfunction,
                                                         jobjectArray jargs) {
          v8::HandleScope handleScope;
          v8::Isolate::Scope isolate_scope(globalIsolate);
          v8::Context::Scope ctx_scope(V8context);
          v8::TryCatch try_catch;
          int length = env->GetArrayLength(jargs);
          v8::Handle<v8::Value> obj[length];

          // 省略将 jargs 转换为 obj[] 的代码

          const char *func = env->GetStringUTFChars(jfunction, 0);
          v8::Handle<v8::Object> global = V8context->Global();
          v8::Handle<v8::Function> function;
          v8::Handle<v8::Value> result;
          // 根据 jnamespace 和 jfunction 找到需要运行的函数，并获得返回值
          if (jnamespace == NULL) {
            function = v8::Handle<v8::Function>::Cast(global->Get(v8::String::New(func)));
            result = function->Call(global, length, obj);
          }
          else {
            v8::Handle<v8::Object> master = v8::Handle<v8::Object>::Cast(global->Get(jString2V8String(env, jnamespace)));
            function = v8::Handle<v8::Function>::Cast(master->Get(jString2V8String(env, jfunction)));
            result = function->Call(master, length, obj);
          }

          if (result.IsEmpty()) {
            assert(try_catch.HasCaught());
            ReportException(globalIsolate, &try_catch, jinstanceid, func);
            env->ReleaseStringUTFChars(jfunction, func);
            return false;
          }
          env->ReleaseStringUTFChars(jfunction, func);
          return true;
        }
      #+END_SRC

**** DONE WeexJSConnection 创建并启动 IPC 服务
     CLOSED: [2018-10-26 Fri 23:56]

     IPC 服务其实实在 WeexSDK 初始化的时候创建的, 通过 JNI 调用 weexcore.so 中的方法创建并启动.

***** WXBridge 初始化
      ~WXBridge => initFramework()~ 调用 JNI ~InitFramework()~ 的时候会设置 ~ScriptBridge~ 对象(~ScriptBridgeInMultiProcess~):
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
        static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
          // other code...
          WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
          // other code...
        }
      #+END_SRC

      ~ScriptBridgeInMultiProcess~ 对象的初始化方法中会创建 ~MultiProcessAndSoInitializer~ 对象:
      #+NAME: script_bridge_in_multi_process.cpp
      #+BEGIN_SRC c++
        ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
          // 之前的 script_side 配置
          set_script_side(new bridge::script::ScriptSideInMultiProcess);
          set_core_side(new CoreSideInScript);

          // 多进程通信初始化,里面包含了对 IPC 监听的启动过程
          std::unique_ptr<MultiProcessAndSoInitializer> initializer(new MultiProcessAndSoInitializer);
        }
      #+END_SRC

      ~MultiProcessAndSoInitializer~ 对象初始化的时候调用 ~WeexJSConnection~ 的 ~start()~ 方法启动 IPC 服务:
      #+NAME: multi_process_and_so_initializer.cpp
      #+BEGIN_SRC c++
        bool MultiProcessAndSoInitializer::Init(const std::function<void(IPCHandler*)>& OnHandlerCreated,
                                                const std::function<bool(std::unique_ptr<WeexJSConnection>, std::unique_ptr<IPCHandler>, std::unique_ptr<IPCHandler>)>& OnInitFinished,
                                                const std::function<void(const char*, const char*, const char*)>& ReportException){
          // other code...
         startInitFrameWork:
          try {
            auto handler = std::move(createIPCHandler());
            auto server_handler = std::move(createIPCHandler());
            OnHandlerCreated(server_handler.get());
            std::unique_ptr<WeexJSConnection> connection(new WeexJSConnection());
            // 启动 IPC 服务,开启 listen()
            auto sender = connection->start(handler.get(), server_handler.get(), reinit);
            // other code...
          } catch (IPCException& e) {
            // other code...
          }
          return true;
        }
      #+END_SRC

***** WeexJSConnection 启动 IPC 服务线程

      要创建线程，先来看下 ~pthread_create~ 方法:
      #+BEGIN_SRC c++
        #include <pthread.h>
        /*
         * pthread_t: 指向线程标识符的指针
         * pthread_attr_t: 设置线程属性
         * start_routine: 线程运行函数的起始地址
         * arg: 最后一个参数是运行函数的参数
         */
        int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
      #+END_SRC

      在 ~WeexJSConnection~ 的 ~start~ 方法中调用了 ~pthread_create()~ 来创建 IPC 服务线程:
      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        IPCSender *WeexJSConnection::start(IPCHandler *handler, IPCHandler *serverHandler, bool reinit) {
          // other code...
          int i = pthread_create(&ipcServerThread, &threadAttr, newIPCServer, &td);
          while (newThreadStatus == UNFINISH) {
            continue;
          }

          if(newThreadStatus == ERROR) {
            throw IPCException("failed to map ashmem region");
          }
          // other code...
        }
      #+END_SRC

      ~pthread_create()~ 方法中传入的函数参数 ~newIPCServer()~ 的定义,在这个方法中开启了监听 ~IPCListener => listen()~ :
      <<weex_new_ipc_server>>
      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        static void *newIPCServer(void *_td) {
          // other code...
          // 初始化 IPCHandler 来处理消息
          const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
          // 初始化 IPCSender 来发送消息
          std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
          // 创建了 IPCListener 来接收消息
          std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
          newThreadStatus = SUCCESS;

          try {
            futexPageQueue->spinWaitPeer();
            // 启动 IPC 消息监听 looper
            listener->listen();
          } catch (IPCException &e) {
            LOGE("server died");
            close(td->ipcServerFd);
            base::android::DetachFromVM();
            pthread_exit(NULL);
          }
        }
      #+END_SRC

***** IPCSender/IPCListener/IPCHandler 的创建
      ~newIPCServer()~ 方法中完成了 IPC 流程中三个重要角色的创建：

      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        // 初始化 IPCHandler 来处理消息
        const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
        // 初始化 IPCSender 来发送消息
        std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
        // 创建了 IPCListener 来接收消息
        std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
      #+END_SRC
**** DONE Android IPCSender
     CLOSED: [2018-10-26 五 18:11]

     WXBridge 的 execJS 方法实际是调用了 CoreSideInMultiProcess 中的 IPCSender 的 send() 方法发送 IPC 消息的.

***** CoreSideInMultiProcess -> WeexJSConnection => sender()
      先来看下这个 ~sender_~ 对象, ~ScriptBridgeInMultiProcess~ 的 ~sender_~ 是在 ~ScriptSideInMultiProcess~ 中被赋值的:
      #+NAME: script_bridge_in_multi_process.cpp
      #+BEGIN_SRC c++
        ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
          // other code...
          bool passable = initializer->Init
            (
             [this](IPCHandler *handler) { RegisterIPCCallback(handler); },
             [this](std::unique_ptr<WeexJSConnection> connection,

             std::unique_ptr<IPCHandler> handler,
                    std::unique_ptr<IPCHandler> server_handler) {
               // 将 ScriptSideInMultiProcess 中的 sender 赋值为 WeexJSConnection -> sender()
               static_cast<bridge::script::ScriptSideInMultiProcess *>(script_side())->set_sender(connection->sender());
               connection_ = std::move(connection);
               handler_ = std::move(handler);
               server_handler_ = std::move(server_handler);
               LOGE("ScriptBridgeInMultiProcess finish %x %x", server_handler_.get(),
                    server_handler.get());
               return true;
             },
             [this](const char *page_id, const char *func,
                    const char *exception_string) {
               WeexCoreManager::Instance()
                 ->getPlatformBridge()
                 ->platform_side()
                 ->ReportException(page_id, func, exception_string);
             });
          // other code...
        }
      #+END_SRC

      WeexJSConnection => sender()
      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        // m_impl: new WeexJSConnectionImpl
        IPCSender* WeexJSConnection::sender() {
          return m_impl->serverSender.get();
        }
      #+END_SRC

***** -> WeexJSConnection => sender()
      这里的实际发送消息的 IPCSender 对象，实际是在 [[weex_new_ipc_server][IPC 服务创建]] 的时候进行初始化的.

      初始化的时候调用的设置 IPCSender 代码：
      #+BEGIN_SRC c++
      std::unique_ptr<IPCSender> sender(createIPCSender(futexPageQueue.get(), handler));
      #+END_SRC

      IPCSender 中的 ~createIPCSender()~ 方法, 实际上就是创建了一个 ~IPCSenderImpl~  实例：
      #+NAME: IPCSender.cpp
      #+BEGIN_SRC c++
        std::unique_ptr<IPCSender> createIPCSender(IPCFutexPageQueue* futexPageQueue, IPCHandler* handler)
        {
          return std::unique_ptr<IPCSender>(new IPCSenderImpl(futexPageQueue, handler));
        }
      #+END_SRC

***** -> IPCSenderImpl => send()
      实际调用了 ~IPCCommunicator => doSendBufferOnly()~ 来发送 IPC 消息：
      #+NAME: IPCSender.cpp
      #+BEGIN_SRC c++
        std::unique_ptr<IPCResult> IPCSenderImpl::send(IPCBuffer* buffer)
        {
          doSendBufferOnly(buffer);
          if (checkBufferAsync(buffer))
            return createVoidResult();

          while (true) {
            uint32_t msg = doReadPackage();
            bool isAsync = !!(msg & MSG_FLAG_ASYNC);
            msg &= MSG_MASK;
            // 通过抛异常方式结束消息发送循环
            if (msg == MSG_END) {
              std::unique_ptr<IPCResult> result = assembleResult();
              releaseBlob();
              return result;
            } else if (msg == MSG_TERMINATE) {
              releaseBlob();
              throw IPCException("peer terminates");
            }
            std::unique_ptr<IPCArguments> arguments = assembleArguments();
            releaseBlob();
            std::unique_ptr<IPCResult> sendBack = m_handler->handle(msg, arguments.get());
            if (!isAsync) {
              std::unique_ptr<IPCBuffer> resultBuffer = generateResultBuffer(sendBack.get());
              doSendBufferOnly(resultBuffer.get());
            }
          }
        }
      #+END_SRC

      Weex 底层提供的 IPC 交互方式是通过 ~memcpy()~ 方法创建共享内存的方式来实现的：
      #+NAME: IPCCommunicator.cpp
      #+BEGIN_SRC c++
        void IPCCommunicator::doSendBufferOnly(const void* _data, size_t length)
        {
          const char* data = static_cast<const char*>(_data);
          size_t pageSize = m_futexPageQueue->getPageSize();
          ssize_t byteTransfered;
          uint32_t* dstLength = static_cast<uint32_t*>(m_futexPageQueue->getCurrentWritePage());
          // special handle the first part, which need a size
          // as header.
          dstLength[0] = length;

          IPC_LOGD("send bytes: length: %zu", length);
          byteTransfered = std::min(length, pageSize - sizeof(uint32_t));
          // 将发送的消息，写到共享内存中
          memcpy(dstLength + 1, data, byteTransfered);
          m_futexPageQueue->stepWrite();
          // multiple page package
          if (length > byteTransfered) {
            data += byteTransfered;
            length -= byteTransfered;
            IPC_LOGD("sent bytes: remaining length: %zu, transfered: %zu", length, byteTransfered);

            while (length > 0) {
              byteTransfered = doSendBufferPage(data, length, pageSize);
              data += byteTransfered;
              length -= byteTransfered;
              IPC_LOGD("sent bytes: remaining length: %zu, transfered: %zu", length, byteTransfered);
            }
          }
        }
      #+END_SRC

**** DONE Android IPCListener
     CLOSED: [2018-10-27 Sat 01:00]

***** WeexJSConnection => newIPCServer() -> listener
      在创建 IPC 服务的时候创建了 IPCListener 的实例,并开启了消息监听:
      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        static void *newIPCServer(void *_td) {
          // other code...
          // 创建了 IPCListener 来接收消息
          std::unique_ptr<IPCListener> listener =std::move(createIPCListener(futexPageQueue.get(), handler)) ;
          try {
            // 启动 IPC 消息监听 looper
            listener->listen();
          } catch (IPCException &e) {
            // other code...
          }
        }

      #+END_SRC
***** -> IPCListener => createIPCListener()
      创建一个 ~IPCListener~, 实际创建的是 ~IPCListenerImpl~ 的一个实例,它内部实现了 ~listen()~ 方法:

      #+NAME: IPCListener.cpp
      #+BEGIN_SRC c++
        std::unique_ptr<IPCListener> createIPCListener(IPCFutexPageQueue* futexPageQueue, IPCHandler* handler) {
          return std::unique_ptr<IPCListener>(new IPCListenerImpl(futexPageQueue, handler));
        }
      #+END_SRC

***** -> Ipclistenerimpl => listen()
      ~IPCListenerImpl~ 内部实现的 ~listen()~ 方法, 在线程中开启消息队列, 从共享内存中读取 ~IPCSender~ 写入的消息, 并交给 ~IPCHandler~ 来处理:
      #+NAME:IPCListener.cpp
      #+BEGIN_SRC c++
        void IPCListenerImpl::listen() {
          // 开启一个消息循环
          while (true) {
            uint32_t msg = doReadPackage();
            bool isAsync = !!(msg & MSG_FLAG_ASYNC);
            msg &= MSG_MASK;
            // 抛异常的方式结束消息循环
            if (msg == MSG_END)
              throw IPCException("unexpected MSG_END");
            else if (msg == MSG_TERMINATE) {
              releaseBlob();
              throw IPCException("peer terminates");
            }
            std::unique_ptr<IPCArguments> arguments = assembleArguments();
            releaseBlob();
            IPCArguments*  pArguments = arguments.get();
            // IPCHandler 来处理收到的消息和参数
            std::unique_ptr<IPCResult> sendBack = m_handler->handle(msg, pArguments);
            if (!isAsync) {
              std::unique_ptr<IPCBuffer> resultBuffer = generateResultBuffer(sendBack.get());
              doSendBufferOnly(resultBuffer.get());
            }
          }
        }
      #+END_SRC

**** DONE Android IPCHandler
     CLOSED: [2018-10-27 Sat 14:40]
***** WeexJSConnection => newIPCServer() -> handler
      #+NAME: WeexJSConnection.cpp
      #+BEGIN_SRC c++
        static void *newIPCServer(void *_td) {
          // other code...
          // 初始化 IPCHandler 来处理消息
          const std::unique_ptr<IPCHandler> &testHandler = createIPCHandler();
          // other code...
        }
      #+END_SRC
***** -> IPCHandler => createIPCHandler()
      ~createIPCHandler()~ 实际上创建了一个 ~IPCHandlerImpl~ 的实例，它内部实现了 ~handle()~ 方法:
      #+BEGIN_SRC c++
        std::unique_ptr<IPCHandler> createIPCHandler()
        {
          return std::unique_ptr<IPCHandler>(new IPCHandlerImpl);
        }
      #+END_SRC
***** -> IPCHandlerImpl => handler()
      #+BEGIN_SRC c++
        std::unique_ptr<IPCResult> IPCHandlerImpl::handle(uint32_t msg, IPCArguments* arguments)
        {
          auto it = m_map.find(msg);
          if (it == m_map.end()) {
            IPC_LOGE("unable to find msg: %d", msg);
            return createVoidResult();
          }
          return it->second(arguments);
        }
      #+END_SRC
***** 注册 IPCHandler
      IPCHandlerImpl 中用一个 Map 数据结构来存储各种 IPC 消息的回调方法:
      #+NAME: IPCHandler.cpp
      #+BEGIN_SRC c++
        class IPCHandlerImpl : public IPCHandler {
          // other code...
        private:
          typedef std::unordered_map<int, std::function<std::unique_ptr<IPCResult>(IPCArguments*)>> MapType;
          // IPCHandlerImpl 中持有一个消息回调方法的 map
          MapType m_map;
        };
      #+END_SRC

      注册消息回调的方法, 比较简单，就是将一个 int 值作为 key，将一个回调方法作为 value 插入到声明好的一个 Map 中:
      #+NAME: IPCHandler.cpp
      #+BEGIN_SRC c++
        void IPCHandlerImpl::registerHandler(int msg, const std::function<std::unique_ptr<IPCResult>(IPCArguments*)>& handler)
        {
          m_map.insert(MapType::value_type(msg, handler));
        }
      #+END_SRC
***** 内部的 IPCHandler 注册时机
      是的,还是这个熟悉的方法 ~WXBridge=>nativeInitFramework()~ -> ~wx_bridge => InitFramework()~.
      由于 IPC 的方式只存在于开启多进程的情况下，所以内置的 ~IPCHandler~ 也只在多进程模式下被注册：
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c++
        static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
          // other code
          // Android SDK 中默认的 ProjectMode = MULTI_PROCESS，所以会初始化 ScriptBridgeInMultiProcess.
          if (WeexCoreManager::Instance()->project_mode() == WeexCoreManager::ProjectMode::MULTI_PROCESS) {
            WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
          }
          // other code
        }
      #+END_SRC

      ~ScriptBridgeInMultiProcess~ 的构造方法中，会调用内部的 IPCCallback 注册：
      #+NAME: script_bridge_in_multi_process.cpp
      #+BEGIN_SRC c++
        ScriptBridgeInMultiProcess::ScriptBridgeInMultiProcess() {
          // other code...
          [this](IPCHandler *handler) { RegisterIPCCallback(handler); }
            // other code...
        }
      #+END_SRC

***** 默认注册的 IPCHandler

      ~ScriptBridgeInMultiProcess => RegisterIPCCallback()~ 方法中，注册了很多内置的 IPC 回调方法:
      #+NAME: script_bridge_in_multi_process.cpp
      #+BEGIN_SRC c++
        void ScriptBridgeInMultiProcess::RegisterIPCCallback(IPCHandler *handler) {
          LOGE("RegisterIPCCallback is running");
          handler->registerHandler(static_cast<uint32_t>(IPCProxyMsg::SETJSFVERSION),
                                   HandleSetJSVersion);
          //省略了一系列 registerHandler 方法
        }
      #+END_SRC

      ~RegisterIPCCallback()~ 方法中注册的所有的 ~IPCHandler~ 回调：
      #+NAME: IPCProxyMsg 对应关系（方法中省略了参数）
      | Key(enum IPCProxyMsg) | Handler Value               | Function(Ignore arguments)                   | Source File             |
      |-----------------------+-----------------------------+----------------------------------------------+-------------------------|
      | SETJSFVERSION         | HandleSetJSVersion          | public void setJSFrmVersion()                | WXBridge.java           |
      | REPORTEXCEPTION       | HandleReportException       | public void reportJSException()              | WXBridge.java           |
      | CALLNATIVE            | HandleCallNative            | public int callNative()                      | WXBridge.java           |
      | CALLNATIVEMODULE      | HandleCallNativeModule      | public Object callNativeModule()             | WXBridge.java           |
      | CALLNATIVECOMPONENT   | HandleCallNativeComponent   | public void callNativeComponent()            | WXBridge.java           |
      | CALLADDELEMENT        | HandleCallAddElement        | public int callAddElement()                  | WXBridge.java           |
      | SETTIMEOUT            | HandleSetTimeout            | public void setTimeoutNative()               | WXBridge.java           |
      | NATIVELOG             | HandleCallNativeLog         | public void d(String msg)                    | WXLogUtils.java         |
      | CALLCREATEBODY        | FunctionCallCreateBody      | public int callCreateBody()                  | WXBridge.java           |
      | CALLUPDATEFINISH      | FunctionCallUpdateFinish    | public int callUpdateFinish()                | WXBridge.java           |
      | CALLCREATEFINISH      | FunctionCallCreateFinish    | public int callCreateFinish()                | WXBridge.java           |
      | CALLREFRESHFINISH     | FunctionCallRefreshFinish   | public int callRefreshFinish()               | WXBridge.java           |
      | CALLUPDATEATTRS       | FunctionCallUpdateAttrs     | public int callUpdateAttrs()                 | WXBridge.java           |
      | CALLUPDATESTYLE       | FunctionCallUpdateStyle     | public int callUpdateStyle()                 | WXBridge.java           |
      | CALLREMOVEELEMENT     | FunctionCallRemoveElement   | public int callRemoveElement()               | WXBridge.java           |
      | CALLMOVEELEMENT       | FunctionCallMoveElement     | public int callMoveElement()                 | WXBridge.java           |
      | CALLADDEVENT          | FunctionCallAddEvent        | public int callAddEvent()                    | WXBridge.java           |
      | CALLREMOVEEVENT       | FunctionCallRemoveEvent     | public int callRemoveElement()               | WXBridge.java           |
      |-----------------------+-----------------------------+----------------------------------------------+-------------------------|
      | CALLGCANVASLINK       | HandleCallGCanvasLinkNative | const char *CallGCanvasFun()                 | ExtendJSApi.cpp         |
      | CALLT3DLINK           | HandleT3DLinkNative         | const char* CallT3dFunc()                    | ExtendJSApi.cpp         |
      | SETINTERVAL           | HandleSetInterval           | int CoreSideInScript::SetInterval()          | code_side_in_script.cpp |
      | CLEARINTERVAL         | HandleClearInterval         | int CoreSideInScript::ClearInterval()        | code_side_in_script.cpp |
      | POSTMESSAGE           | HandlePostMessage           | static void Java_WMLBridge_postMessage()     | wml_bridge.cpp          |
      | DISPATCHMESSAGE       | HandleDispatchMessage       | static void Java_WMLBridge_dispatchMessage() | wml_bridge.cpp          |

*** Native 注册 Module
    <<weex_core_register_module>>

**** Android 注册 Module

*** Native 注册 Component
    <<weex_core_register_component>>

*** Native 渲染流程分析
    <<weex_core_render>>

    ~WXBridgeManager => invokeExecJS()~ 之后通过 ~WXBridge => execJS()~ 调用到了底层的方法：
    #+NAME: WXBridgeManager.java
    #+BEGIN_SRC java
    // METHOD_CREATE_INSTANCE = "createInstance"
    invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
    #+END_SRC

    之后的流程就是通过 IPC 以消息的方式通知到 JSFramework 环境调用响应的方法。
