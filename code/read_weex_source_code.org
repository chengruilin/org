#+TITLE: Weex 源码分析
#+TODO: TODO(t) DOING(d!) PAUSE(p!) RESUME(r!) | DONE(e)

* TODO Weex Source Code [7/11]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:

** DONE Weex 使用相关
   CLOSED: [2018-10-22 一 10:57]
*** DONE Weex 扩展(Android)
    CLOSED: [2018-10-11 四 11:11]

**** DONE Module
     CLOSED: [2018-10-10 三 17:56]
     
     实现源码分析:[[weex_register_module][传送门]]

     Module 扩展非 UI 功能
     1. extends WXModule
     2. @JsMethod(uiThread = false or true)
     3. public function
     4. -keep public class * extends com.taobao.weex.common.WXModule{*;}
     5. 方法参数:int,double,float,String,Map,List
     6. Register: WXSDKEngine.registerModule("myModule", MyModule.class);

     Weex Module Sample:
     #+BEGIN_SRC java
       public class MyModule extends WXModule {

           //run ui thread
           @JSMethod (uiThread = true)
           public void printLog(String msg) {
               Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();
           }

           //run JS thread
           @JSMethod (uiThread = false)
           public void fireEventSyncCall(){
               //implement your module logic here
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <text onclick="click">testMyModule</text>
         </div>
       </template>

       <script>
         module.exports = {
           methods: {
             click: function() {
               weex.requireModule('MyModule').printLog("I am a weex Module");
             }
           }
         }
       </script>
     #+END_SRC

**** DONE Component
     CLOSED: [2018-10-10 三 17:56]

     实现源码分析:[[weex_register_component][传送门]]

     Component 扩展实现 Native 控件
     1. extends WXComponent
     2. @WXComponentProp(name=value(value is attr or style of dsl))
     3. -keep public class * extends com.taobao.weex.common.WXComponent{*;}
     4. 方法参数:int,double,float,String,Map,List
     5. WXSDKEngine.registerComponent("richText", RichText.class);

     Weex Component Sample:
     #+BEGIN_SRC java
       public class RichText extends WXComponent<TextView> {

           public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) {
               super(instance, dom, parent);
           }

           @Override
           protected TextView initComponentHostView(@NonNull Context context) {
               TextView textView = new TextView(context);
               textView.setTextSize(20);
               textView.setTextColor(Color.BLACK);
               return textView;
           }

           @WXComponentProp(name = "tel")
           public void setTel(String telNumber) {
               getHostView().setText("tel: " + telNumber);
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerComponent("richText", RichText.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <richText tel="12305" style="width:200;height:100">12305</richText>
         </div>
       </template>
     #+END_SRC

**** DONE Adapter
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "DOING"      [2018-10-10 三 17:55]
***** IWXImgLoaderAdapter
      图片加载适配器,使用方法:
      #+BEGIN_SRC java
        public class ImageAdapter implements IWXImgLoaderAdapter {

            public ImageAdapter() {
            }

            @Override
            public void setImage(final String url, final ImageView view,
                                 WXImageQuality quality, WXImageStrategy strategy) {

                WXSDKManager.getInstance().postOnUiThread(new Runnable() {

                        @Override
                        public void run() {
                            if(view==null||view.getLayoutParams()==null){
                                return;
                            }
                            if (TextUtils.isEmpty(url)) {
                                view.setImageBitmap(null);
                                return;
                            }
                            String temp = url;
                            if (url.startsWith("//")) {
                                temp = "http:" + url;
                            }
                            if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {
                                return;
                            }
                            Picasso.with(WXEnvironment.getApplication())
                                .load(temp)
                                .into(view);
                        }
                    },0);
            }
        }
      #+END_SRC
***** IWXHttpAdapter
      网络请求适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXHttpAdapter {
            void sendRequest(WXRequest request, OnHttpListener listener);
        }
      #+END_SRC
***** IWXUserTrackAdapter
      埋点适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXUserTrackAdapter {
            void commit(Context context, String eventId, String type, WXPerformance perf, Map<String, Serializable> params);
        }
      #+END_SRC
***** IActivityNavBarSetter
      Weex 导航适配器,使用方法:
      #+BEGIN_SRC java
      WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){});
      #+END_SRC
***** IWXStorageAdapter
      本地存储适配器,默认 DefaultWXStorage
***** IWXJSExceptionAdapter
      处理 JS 异常,默认忽略

*** DONE Lifecycle
    CLOSED: [2018-10-11 四 10:31]
    - State "DOING"      from "TODO"       [2018-10-10 三 18:12]
**** Workflow
     此处图片出处: [[https://github.com/alibaba/weex/issues/331?spm=a2c4e.11153940.blogcont59936.9.75012203aFrbFG][WeexLiftcycle 的讨论]]
     Create Instance:
     [[./weex/imgs/img_weex_lifecycle_create_instance.jpeg]]

     Refresh Instance:
     [[./weex/imgs/img_weex_lifecycle_refresh_instance.jpeg]]

     Fire Event/Callback:
     [[./weex/imgs/img_weex_lifecycle_fire_event.jpeg]]

     Destroy Instance:
     [[./weex/imgs/img_weex_lifecycle_destroy_instance.jpeg]]

     Navigate:
     [[./weex/imgs/img_weex_lifecycle_navigate.jpeg]]

**** 组件生命周期解析

     生命周期图解:
     #+BEGIN_EXAMPLE
      ------      --------      -------             -----------
     | init | -> | create | -> | ready |           | destroyed |
      ------      --------      -------             -----------
     #+END_EXAMPLE

     生命周期用法:
     #+BEGIN_SRC javascript
       <script>
         module.exports = {
           data: {},
           methods: {},

           init: function () {
             console.log('在初始化内部变量，并且添加了事件功能后被触发');
           },
           created: function () {
             console.log('完成数据绑定之后，模板编译之前被触发');
           },
           ready: function () {
             console.log('模板已经编译并且生成了 Virtual DOM 之后被触发');
           },
           destroyed: function () {
             console.log('在页面被销毁时调用');
           }
         }
       </script>
     #+END_SRC

***** init:
      - 初始化内部变量,添加事件功能
      - 没有执行数据绑定,没有创建 Virtual-DOM,所以不能通过 this 获取到 data 中的数据,不能调用到 methods 中定义的方法,也不能获取到 Virtual-DOM 的节点
      - 可以在方法内初始化一些内部变量,绑定一些自定义事件

      created:
      - 刚完成数据绑定,还没开始编译模板
      - 可以通过 this 操作 data 中的数据,可以调用 methods 中的方法,但是不能获取到 Virtual-DOM 的节点
      - 可以在方法中修改 data 中数据,不会触发额外的渲染

***** ready:
      - 表示组件已经渲染完成
      - 首先执行子组件的 ready 方法
      - 可以获得 Virtual-DOM 的节点,也可以获取子组件的 Virtual-DOM 实例
      - 小心操作 data,避免频繁赋值
      - 建议去除需要频繁改动的值,等操作执行结束之后再赋值

      [[./weex/imgs/img_weex_lifecycle_parent_son.png]]

      避免频繁赋值:
      #+BEGIN_SRC javascript
       // 在修改 this.count 前先获取它的值，在执行完操作后再赋值回去，如果在循环体中直接设置 this.count 的值，页面将触发 999 次局部刷新，很可能会导致页面卡顿
       module.exports = {
         data: {
           count: 0
         },
         ready: function () {
           var count = this.count;
           for (var i = 0; i < 999; i++) {
             count += Math.random();
           }
           this.count = count;
         }
       }
      #+END_SRC

***** destroyed
      - 组件销毁时被调用
      - 自底向上执行(先触发子组件的 destroyed 方法,再触发自身的)
      - 先执行开发者定义的 destroyed 方法,再清除内部属性
      - 添加的全局或者 this 的属性,建议在 destroyed 方法中手动清除,避免内存泄露

** DONE 架构分析
   CLOSED: [2018-10-24 三 16:33]
*** 调用流程图
    [[./weex/imgs/img_weex_arch_flow.png]]

*** 框架结构图
    图片出处: https://zhuanlan.zhihu.com/p/25326775
    [[./weex/imgs/img_weex_framework_classes.jpeg]]

*** 线程模型
    <<weex_thread>>
    
**** Weex 线程间交互关系图
     [[./weex/imgs/img_weex_threads.jpg]]
*** 项目目录结构
    
    #+NAME: Weex 目录结构(选择性列了一些比较重要的目录)
    #+BEGIN_EXAMPLE
    ./incubator-weex                        # 根目录 
    ---------------------------------------------------------------------------------
        - android/                          # Android SDK 相关目录
            - commons/                      # 
            - playground/                   # Android 模板工程
            - sdk/                          # Android Weex SDK
    ---------------------------------------------------------------------------------        
        - ios/                              # iOS SDK 相关
            - playground/                   # iOS 模板工程
            - sdk/                          # iOS Weex SDK
    ---------------------------------------------------------------------------------
        - packages/                         # 打包好的 JSFramework 库
            - weex-js-framework/            # 
            - weex-js-runtime/              # 
            - weex-legacy-framework/        # 
            - weex-vanilla-framework/       # 
    ---------------------------------------------------------------------------------        
        - runtime/                          # JSFramework 源码目录 
            - api/                          # 
            - bridge/                       # 
            - entries/                      # 
            - frameworks/                   # 
            - services/                     # 
            - shared/                       # 
            - vdom/                         # 
    ---------------------------------------------------------------------------------            
        - script/                           # 一些脚本文件
    ---------------------------------------------------------------------------------
        - weex_core/Source                  # Weex 底层支持代码
            - IPC/                          # [Android] IPC 通信层
            - android/                      # [Android] JNI 层
            - base/                         # 
            - core/                         # 
            - include/                      # 
            - third_party/                  # 
            - wson/                         # wson 支持
            - CMakeLists.txt                # CMake 打包脚本
    #+END_EXAMPLE
    
** DOING 源码分析-Android
*** 初始化流程分析
    整个初始化的流程,简单来说就是:
    1. 获取 Application 对象
    2. 读取初始化的 Config 参数
    3. 配置 so 的加载方式，然后加载 weexcore.so 库
    4. 加载打包在本地的 JSFramework 组件，调用 native 的方法初始化 JS 环境
    5. 注册所有内置的 Weex Component 组件和 Module 组件

**** WXSDKEngine -> initialize
     Weex 官方文档中的初始化方法：
     #+BEGIN_SRC java
       public class WXApplication extends Application {
           @Override
           public void onCreate() {
               super.onCreate();
               InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();
               WXSDKEngine.initialize(this,config);
           }
       }
     #+END_SRC

     此处调用了 WXSDKEngine 方法，那么这个方法里面做了什么事情呢，我们来看下：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // com.taobao.weex.WXSDKEngine
       public static void initialize(Application application,InitConfig config){
           synchronized (mLock) {
               if (mIsInit) {
                   return;
               }
               // 此处省略，大概就是记录初始化耗时，设置日志级别什么的
               doInitInternal(application,config);
               registerApplicationOptions(application);
               mIsInit = true;
           }
       }
     #+END_SRC
     这里需要重点关注的就是 doInitInternal 和 registerApplicationOptions 这两个方法。
**** WXSDKEngine -> doInitInternal
     其实主要初始化的工作都是由 doInitInternal 这个方法完成的，我们来看下它的代码：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       private static void doInitInternal(final Application application,final InitConfig config){
           // 获取 Application 对象
           WXEnvironment.sApplication = application;
           // 如果 Application 对象为空，传递异常给到 JS
           if(application == null){
               WXLogUtils.e(TAG, " doInitInternal application is null");
               WXExceptionUtils.commitCriticalExceptionRT(null,
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                          "doInitInternal",
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "WXEnvironment sApplication is null",
                                                          null);
           }
           WXEnvironment.JsFrameworkInit = false;
           // 这里的操作在线程中完成
           WXBridgeManager.getInstance().post(new Runnable() {
                   @Override
                   public void run() {
                       // 又要统计初始化时间什么的，忽略
                       WXSDKManager sm = WXSDKManager.getInstance();
                       sm.onSDKEngineInitialize();

                       // 设置 Weex 初始化的 Congif 参数(可以为空)
                       if(config != null ) {
                           sm.setInitConfig(config);
                       }
                       // 初始化 SoLoaderAdapter 默认直接调用 System.loadLibrary(so...)
                       WXSoInstallMgrSdk.init(application,
                                              sm.getIWXSoLoaderAdapter(),
                                              sm.getWXStatisticsListener());
                       // 加载 V8 so 库，一个叫 weexcore.so 的库
                       mIsSoInit = WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
                       if (!mIsSoInit) {
                           WXExceptionUtils.commitCriticalExceptionRT(null,
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                                      "doInitInternal",
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "isSoInit false",
                                                                      null);
                           return;
                       }
                       // 调用 WXBridgeManager 的 initScriptsFramework 方法，一系列调用最终调用到了 WXBridgeManager 的 initFramework 方法，我们后续再看
                       sm.initScriptsFramework(config!=null?config.getFramework():null);
                   }
               });
           // 注册了一堆默认的 Component
           register();
       }
     #+END_SRC

     可以看到其中几步重要的操作通过 ~WXBridgeManager.getInstance().post()~ 在线程中完成,详细的线程模型可以查 [[weex_thread]]:
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
     WXBridgeManager.getInstance().post(new Runnable() {
               @Override
               public void run() {
                   // do something
               }
           };
     #+END_SRC
     其中有两个重要的方法,继续往下追 ~initFramework~ 方法和 ~register~ 方法,分两小节来介绍.

***** WXBridgeManager -> initFramework
      可能需要了解下这里的 framework 是什么概念, [[weex_jsframework][传送门]].

      先来看下 InitConfig 的 framework 为空的情况(这个参数默认为空):
      #+NAME: WXBridgeManager.java
      #+BEGIN_SRC java
        // InitConfig -> framework 默认为空
        private void initFramework(String framework) {
            // 首先检查 so 文件是否初始化成功
            if (WXSDKEngine.isSoInitialized() && !isJSFrameworkInit()) {
                if (TextUtils.isEmpty(framework)) {
                    // isSandBoxContext 默认为 true
                    if (!isSandBoxContext) {
                        framework = WXFileUtils.loadAsset("main.js", WXEnvironment.getApplication());
                    } else {
                        // 默认加载 assets 目录下的 weex-main-jsfm.js 文件来启动 JSFramework
                        framework = WXFileUtils.loadAsset("weex-main-jsfm.js", WXEnvironment.getApplication());
                    }
                }
                if (TextUtils.isEmpty(framework)) {
                    // 抛出异常到 JS 端显示
                    return;
                }
                try {
                    //监听 JSFramework 启动状态
                    if (WXSDKManager.getInstance().getWXStatisticsListener() != null) {
                        WXSDKManager.getInstance().getWXStatisticsListener().onJsFrameworkStart();
                    }

                    String crashFile = "";
                    try {
                        crashFile = WXEnvironment.getApplication().getApplicationContext().getCacheDir().getPath();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    boolean pieSupport = true;
                    try {
                        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
                            pieSupport = false;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    // extends initFramework
                    // 调用 WXBridge -> initFramework -> nativeInitFramework -> weexcore.so 底层方法初始化 JSFramework
                    if (mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport) == INIT_FRAMEWORK_OK) {
                        // 打了一堆日志(渲染速度监控相关的)
                        setJSFrameworkInit(true);

                        //监听 JSFramework 准备状态
                        if (WXSDKManager.getInstance().getWXStatisticsListener() != null) {
                            WXSDKManager.getInstance().getWXStatisticsListener().onJsFrameworkReady();
                        }
                        // Module/Component/JSService 有注册失败的话,在这里可以完成重新注册
                        execRegisterFailTask();
                        // 注册 Dom Module
                        registerDomModule();
                    } else {
                        //抛异常到 JS
                    }
                } catch (Throwable e) {
                    //抛异常到 JS
                }

            }
        }
      #+END_SRC

      有关 Module 注册: [[weex_register_module][传送门]]
      有关 Component 注册: [[weex_register_module][传送门]]

***** native -> initFramework
      上一节中提到的 initFramework 代码 ~mWXBridge.initFrameworkEnv(framework, assembleDefaultOptions(), crashFile, pieSupport)~ 实际调用的是 native 层的代码:
      #+NAME: wx_bridge.cpp
      #+BEGIN_SRC c
        static jint InitFramework(JNIEnv* env, jobject object, jstring script, jobject params) {
          WXBridge::Instance()->Reset(env, object);
          // Init platform thread --- ScriptThread
          WeexCoreManager::Instance()->InitScriptThread();
          // Exception handler for so
          SoUtils::RegisterExceptionHanler([](const char* status_code, const char* error_msg) {
              WeexCoreManager::Instance()
                ->getPlatformBridge()
                ->platform_side()
                ->ReportNativeInitStatus(status_code, error_msg);
            });
          // Init platform bridge
          PlatformBridge* bridge = new AndroidBridgeInSimple;
          WeexCoreManager::Instance()->set_platform_bridge(bridge);
          // Init params
          std::vector<INIT_FRAMEWORK_PARAMS*> params_vector = initFromParam(env, params, [](const char* status_code, const char* error_msg) {
              WeexCoreManager::Instance()
                ->getPlatformBridge()
                ->platform_side()
                ->ReportNativeInitStatus(status_code, error_msg);
            });
          // If parse init params error, return false
          if (params_vector.empty()) return false;
          // Set project mode
          if (isSingleProcess()) {
            WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_SO);
          } else {
            WeexCoreManager::Instance()->set_project_mode(WeexCoreManager::ProjectMode::MULTI_PROCESS);
          }
          // Init script bridge
          if (WeexCoreManager::Instance()->project_mode() ==
              WeexCoreManager::ProjectMode::MULTI_PROCESS) {
            WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiProcess);
          } else {
            WeexCoreManager::Instance()->set_script_bridge(new ScriptBridgeInMultiSo);
          }
          // It means initialization failed when any bridge is not passable
          if (!WeexCoreManager::Instance()->getPlatformBridge()->is_passable() ||
              !WeexCoreManager::Instance()->script_bridge()->is_passable()) {
            return false;
          }
          // for environment
          bridge->core_side()->SetPlatform(WXCoreEnvironment::getInstance()->platform());
          bridge->core_side()->SetDeviceWidthAndHeight(WXCoreEnvironment::getInstance()->DeviceWidth(), WXCoreEnvironment::getInstance()->DeviceHeight());
          auto options = WXCoreEnvironment::getInstance()->options();
          auto it = options.begin();
          for (; it != options.end(); it++) {
            bridge->core_side()->AddOption(it->first, it->second);
          }
          // Set measure function
          WeexCoreManager::Instance()->set_measure_function_adapter(new MeasureFunctionAdapterImplAndroid());
          bridge->core_side()->SetMeasureFunctionAdapter();
          ScopedJStringUTF8 c_script(env, script);
          // Call InitFramework
          auto result = bridge->core_side()->InitFramework(c_script.getChars(), params_vector);
          freeParams(params_vector);
          return result;
        }
      #+END_SRC
***** WXSDKEngine -> regiser
      ~WXSDKEngine~ 的 ~register~ 方法注册了一系列内置的 Component 和 Module
      #+NAME: 内嵌的 Component 组件
      | Component         | Class                         |
      |-------------------+-------------------------------|
      | text              | WXText.class                  |
      | image             | WXImage.class                 |
      | img               | WXImage.class                 |
      | div               | WXDiv.class                   |
      | container         | WXDiv.class                   |
      | header            | WXDiv.class                   |
      | footer            | WXDiv.class                   |
      | scroller          | WXScroller.class              |
      | slider            | WXSlider.class                |
      | cycleslider       | WXSlider.class                |
      | slider-neighbor   | WXSliderNeighbor.class        |
      | cell              | WXCell.class                  |
      | list              | WXListComponent.class         |
      | vlist             | WXListComponent.class         |
      | recycler          | WXListComponent.class         |
      | waterfall         | WXListComponent.class         |
      | simplelist        | SimpleListComponent.class     |
      | recycler-list     | WXRecyclerTemplateList.class  |
      | hlist             | HorizontalListComponent.class |
      | cell-slot         | WXCell.class                  |
      | indicator         | WXIndicator.class             |
      | video             | WXVideo.class                 |
      | input             | WXInput.class                 |
      | textarea          | WXTextarea.class              |
      | switch            | WXSwitch.class                |
      | a                 | WXA.class                     |
      | embed             | WXEmbed.class                 |
      | web               | WXWeb.class                   |
      | refresh           | WXRefresh.class               |
      | loading           | WXLoading.class               |
      | loading-indicator | WXLoadingIndicator.class      |
      | header            | WXHeader.class                |

      #+NAME: 内嵌的 Module 组件
      | Module       | Class                     |
      |--------------+---------------------------|
      | modal        | WXModalUIModule.class     |
      | instanceWrap | WXInstanceWrap.class      |
      | animation    | WXAnimationModule.class   |
      | webview      | WXWebViewModule.class     |
      | navigator    | WXNavigatorModule.class   |
      | stream       | WXStreamModule.class      |
      | timer        | WXTimerModule.class       |
      | storage      | WXStorageModule.class     |
      | clipboard    | WXClipboardModule.class   |
      | globalEvent  | WXGlobalEventModule.class |
      | picker       | WXPickersModule.class     |
      | meta         | WXMetaModule.class        |
      | webSocket    | WebSocketModule.class     |
      | locale       | WXLocaleModule.class      |

**** WXSDKEngine -> registerApplicationOptions
     可以认为是获取了 App 的一些环境配置
     | key                  | value                                      |
     |----------------------+--------------------------------------------|
     | screen_width_pixels  | resources.getDisplayMetricx().widthPixels  |
     | screen_height_pixels | resources.getDisplayMetricx().heightPixels |
     | status_bar_height    | get status bar height                      |

     获取 status_bar_height 的方式：
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // com.taobao.weex.WXSDKEngine
       int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android");
       if (resourceId > 0) {
           int statusBarHeight = resources.getDimensionPixelSize(resourceId);
           registerCoreEnv("status_bar_height", String.valueOf(statusBarHeight));
       }
     #+END_SRC
*** Weex 页面渲染流程分析
    #+NAME: Weex 加载页面的调用
    #+BEGIN_SRC java
      public class MainActivity extends AppCompatActivity implements IWXRenderListener {

          WXSDKInstance mWXSDKInstance;

          @Override
          protected void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.activity_main);

              mWXSDKInstance = new WXSDKInstance(this);
              mWXSDKInstance.registerRenderListener(this);
              /**
               ,* WXSample 可以替换成自定义的字符串，针对埋点有效。
               ,* template 是.we transform 后的 js 文件。
               ,* option 可以为空，或者通过 option 传入 js 需要的参数。例如 bundle js 的地址等。
               ,* jsonInitData 可以为空。
               ,* width 为-1 默认全屏，可以自己定制。
               ,* height =-1 默认全屏，可以自己定制。
               ,*/
              mWXSDKInstance.render("WXSample", WXFileUtils.loadFileContent("hello.js", this), null, null, -1, -1, WXRenderStrategy.APPEND_ASYNC);
          }

          /* other methods */
      }
    #+END_SRC
    来分析下 WXSDKInstance -> render() 方法的内部实现, 除了参数检查之外,它其实调用的是内部的 rednerInternal 方法.

**** WXSDKInstance -> renderInternal
     redner 方法内部调用了内部的 renderInternal 方法来进行 Weex 页面的渲染，来看下代码：
     #+NAME: WXSDKInstance.class
     #+BEGIN_SRC java
      /**
       ,* Render template asynchronously
       ,*
       ,* @param pageName, used for performance log.
       ,* @param template bundle js
       ,* @param options  os   iphone/android/ipad
       ,*                 weexversion    Weex version(like 1.0.0)
       ,*                 appversion     App version(like 1.0.0)
       ,*                 devid        Device id(like Aqh9z8dRJNBhmS9drLG5BKCmXhecHUXIZoXOctKwFebH)
       ,*                 sysversion    Device system version(like 5.4.4、7.0.4, should be used with os)
       ,*                 sysmodel     Device model(like iOS:"MGA82J/A", android:"MI NOTE LTE")
       ,*                 Time    UNIX timestamp, UTC+08:00
       ,*                 TTID(Optional)
       ,*                 MarkertId
       ,*                 Appname(Optional)  tm,tb,qa
       ,*                 Bundleurl(Optional)  template url
       ,* @param jsonInitData Initial data for rendering
       ,* @param flag     RenderStrategy {@link WXRenderStrategy}
       ,*/
      private void renderInternal(String pageName,
                                  String template,
                                  Map<String, Object> options,
                                  String jsonInitData,
                                  WXRenderStrategy flag){
          // 此处省略各种参数检查
          // 此处省略数据埋点

          // 检查 RenderContainer 是否为空，为空的话创建一个
          ensureRenderArchor();

          Map<String, Object> renderOptions = options;
          if (renderOptions == null) {
              renderOptions = new HashMap<>();
          }
          if (WXEnvironment.sDynamicMode && !TextUtils.isEmpty(WXEnvironment.sDynamicUrl) && renderOptions.get("dynamicMode") == null) {
              renderOptions.put("dynamicMode", "true");
              // 根据 URL 渲染，最终还是调用到 renderInternal 方法，最终还是会调用 WXSDKManager -> createInstance 方法
              renderByUrl(pageName, WXEnvironment.sDynamicUrl, renderOptions, jsonInitData, flag);
              return;
          }
          WXSDKManager.getInstance().setCrashInfo(WXEnvironment.WEEX_CURRENT_KEY,pageName);
          // 渲染页面，会调用 WXBridgeManager -> createInstance 方法
          WXSDKManager.getInstance().createInstance(this, template, renderOptions, jsonInitData);
          mRendered = true;
      }
     #+END_SRC
**** WXBridgeManager -> createInstance
     render 方法调用最终会调用到这个方法中
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       public void createInstance(final String instanceId, final String template,
                                  final Map<String, Object> options, final String data) {
           final WXSDKInstance instance = WXSDKManager.getInstance().getSDKInstance(instanceId);
           // 此处省略  WXSDKInstance 为空检查

           if (!isJSFrameworkInit() && reInitCount == 1 && !WXEnvironment.sDebugServerConnectable) {
               //  错误日志
               post(new Runnable() {
                       @Override
                       public void run() {
                           // 再次初始化 JSFramework 环境
                           initFramework("");
                       }
                   }, instanceId);
               return;
           }

           WXModuleManager.createDomModule(instance);
           post(new Runnable() {
                   @Override
                   public void run() {
                       // 省略一堆性能日志代码
                       invokeCreateInstance(instance, template, options, data);
                   }
               }, instanceId);
       }
     #+END_SRC

     来看下 createInstance 方法最后调用到的 invokeCreateInstance 方法
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       private void invokeCreateInstance(@NonNull WXSDKInstance instance, String template,
                                         Map<String, Object> options, String data) {
           // add for sandbox, will delete on sandbox ok
           initFramework("");

           if (mMock) {
               mock(instance.getInstanceId());
           } else {

               //省略 JSFramework 环境检查

               WXModuleManager.registerWhenCreateInstance();
               try {
                   BundType type = BundType.Others;
                   try {
                       type = getBundleType(instance.getBundleUrl(), template);
                   } catch (Throwable e) {
                   }

                   try {
                       if (options == null) {
                           options = new HashMap<>();
                       }
                       // on file there is { "framework": "Vue" } or others
                       if (options.get(BUNDLE_TYPE) == null) {
                           // may vue or Rax
                           if (type == BundType.Vue) {
                               options.put(BUNDLE_TYPE, "Vue");
                           } else if (type == BundType.Rax) {
                               options.put(BUNDLE_TYPE, "Rax");
                           } else {
                               options.put(BUNDLE_TYPE, "Others");
                           }
                           instance.getApmForInstance().addProperty(WXInstanceApm.KEY_PAGE_PROPERTIES_BUNDLE_TYPE, options.get(BUNDLE_TYPE));
                       }
                       if (options.get("env") == null) {
                           options.put("env", mInitParams.toMap());
                       }
                   } catch (Throwable e) {
                       e.printStackTrace();
                   }
                   instance.bundleType = type;

                   // 省略日志什么的

                   WXJSObject instanceIdObj = new WXJSObject(WXJSObject.String, instance.getInstanceId());
                   WXJSObject instanceObj = new WXJSObject(WXJSObject.String, template);
                   WXJSObject optionsObj = new WXJSObject(WXJSObject.JSON,
                                                          options == null ? "{}"
                                                          : WXJsonUtils.fromObjectToJSONString(options));
                   optionsObj = optionObjConvert(isSandBoxContext, type, optionsObj);
                   WXJSObject dataObj = new WXJSObject(WXJSObject.JSON,
                                                       data == null ? "{}" : data);

                   WXJSObject apiObj;
                   if (type == BundType.Rax) {
                       if (mRaxApi == null) {
                           mRaxApi =  WXFileUtils.loadAsset("weex-rax-api.js", WXEnvironment.getApplication());
                       }
                       apiObj = new WXJSObject(WXJSObject.String,
                                               mRaxApi);
                   } else {
                       apiObj = new WXJSObject(WXJSObject.String,
                                               "");
                   }

                   // When render strategy is data_render, put it into options. Others keep null.
                   WXJSObject renderStrategy = null;
                   if (instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                       renderStrategy = new WXJSObject(WXJSObject.String, WXRenderStrategy.DATA_RENDER.getFlag());
                   }

                   WXJSObject[] args = {instanceIdObj, instanceObj, optionsObj,
                                        dataObj, apiObj, renderStrategy};
                   instance.setTemplate(template);
                   instance.getApmForInstance().onStage(WXInstanceApm.KEY_PAGE_STAGES_LOAD_BUNDLE_END);

                   if (!isSandBoxContext) {
                       invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                       return;
                   }
                   if (type == BundType.Vue || type == BundType.Rax
                       || instance.getRenderStrategy() == WXRenderStrategy.DATA_RENDER) {
                       invokeCreateInstanceContext(instance.getInstanceId(), null, "createInstanceContext", args, false);
                       return;
                   } else {
                   invokeExecJS(instance.getInstanceId(), null, METHOD_CREATE_INSTANCE, args, false);
                       return;
                   }
               } catch (Throwable e) {
                   // 处理异常
               }
           }
       }
     #+END_SRC
     这里最终处理完交给 WXBridge 来调用 execJS -> nativeExecJS
*** JS Bridge
    来看下 Android 的 SDK 中用来和 JS Engine（V8）进行双向通信的代码,主要的类有 WXBridgeManager.java 和 WXBridge.java.
    与 native 的 JS 方法的调用都运行在 JsBridge 线程中。
**** WXBridgeManager.java
     负责通过 WXBridge.java 提供的一系列 native 接口,来完成 Java 环境和 JS 之间的交互.

**** WXBridge.java
     封装了一层 Java 层和 JNI 层关于 JS 调用的接口,内部实现了一堆 native 调用方法.
**** 注册 Component
     <<weex_register_component>>

     再来看下如何手动注册一个 Component 组件:
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       // 调用 SDK 提供的 API 注册一个 Component 实现
       WXSDKEngine.registerComponent("richText", RichText.class);

       // 实际调用的注册方法
       public static boolean registerComponent(Map<String, Object> componentInfo, Class<? extends WXComponent> clazz) throws WXException {
           if(componentInfo == null){
               return false;
           }
           String type = (String)componentInfo.get("type");
           if(TextUtils.isEmpty(type)){
               return false;
           }
           return WXComponentRegistry.registerComponent(type,new SimpleComponentHolder(clazz), componentInfo);
       }
     #+END_SRC
     
     WXComponentRegistry -> registerComponent
     #+NAME: WXComponentRegistry.java
     #+BEGIN_SRC java
       public static synchronized boolean registerComponent(final String type, final IFComponentHolder holder, final Map<String, Object> componentInfo) throws WXException {
           if (holder == null || TextUtils.isEmpty(type)) {
               return false;
           }

           //register component
           AutoScanConfigRegister.preLoad(holder);

           //execute task in js thread to make sure register order is same as the order invoke register method.
           WXBridgeManager.getInstance()
               .post(new Runnable() {
                       @Override
                       public void run() {
                           try {
                               Map<String, Object> registerInfo = componentInfo;
                               if (registerInfo == null){
                                   registerInfo = new HashMap<>();
                               }

                               registerInfo.put("type",type);
                               registerInfo.put("methods",holder.getMethods());
                               // 注册 Component 到本地的一个静态变量 ConcurrentHashMap -> sTypeComponentMap 中
                               registerNativeComponent(type, holder);
                               // 调用 WXBridgeManager -> invokeRegisterComponents 方法
                               registerJSComponent(registerInfo);
                               sComponentInfos.add(registerInfo);
                           } catch (WXException e) {
                               WXLogUtils.e("register component error:", e);
                           }

                       }
       }
     #+END_SRC
     
     WXBridgeManager -> invokeRegisterComponents
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       private void invokeRegisterComponents(List<Map<String, Object>> components, List<Map<String, Object>> failReceiver) {
           if (components == failReceiver) {
               throw new RuntimeException("Fail receiver should not use source.");
           }
           if (!isJSFrameworkInit()) {
               // JSFramework 还没初始化成功,丢到 failReceiver 列表中,等 JSFramework 初始化成功之后重新注册
               for (Map<String, Object> comp : components) {
                   failReceiver.add(comp);
               }
               return;
           }
           if (components == null) {
               return;
           }
           WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(components)};
           try {
               // 调用 WXBridge.java 提供的 JNI 方法,注册到 JS 环境中
               if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_COMPONENTS, args)) {
                   errorMsg = "execJS error";
               }
           } catch (Throwable e) {
               // 省略异常日志输出
           }
           // 省略异常日志输出
       }
     #+END_SRC
     
**** 注册 Module
     <<weex_register_module>>

     来看下 Android 应用中注册 Module 的方式:
     #+BEGIN_SRC java
     WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC
     
     WXSDKEngine -> registerModule
     #+NAME: WXSDKEngine.java
     #+BEGIN_SRC java
       /**
        ,* Register module. This is a wrapper method for
        ,* {@link #registerModule(String, Class, boolean)}. The module register here only need to
        ,* be singleton in {@link WXSDKInstance} level.
        ,* @param moduleName  module name
        ,* @param moduleClass module to be registered.
        ,* @return true for registration success, false for otherwise.
        ,* {@link WXModuleManager#registerModule(String, ModuleFactory, boolean)}
        ,*/
       public static <T extends WXModule> boolean registerModule(String moduleName, Class<T> moduleClass,boolean global) throws WXException {
           return moduleClass != null && registerModule(moduleName, new TypeModuleFactory<>(moduleClass), global);
       }

       public static <T extends WXModule> boolean registerModule(String moduleName, ModuleFactory factory, boolean global) throws WXException {
           return WXModuleManager.registerModule(moduleName, factory,global);
       }
     #+END_SRC
     
     WXModuleManager -> regiserModule
     #+NAME: WXModuleManager.java
     #+BEGIN_SRC java
       public static boolean registerModule(final String moduleName, final ModuleFactory factory, final boolean global) throws WXException {
           // 省略一系列的参数检查

           //execute task in js thread to make sure register order is same as the order invoke register method.
           WXBridgeManager.getInstance()
               .post(new Runnable() {
                       @Override
                       public void run() {
                           try {
                               // 将注册的 Module 相关参数放到一个静态的 volatile ConcurrentHashMap 中
                               registerNativeModule(moduleName, factory);
                           } catch (WXException e) {
                           }
                           // 省略 global Module map

                           // 调用 WXSDKManager 的 registerJSModules 方法
                           registerJSModule(moduleName, factory);
                       }
                   });
           return true;
       }

       static boolean registerJSModule(String moduleName, ModuleFactory factory) {
           Map<String, Object> modules = new HashMap<>();
           modules.put(moduleName, factory.getMethods());
           // WXSDKManager 中调用了 WXBridgeManager -> registerModules 方法
           WXSDKManager.getInstance().registerModules(modules);
           return true;
       }
     #+END_SRC

     WXBridgeManager -> registerModules
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       public void registerModules(final Map<String, Object> modules) {
           if (modules != null && modules.size() != 0) {
               // 确保是在 JSThread 中完成注册
               if (isJSThread()) {
                   invokeRegisterModules(modules, mRegisterModuleFailList);
               } else {
                   post(new Runnable() {
                           @Override
                           public void run() {
                               invokeRegisterModules(modules, mRegisterModuleFailList);
                           }
                       }, null);
               }
           }
       }
     #+END_SRC

     WXBridgeManager -> invokeRegisterModules
     #+NAME: WXBridgeManager.java
     #+BEGIN_SRC java
       private void invokeRegisterModules(Map<String, Object> modules, List<Map<String, Object>> failReceiver) {
           if (modules == null || !isJSFrameworkInit()) {
               // JSFramework 没有初始化的情况下放到 failReceiver 列表中,下次 initFramework 的时候再次注册
               failReceiver.add(modules);
               return;
           }

           WXJSObject[] args = {WXWsonJSONSwitch.toWsonOrJsonWXJSObject(modules)};
           try {
               // 通过 WXBridge.java 的 JNI 方法调用,完成 Module 注册到 JS 环境中
               if(0 == mWXBridge.execJS("", null, METHOD_REGISTER_MODULES, args)) {
                   errorMsg = "execJS error";
               }
               // 注册成功之后调用 WXModuleManager.resetModuleState(module, true); 方法更新 module 状态
           } catch (Throwable e) {
           }
           //忽略错误信息打印
       }
     #+END_SRC

*** Android Render Engine
** TODO 源码分析-iOS
*** 初始化流程分析

*** JS Bridge

*** iOS Render Engine

** TODO 源码分析-JS
*** JSFramework
    <<weex_jsframework>>
**** framework 是个啥?
     Weex 通过调用 JS Framework 提供的接口来调用原生功能并且渲染真实 UI.代码层面其实就是 weex 提供的一个 js 库,用来完成 js 调用原生功能的一个组件.
**** 配置 framework
     在 weex 初始化时,通过设置 InitConfig 的 framework 参数,来配置 framework
     #+NAME: InitConfig.java
     #+BEGIN_SRC java
     InitConfig config=new InitConfig.Builder().setFramework("your framework").build();
     #+END_SRC
** TODO Weex Core 代码分析
