#+TITLE: Weex 源码分析
#+TODO: TODO(t) DOING(d!) PAUSE(p!) RESUME(r!) | DONE(e)

* TODO Weex Source Code [6/7]
  :PROPERTIES:
  :COOKIE_DATA: todo recursive
  :END:

** DONE Weex 使用相关
   CLOSED: [2018-10-22 一 10:57]
   - State "DOING"      from "TODO"       [2018-10-10 三 17:56]
*** DONE Weex 扩展(Android)
    CLOSED: [2018-10-11 四 11:11]

**** DONE Module
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "TODO"       [2018-10-10 三 17:42]

     Module 扩展非 UI 功能
     1. extends WXModule
     2. @JsMethod(uiThread = false or true)
     3. public function
     4. -keep public class * extends com.taobao.weex.common.WXModule{*;}
     5. 方法参数:int,double,float,String,Map,List
     6. Register: WXSDKEngine.registerModule("myModule", MyModule.class);

     Weex Module Sample:
     #+BEGIN_SRC java
       public class MyModule extends WXModule {

           //run ui thread
           @JSMethod (uiThread = true)
           public void printLog(String msg) {
               Toast.makeText(mWXSDKInstance.getContext(),msg,Toast.LENGTH_SHORT).show();
           }

           //run JS thread
           @JSMethod (uiThread = false)
           public void fireEventSyncCall(){
               //implement your module logic here
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerModule("MyModule", MyModule.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <text onclick="click">testMyModule</text>
         </div>
       </template>

       <script>
         module.exports = {
           methods: {
             click: function() {
               weex.requireModule('MyModule').printLog("I am a weex Module");
             }
           }
         }
       </script>
     #+END_SRC

**** DONE Component
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "TODO"       [2018-10-10 三 17:42]

     Component 扩展实现 Native 控件
     1. extends WXComponent
     2. @WXComponentProp(name=value(value is attr or style of dsl))
     3. -keep public class * extends com.taobao.weex.common.WXComponent{*;}
     4. 方法参数:int,double,float,String,Map,List
     5. WXSDKEngine.registerComponent("richText", RichText.class);

     Weex Component Sample:
     #+BEGIN_SRC java
       public class RichText extends WXComponent<TextView> {

           public RichText(WXSDKInstance instance, WXDomObject dom, WXVContainer parent) {
               super(instance, dom, parent);
           }

           @Override
           protected TextView initComponentHostView(@NonNull Context context) {
               TextView textView = new TextView(context);
               textView.setTextSize(20);
               textView.setTextColor(Color.BLACK);
               return textView;
           }

           @WXComponentProp(name = "tel")
           public void setTel(String telNumber) {
               getHostView().setText("tel: " + telNumber);
           }
       }
     #+END_SRC

     Register code:
     #+BEGIN_SRC java
       WXSDKEngine.registerComponent("richText", RichText.class);
     #+END_SRC

     Js call:
     #+BEGIN_SRC html
       <template>
         <div>
           <richText tel="12305" style="width:200;height:100">12305</richText>
         </div>
       </template>
     #+END_SRC

**** DONE Adapter
     CLOSED: [2018-10-10 三 17:56]
     - State "DOING"      from "DOING"      [2018-10-10 三 17:55]
***** IWXImgLoaderAdapter
      图片加载适配器,使用方法:
      #+BEGIN_SRC java
        public class ImageAdapter implements IWXImgLoaderAdapter {

            public ImageAdapter() {
            }

            @Override
            public void setImage(final String url, final ImageView view,
                                 WXImageQuality quality, WXImageStrategy strategy) {

                WXSDKManager.getInstance().postOnUiThread(new Runnable() {

                        @Override
                        public void run() {
                            if(view==null||view.getLayoutParams()==null){
                                return;
                            }
                            if (TextUtils.isEmpty(url)) {
                                view.setImageBitmap(null);
                                return;
                            }
                            String temp = url;
                            if (url.startsWith("//")) {
                                temp = "http:" + url;
                            }
                            if (view.getLayoutParams().width <= 0 || view.getLayoutParams().height <= 0) {
                                return;
                            }
                            Picasso.with(WXEnvironment.getApplication())
                                .load(temp)
                                .into(view);
                        }
                    },0);
            }
        }
      #+END_SRC
***** IWXHttpAdapter
      网络请求适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXHttpAdapter {
            void sendRequest(WXRequest request, OnHttpListener listener);
        }
      #+END_SRC
***** IWXUserTrackAdapter
      埋点适配器,接口定义:
      #+BEGIN_SRC java
        public interface IWXUserTrackAdapter {
            void commit(Context context, String eventId, String type, WXPerformance perf, Map<String, Serializable> params);
        }
      #+END_SRC
***** IActivityNavBarSetter
      Weex 导航适配器,使用方法:
      #+BEGIN_SRC java
      WXSDKEngine.setActivityNavBarSetter(new IActivityNavBarSetter(){});
      #+END_SRC
***** IWXStorageAdapter
      本地存储适配器,默认 DefaultWXStorage
***** IWXJSExceptionAdapter
      处理 JS 异常,默认忽略

*** DONE Lifecycle
    CLOSED: [2018-10-11 四 10:31]
    - State "DOING"      from "TODO"       [2018-10-10 三 18:12]
**** Workflow
     此处图片出处: [[https://github.com/alibaba/weex/issues/331?spm=a2c4e.11153940.blogcont59936.9.75012203aFrbFG][WeexLiftcycle 的讨论]]
     Create Instance:
     [[./weex/imgs/img_weex_lifecycle_create_instance.jpeg]]

     Refresh Instance:
     [[./weex/imgs/img_weex_lifecycle_refresh_instance.jpeg]]

     Fire Event/Callback:
     [[./weex/imgs/img_weex_lifecycle_fire_event.jpeg]]

     Destroy Instance:
     [[./weex/imgs/img_weex_lifecycle_destroy_instance.jpeg]]

     Navigate:
     [[./weex/imgs/img_weex_lifecycle_navigate.jpeg]]

**** 组件生命周期解析

     生命周期图解:
     #+BEGIN_EXAMPLE
      ------      --------      -------             -----------
     | init | -> | create | -> | ready |           | destroyed |
      ------      --------      -------             -----------
     #+END_EXAMPLE

     生命周期用法:
     #+BEGIN_SRC javascript
       <script>
         module.exports = {
           data: {},
           methods: {},

           init: function () {
             console.log('在初始化内部变量，并且添加了事件功能后被触发');
           },
           created: function () {
             console.log('完成数据绑定之后，模板编译之前被触发');
           },
           ready: function () {
             console.log('模板已经编译并且生成了 Virtual DOM 之后被触发');
           },
           destroyed: function () {
             console.log('在页面被销毁时调用');
           }
         }
       </script>
     #+END_SRC

***** init:
      - 初始化内部变量,添加事件功能
      - 没有执行数据绑定,没有创建 Virtual-DOM,所以不能通过 this 获取到 data 中的数据,不能调用到 methods 中定义的方法,也不能获取到 Virtual-DOM 的节点
      - 可以在方法内初始化一些内部变量,绑定一些自定义事件

      created:
      - 刚完成数据绑定,还没开始编译模板
      - 可以通过 this 操作 data 中的数据,可以调用 methods 中的方法,但是不能获取到 Virtual-DOM 的节点
      - 可以在方法中修改 data 中数据,不会触发额外的渲染

***** ready:
      - 表示组件已经渲染完成
      - 首先执行子组件的 ready 方法
      - 可以获得 Virtual-DOM 的节点,也可以获取子组件的 Virtual-DOM 实例
      - 小心操作 data,避免频繁赋值
      - 建议去除需要频繁改动的值,等操作执行结束之后再赋值

      [[./weex/imgs/img_weex_lifecycle_parent_son.png]]

      避免频繁赋值:
      #+BEGIN_SRC javascript
       // 在修改 this.count 前先获取它的值，在执行完操作后再赋值回去，如果在循环体中直接设置 this.count 的值，页面将触发 999 次局部刷新，很可能会导致页面卡顿
       module.exports = {
         data: {
           count: 0
         },
         ready: function () {
           var count = this.count;
           for (var i = 0; i < 999; i++) {
             count += Math.random();
           }
           this.count = count;
         }
       }
      #+END_SRC

***** destroyed
      - 组件销毁时被调用
      - 自底向上执行(先触发子组件的 destroyed 方法,再触发自身的)
      - 先执行开发者定义的 destroyed 方法,再清除内部属性
      - 添加的全局或者 this 的属性,建议在 destroyed 方法中手动清除,避免内存泄露

** DOING 源码分析
   - State "DOING"      from "TODO"       [2018-10-16 二 15:23]

*** 整体架构

    官方结构图:
    [[./weex/imgs/img_weex_arch_flow.png]]

    [[file:weex/imgs/img_weex_framework_classes.jpeg][依赖关系图（图片比较大，摘自知乎）]]

*** 初始化流程分析
**** 初始化方法
     Weex 官方文档中的初始化方法：
     #+BEGIN_SRC java
       public class WXApplication extends Application {
           @Override
           public void onCreate() {
               super.onCreate();
               InitConfig config=new InitConfig.Builder().setImgAdapter(new ImageAdapter()).build();
               WXSDKEngine.initialize(this,config);
           }
       }
     #+END_SRC
     此处调用了 WXSDKEngine 方法，那么这个方法里面做了什么事情呢，我们来看下：
     #+BEGIN_SRC java
       // com.taobao.weex.WXSDKEngine
       public static void initialize(Application application,InitConfig config){
           synchronized (mLock) {
               if (mIsInit) {
                   return;
               }
               // 此处省略，大概就是记录初始化耗时，设置日志级别什么的
               doInitInternal(application,config);
               registerApplicationOptions(application);
               mIsInit = true;
           }
       }
     #+END_SRC
     这里需要重点关注的就是 doInitInternal 和 registerApplicationOptions 这两个方法。
**** registerApplicationOptions 方法
     可以认为是获取了 App 的一些环境配置
     | key                  | value                                      |
     |----------------------+--------------------------------------------|
     | screen_width_pixels  | resources.getDisplayMetricx().widthPixels  |
     | screen_height_pixels | resources.getDisplayMetricx().heightPixels |
     | status_bar_height    | get status bar height                      |

     获取 status_bar_height 的方式：
     #+BEGIN_SRC java
       int resourceId = resources.getIdentifier("status_bar_height", "dimen", "android");
       if (resourceId > 0) {
           int statusBarHeight = resources.getDimensionPixelSize(resourceId);
           registerCoreEnv("status_bar_height", String.valueOf(statusBarHeight));
       }
     #+END_SRC
**** doInitInternal 方法
     其实主要初始化的工作都是由 doInitInternal 这个方法完成的，我们来看下它的代码：
     #+BEGIN_SRC java
       private static void doInitInternal(final Application application,final InitConfig config){
           // 获取 Application 对象
           WXEnvironment.sApplication = application;
           // 如果 Application 对象为空，传递异常给到 JS
           if(application == null){
               WXLogUtils.e(TAG, " doInitInternal application is null");
               WXExceptionUtils.commitCriticalExceptionRT(null,
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                          "doInitInternal",
                                                          WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "WXEnvironment sApplication is null",
                                                          null);
           }
           WXEnvironment.JsFrameworkInit = false;

           WXBridgeManager.getInstance().post(new Runnable() {
                   @Override
                   public void run() {
                       // 又要统计初始化时间什么的，忽略
                       WXSDKManager sm = WXSDKManager.getInstance();
                       sm.onSDKEngineInitialize();

                       if(config != null ) {
                           sm.setInitConfig(config);
                       }
                       // 初始化 SoLoaderAdapter 默认直接调用 System.loadLibrary(so...)
                       WXSoInstallMgrSdk.init(application,
                                              sm.getIWXSoLoaderAdapter(),
                                              sm.getWXStatisticsListener());
                       // 加载 V8 so 库，一个叫 weexcore.so 的库
                       mIsSoInit = WXSoInstallMgrSdk.initSo(V8_SO_NAME, 1, config!=null?config.getUtAdapter():null);
                       if (!mIsSoInit) {
                           WXExceptionUtils.commitCriticalExceptionRT(null,
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT,
                                                                      "doInitInternal",
                                                                      WXErrorCode.WX_KEY_EXCEPTION_SDK_INIT.getErrorMsg() + "isSoInit false",
                                                                      null);
                           return;
                       }
                       // 调用 WXBridgeManager 的 initScriptsFramework 方法，一系列调用最终调用到了 WXBridgeManager 的 initFramework 方法，我们后续再看
                       sm.initScriptsFramework(config!=null?config.getFramework():null);
                   }
               });
           // 注册了一堆默认的 Component
           register();
       }
     #+END_SRC
*** JS Bridge
    主要用来和 JS Engine（V8）进行双向通信，运行在 JsBridge 进程中。

**** 注册 Component

     实际注册 Component 的方法： ~com.taobao.weex.ui.WXComponentRegistry~
     #+BEGIN_SRC java
       public static synchronized boolean registerComponent(final String type, final IFComponentHolder holder, final Map<String, Object> componentInfo) throws WXException {
           if (holder == null || TextUtils.isEmpty(type)) {
               return false;
           }

           //register component
           AutoScanConfigRegister.preLoad(holder);

           //execute task in js thread to make sure register order is same as the order invoke register method.
           WXBridgeManager.getInstance()
               .post(new Runnable() {
                       @Override
                       public void run() {
                           try {
                               Map<String, Object> registerInfo = componentInfo;
                               if (registerInfo == null){
                                   registerInfo = new HashMap<>();
                               }

                               registerInfo.put("type",type);
                               registerInfo.put("methods",holder.getMethods());
                               registerNativeComponent(type, holder);
                               registerJSComponent(registerInfo);
                               sComponentInfos.add(registerInfo);
                           } catch (WXException e) {
                               WXLogUtils.e("register component error:", e);
                           }

                       }
       }
     #+END_SRC
*** Render
**** Android Render Engine
**** iOS Render Engine

**** H5 Render Engine
