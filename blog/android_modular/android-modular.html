<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Android 组件化方案</title>
<meta name="author" content="(茄子)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.css"/>

<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/night.css" id="theme"/>

<link rel="stylesheet" href="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'http://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Android 组件化方案</h1><h2 class="author">茄子</h2><p class="date">Created: 2019-04-20 Sat 18:46</p>
</section>

<section>
<section id="slide-org84a6bf5">
<h2 id="org84a6bf5">概述</h2>
<p>
目前有赞移动端的主要工作内容是在“有赞微商城”和“有赞零售”两条公司主要的业务线，随着有赞 Saas 业务的增长，客户端也不断迭代，支持越来越多的功能。在这个业务快速增长的情况下，移动端技术的整体架构也是一直在不断调整，来保证开发效率和业务的快速迭代。
</p>

</section>
<section id="slide-orga8bd88b">
<h3 id="orga8bd88b">现状</h3>
<p>
客户端的架构，也从一开始的“All IN ONE” 模式（即所有代码都在 App 中），逐渐演变到目前的一个单 Project 多 Module 结构：
<img src="./imgs/old_modular_arch.jpg" alt="old_modular_arch.jpg" />
</p>

</section>
<section id="slide-org73fbede">
<h3 id="org73fbede">痛点</h3>
<ul>
<li>日益复杂的 Common 模块，逻辑复杂，依赖不清晰，不敢随便改动 Common 代码，造成大量冗余代码和无法维护的业务逻辑</li>
<li>随着业务模块的增多，打包速度一发不可收拾；从倒杯水的时间到下楼吃个饭的时间，大大减慢了开发节奏</li>
<li>由于业务模块跟项目中的上层（App 壳）和下层（Common 模块）耦合</li>
<li>业务模块增多，由于业务模块没有自己的生命周期，无法实现模块之间的隔离，整体模块控制比较混乱</li>

</ul>

</section>
<section id="slide-orgf9e7e99">
<h3 id="orgf9e7e99">需要解决的问题</h3>
<ul>
<li>去 Common 化，需要将 Common 层的业务向上抽离，通用的底层和基础组件、公用 UI 组件抽成单独的依赖</li>
<li>移动端业务服务化，解耦现有业务，抽象出业务接口，业务模块只向外暴露自己的接口，并实现跨模块之间的调用</li>
<li>能够配置单模块或者多模块打包，不用每次调试都全量打包，费时费力，又影响开发的节奏</li>
<li>业务模块的依赖和发布管理</li>

</ul>

</section>
</section>
<section>
<section id="slide-org377a9dc">
<h2 id="org377a9dc">架构调整</h2>
<div class="outline-text-2" id="text-org377a9dc">
</div>
</section>
<section id="slide-org7d36bf0">
<h3 id="org7d36bf0">公共业务去中心化</h3>
<p>
跟很多客户端的同学聊过，很多 APP 发展到一定阶段之后，必然会诞生一个所谓的 Common 模块。它就像一个大储物柜，每个人都把一些其他人可能用到的东西一股脑儿塞进去。这么个塞法，会有两个问题：
</p>
<ol>
<li>冗余：比如一些工具类，很多时候，当你找不到需要的工具类的时候，你可能会塞一个新的进去</li>
<li>维护成本高：所有公用的业务逻辑的实现都在 Common 中，对一些公用业务逻辑的影响面无法掌控</li>

</ol>

</section>
<section id="slide-org7aba3b4">
<h4 id="org7aba3b4">Common 里面都有什么？</h4>
<ul>
<li>工具类</li>
<li>公用的 UI 组件</li>
<li>多个业务模块都公用的业务类</li>
<li>基础组件的封装类（图片库、网络库、Webview）</li>
<li>封装的一些基类（BaseActivity，BaseFragment 什么的）</li>
<li>等等等等</li>

</ul>

</section>
<section id="slide-orge034dc4">
<h4 id="orge034dc4">解决的思路</h4>
<ul>
<li>将公用的业务模块向上抽离到业务模块中（所谓业务模块的服务化）</li>
<li>将基础组件抽象到一个独立的组件中</li>
<li>将一些基下沉到不包含业务逻辑的底层核心库中</li>

</ul>

</section>
<section id="slide-org2383115">
<h3 id="org2383115">业务模块服务化</h3>
<p>
“服务化”这个词，好像是在服务端的开发中经常被提到，简单来说，就是根据业务划分为多个模块，模块之间的交互以互相提供服务的方式来完成。而客户端随着业务模块的增多，也必然存在业务模块之间存在业务依赖的情况，客户端这边老的处理方式一般有两种：
</p>
<ol>
<li>A 模块直接依赖 B 模块，直接调用 B 模块的代码逻辑</li>
<li>将 A 模块中的公用部分放到 Common 模块中，提供给其他模块调用</li>

</ol>

</section>
<section id="slide-org0927f94">
<h4 id="org0927f94">将各个业务模块的实现隔离</h4>

</section>
<section id="slide-orgc9ecd89">
<h4 id="orgc9ecd89">服务的方式解决耦合不可控的问题</h4>

</section>
<section id="slide-org35e626d">
<h3 id="org35e626d">基础组件抽象</h3>

</section>
<section id="slide-org36d105a">
<h3 id="org36d105a">单/多模块快速打包</h3>

</section>
<section id="slide-org4fd8fb3">
<h3 id="org4fd8fb3">组件发布优化</h3>

</section>
</section>
<section>
<section id="slide-org9efb27e">
<h2 id="org9efb27e">Android-Modular-Plugin</h2>
<div class="outline-text-2" id="text-org9efb27e">
</div>
</section>
<section id="slide-org7b58c9e">
<h3 id="org7b58c9e">不改变现有的开发模式</h3>

</section>
<section id="slide-orga2436a2">
<h3 id="orga2436a2">单模块打包</h3>

</section>
<section id="slide-org134b5f3">
<h3 id="org134b5f3">模块 API 层和业务层隔离</h3>

</section>
<section id="slide-org2de760e">
<h3 id="org2de760e">模块间依赖管理</h3>

</section>
<section id="slide-orgf3392c5">
<h3 id="orgf3392c5">模块发布</h3>

</section>
</section>
<section>
<section id="slide-org342c775">
<h2 id="org342c775">Android-Core</h2>

</section>
</section>
<section>
<section id="slide-org34940c0">
<h2 id="org34940c0">Android-Support</h2>
<div class="outline-text-2" id="text-org34940c0">
</div>
</section>
<section id="slide-org480c017">
<h4 id="org480c017">Native-Support</h4>

</section>
<section id="slide-org13d463a">
<h4 id="org13d463a">Weex-Support</h4>

</section>
<section id="slide-org8a81c84">
<h4 id="org8a81c84">ReactNative-Support</h4>

</section>
<section id="slide-org0394f49">
<h4 id="org0394f49">Flutter-Support</h4>

</section>
</section>
<section>
<section id="slide-orgfca7a6a">
<h2 id="orgfca7a6a">规划</h2>
</section>
</section>
</div>
</div>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
<script src="http://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'http://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }]
});
</script>
</body>
</html>
